(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

// a simple wrapper around a single arraybuffer

module.exports = Buffer;

function Buffer(buffer) {
    if (!buffer) {
        this.array = new ArrayBuffer(this.defaultLength);
        this.length = this.defaultLength;
        this.setupViews();

    } else {
        // we only recreate buffers after receiving them from workers for binding to gl,
        // so we only need these 2 properties
        this.array = buffer.array;
        this.pos = buffer.pos;
    }
}

Buffer.prototype = {
    pos: 0,
    itemSize: 4, // bytes in one item
    defaultLength: 8192, // initial buffer size
    arrayType: 'ARRAY_BUFFER', // gl buffer type

    get index() {
        return this.pos / this.itemSize;
    },

    setupViews: function() {
        // set up views for each type to add data of different types to the same buffer
        this.ubytes = new Uint8Array(this.array);
        this.bytes = new Int8Array(this.array);
        this.ushorts = new Uint16Array(this.array);
        this.shorts = new Int16Array(this.array);
    },

    // binds the buffer to a webgl context
    bind: function(gl) {
        var type = gl[this.arrayType];
        if (!this.buffer) {
            this.buffer = gl.createBuffer();
            gl.bindBuffer(type, this.buffer);
            gl.bufferData(type, new DataView(this.array, 0, this.pos), gl.STATIC_DRAW);

            // dump array buffer once it's bound to gl
            this.array = null;
        } else {
            gl.bindBuffer(type, this.buffer);
        }
    },

    destroy: function(gl) {
        if (this.buffer) {
            gl.deleteBuffer(this.buffer);
        }
    },

    // increase the buffer size by 50% if a new item doesn't fit
    resize: function() {
        if (this.length < this.pos + this.itemSize) {

            while (this.length < this.pos + this.itemSize) {
                // increase the length by 50% but keep it even
                this.length = Math.round(this.length * 1.5 / 2) * 2;
            }

            // array buffers can't be resized, so we create a new one and reset all bytes there
            this.array = new ArrayBuffer(this.length);

            var ubytes = new Uint8Array(this.array);
            ubytes.set(this.ubytes);

            this.setupViews();
        }
    }
};

},{}],2:[function(require,module,exports){
'use strict';

var LineVertexBuffer = require('./linevertexbuffer.js');
var LineElementBuffer = require('./lineelementbuffer.js');
var FillVertexBuffer = require('./fillvertexbuffer.js');
var FillElementBuffer = require('./fillelementsbuffer.js');
var OutlineElementBuffer = require('./outlineelementsbuffer.js');
var GlyphVertexBuffer = require('./glyphvertexbuffer.js');
var IconVertexBuffer = require('./iconvertexbuffer.js');

module.exports = function(bufferset) {
    bufferset = bufferset || {};
    return {
        glyphVertex: new GlyphVertexBuffer(bufferset.glyphVertex),
        iconVertex: new IconVertexBuffer(bufferset.iconVertex),
        fillVertex: new FillVertexBuffer(bufferset.fillVertex),
        fillElement: new FillElementBuffer(bufferset.fillElement),
        outlineElement: new OutlineElementBuffer(bufferset.outlineElement),
        lineVertex: new LineVertexBuffer(bufferset.lineVertex),
        lineElement: new LineElementBuffer(bufferset.lineElement)
    };
};

},{"./fillelementsbuffer.js":3,"./fillvertexbuffer.js":4,"./glyphvertexbuffer.js":5,"./iconvertexbuffer.js":6,"./lineelementbuffer.js":7,"./linevertexbuffer.js":8,"./outlineelementsbuffer.js":9}],3:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = FillElementsBuffer;

function FillElementsBuffer(buffer) {
    Buffer.call(this, buffer);
}

FillElementsBuffer.prototype = Object.create(Buffer.prototype);

FillElementsBuffer.prototype.itemSize = 6; // bytes per triangle (3 * unsigned short == 6 bytes)
FillElementsBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';

FillElementsBuffer.prototype.add = function(a, b, c) {
    var pos2 = this.pos / 2;

    this.resize();

    this.ushorts[pos2 + 0] = a;
    this.ushorts[pos2 + 1] = b;
    this.ushorts[pos2 + 2] = c;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],4:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = FillVertexBuffer;

function FillVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

FillVertexBuffer.prototype = Object.create(Buffer.prototype);

FillVertexBuffer.prototype.itemSize = 4; // bytes per vertex (2 * short == 4 bytes)

FillVertexBuffer.prototype.add = function(x, y) {
    var pos2 = this.pos / 2;

    this.resize();

    this.shorts[pos2 + 0] = x;
    this.shorts[pos2 + 1] = y;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],5:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = GlyphVertexBuffer;

function GlyphVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

GlyphVertexBuffer.prototype = Object.create(Buffer.prototype);

GlyphVertexBuffer.prototype.defaultLength = 2048 * 16;
GlyphVertexBuffer.prototype.itemSize = 16;

// Converts the 0..2pi to an int16 range
GlyphVertexBuffer.angleFactor = 128 / Math.PI;

GlyphVertexBuffer.prototype.add = function(x, y, ox, oy, tx, ty, angle, minzoom, range, maxzoom, labelminzoom) {
    var pos = this.pos,
        pos2 = pos / 2,
        angleFactor = GlyphVertexBuffer.angleFactor;

    this.resize();

    this.shorts[pos2 + 0] = x;
    this.shorts[pos2 + 1] = y;
    this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
    this.shorts[pos2 + 3] = Math.round(oy * 64);

    this.ubytes[pos + 8] = Math.floor((labelminzoom || 0) * 10);
    this.ubytes[pos + 9] = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 10] = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 11] = Math.round(angle * angleFactor) % 256;
    this.ubytes[pos + 12] = Math.max(Math.round(range[0] * angleFactor), 0) % 256;
    this.ubytes[pos + 13] = Math.min(Math.round(range[1] * angleFactor), 255) % 256;

    this.ubytes[pos + 14] = Math.floor(tx / 4);
    this.ubytes[pos + 15] = Math.floor(ty / 4);

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],6:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = GlyphVertexBuffer;

function GlyphVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

GlyphVertexBuffer.prototype = Object.create(Buffer.prototype);

GlyphVertexBuffer.prototype.defaultLength = 2048 * 20;
GlyphVertexBuffer.prototype.itemSize = 20;

// Converts the 0..2pi to an int16 range
GlyphVertexBuffer.angleFactor = 128 / Math.PI;

GlyphVertexBuffer.prototype.add = function(x, y, ox, oy, tx, ty, angle, minzoom, range, maxzoom, labelminzoom) {
    var pos = this.pos,
        pos2 = pos / 2,
        angleFactor = GlyphVertexBuffer.angleFactor;

    this.resize();

    this.shorts[pos2 + 0] = x;
    this.shorts[pos2 + 1] = y;
    this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
    this.shorts[pos2 + 3] = Math.round(oy * 64);

    this.ubytes[pos + 8] = Math.floor((labelminzoom || 0) * 10);
    this.ubytes[pos + 9] = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 10] = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.
    this.ubytes[pos + 11] = Math.round(angle * angleFactor) % 256;
    this.ubytes[pos + 12] = Math.max(Math.round(range[0] * angleFactor), 0) % 256;
    this.ubytes[pos + 13] = Math.min(Math.round(range[1] * angleFactor), 255) % 256;

    this.shorts[pos2 + 8] = tx;
    this.shorts[pos2 + 9] = ty;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],7:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = LineElementBuffer;

function LineElementBuffer(buffer) {
    Buffer.call(this, buffer);
}

LineElementBuffer.prototype = Object.create(Buffer.prototype);

LineElementBuffer.prototype.itemSize = 6; // bytes per triangle (3 * unsigned short == 6 bytes)
LineElementBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';

LineElementBuffer.prototype.add = function(a, b, c) {
    var pos2 = this.pos / 2;

    this.resize();

    this.ushorts[pos2 + 0] = a;
    this.ushorts[pos2 + 1] = b;
    this.ushorts[pos2 + 2] = c;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],8:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = LineVertexBuffer;

function LineVertexBuffer(buffer) {
    Buffer.call(this, buffer);
}

// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
LineVertexBuffer.extrudeScale = 63;

LineVertexBuffer.prototype = Object.create(Buffer.prototype);

LineVertexBuffer.prototype.itemSize = 8; // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
LineVertexBuffer.prototype.defaultLength = 32768;

// add a vertex to this buffer;
// x, y - vertex position
// ex, ey - extrude normal
// tx, ty - texture normal

LineVertexBuffer.prototype.add = function(point, extrude, tx, ty, linesofar) {
    var pos = this.pos,
        pos2 = pos / 2,
        index = this.index,
        extrudeScale = LineVertexBuffer.extrudeScale;

    this.resize();

    this.shorts[pos2 + 0] = (Math.floor(point.x) * 2) | tx;
    this.shorts[pos2 + 1] = (Math.floor(point.y) * 2) | ty;
    this.shorts[pos2 + 2] = Math.round(linesofar || 0);
    this.bytes[pos + 6] = Math.round(extrudeScale * extrude.x);
    this.bytes[pos + 7] = Math.round(extrudeScale * extrude.y);

    this.pos += this.itemSize;
    return index;
};

},{"./buffer.js":1}],9:[function(require,module,exports){
'use strict';

var Buffer = require('./buffer.js');

module.exports = OutlineElementsBuffer;

function OutlineElementsBuffer(buffer) {
    Buffer.call(this, buffer);
}

OutlineElementsBuffer.prototype = Object.create(Buffer.prototype);

OutlineElementsBuffer.prototype.itemSize = 4; // bytes per line (2 * unsigned short == 4 bytes)
OutlineElementsBuffer.prototype.arrayType = 'ELEMENT_ARRAY_BUFFER';

OutlineElementsBuffer.prototype.add = function(a, b) {
    var pos2 = this.pos / 2;

    this.resize();

    this.ushorts[pos2 + 0] = a;
    this.ushorts[pos2 + 1] = b;

    this.pos += this.itemSize;
};

},{"./buffer.js":1}],10:[function(require,module,exports){
'use strict';

module.exports = createBucket;

var LineBucket = require('./linebucket.js');
var FillBucket = require('./fillbucket.js');
var SymbolBucket = require('./symbolbucket.js');
var RasterBucket = require('./rasterbucket.js');
var RenderProperties = require('../style/renderproperties.js');

function createBucket(layer, buffers, collision, indices) {

    if (!RenderProperties[layer.type]) {
        //console.warn('unknown bucket type');
        return;
    }

    var info = new RenderProperties[layer.type](layer.render);

    var BucketClass =
        layer.type === 'line' ? LineBucket :
        layer.type === 'fill' ? FillBucket :
        layer.type === 'symbol' ? SymbolBucket :
        layer.type === 'raster' ? RasterBucket : null;

    var bucket = new BucketClass(info, buffers, collision, indices);
    bucket.type = layer.type;
    bucket.interactive = layer.interactive;
    bucket.minZoom = layer['min-zoom'];
    bucket.maxZoom = layer['max-zoom'];

    return bucket;
}

},{"../style/renderproperties.js":51,"./fillbucket.js":13,"./linebucket.js":14,"./rasterbucket.js":15,"./symbolbucket.js":16}],11:[function(require,module,exports){
'use strict';

module.exports = ElementGroups;

function ElementGroups(vertexBuffer, elementBuffer, secondElementBuffer) {

    this.vertexBuffer = vertexBuffer;
    this.elementBuffer = elementBuffer;
    this.secondElementBuffer = secondElementBuffer;
    this.groups = [];
}

ElementGroups.prototype.makeRoomFor = function(numVertices) {
    if (!this.current || this.current.vertexLength + numVertices > 65535) {
        this.current = new ElementGroup(this.vertexBuffer.index,
                this.elementBuffer && this.elementBuffer.index,
                this.secondElementBuffer && this.secondElementBuffer.index);
        this.groups.push(this.current);
    }
};

function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex)  {
    // the offset into the vertex buffer of the first vertex in this group
    this.vertexStartIndex = vertexStartIndex;
    this.elementStartIndex = elementStartIndex;
    this.secondElementStartIndex = secondElementStartIndex;
    this.elementLength = 0;
    this.vertexLength = 0;
    this.secondElementLength = 0;
}

},{}],12:[function(require,module,exports){
'use strict';

var rbush = require('rbush'),
    Point = require('point-geometry');

module.exports = FeatureTree;

function FeatureTree(getGeometry, getType) {

    this.getGeometry = getGeometry;
    this.getType = getType;

    this.rtree = rbush(9);
    this.toBeInserted = [];
}

FeatureTree.prototype.insert = function(bbox, bucket_name, feature) {
    bbox.bucket = bucket_name;
    bbox.feature = feature;
    this.toBeInserted.push(bbox);
};

// bulk insert into tree
FeatureTree.prototype._load = function() {
    this.rtree.load(this.toBeInserted);
    this.toBeInserted = [];
};

// Finds features in this tile at a particular position.
FeatureTree.prototype.query = function(args, callback) {

    if (this.toBeInserted.length) this._load();

    var radius = args.params && args.params.radius || 0;
    radius *= 4096 / args.scale;

    var x = args.x,
        y = args.y;

    var matching = this.rtree.search([ x - radius, y - radius, x + radius, y + radius ]);

    if (args.params.buckets) {
        this.queryBuckets(matching, x, y, radius, args.params, callback);
    } else {
        this.queryFeatures(matching, x, y, radius, args.params, callback);
    }
};

FeatureTree.prototype.queryFeatures = function(matching, x, y, radius, params, callback) {
    var result = [];
    for (var i = 0; i < matching.length; i++) {
        var feature = matching[i].feature;
        var type = this.getType(feature);
        var geometry = this.getGeometry(feature);


        if (params.bucket && matching[i].bucket !== params.bucket) continue;
        if (params.type && type !== params.type) continue;

        if (geometryContainsPoint(geometry, type, new Point(x, y), radius)) {
            var props = {
                _bucket: matching[i].bucket,
                _type: type
            };

            if (params.geometry) {
                props._geometry = geometry;
            }

            for (var key in feature) {
                if (feature.hasOwnProperty(key) && key[0] !== '_') {
                    props[key] = feature[key];
                }
            }
            result.push(props);
        }
    }

    callback(null, result);
};

// Lists all buckets that at the position.
FeatureTree.prototype.queryBuckets = function(matching, x, y, radius, params, callback) {
    var buckets = [];
    for (var i = 0; i < matching.length; i++) {
        if (buckets.indexOf(matching[i].bucket) >= 0) continue;

        var feature = matching[i].feature;
        var type = this.getType(feature);
        var geometry = this.getGeometry(feature);
        if (geometryContainsPoint(geometry, type, new Point(x, y), radius)) {
            buckets.push(matching[i].bucket);
        }
    }

    callback(null, buckets);
};


function geometryContainsPoint(rings, type, p, radius) {
    if (type === 'Point') {
        return pointContainsPoint(rings, p, radius);
    } else if (type === 'LineString') {
        return lineContainsPoint(rings, p, radius);
    } else if (type === 'Polygon') {
        return polyContainsPoint(rings, p) ? true : lineContainsPoint(rings, p, radius);
    } else {
        return false;
    }
}

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
    var l2 = v.distSqr(w);
    if (l2 === 0) return p.distSqr(v);
    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) return p.distSqr(v);
    if (t > 1) return p.distSqr(w);
    return p.distSqr(w.sub(v)._mult(t)._add(v));
}

function lineContainsPoint(rings, p, radius) {
    var r = radius * radius;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 1; j < ring.length; j++) {
            // Find line segments that have a distance <= radius^2 to p
            // In that case, we treat the line as "containing point p".
            var v = ring[j-1], w = ring[j];
            if (distToSegmentSquared(p, v, w) < r) return true;
        }
    }
    return false;
}

// point in polygon ray casting algorithm
function polyContainsPoint(rings, p) {
    var c = false,
        ring, p1, p2;

    for (var k = 0; k < rings.length; k++) {
        ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (((p1.y > p.y) != (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
    }
    return c;
}

function pointContainsPoint(rings, p, radius) {
    var r = radius * radius;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        for (var j = 0; j < ring.length; j++) {
            if (ring[j].distSqr(p) <= r) return true;
        }
    }
    return false;
}



},{"point-geometry":97,"rbush":99}],13:[function(require,module,exports){
'use strict';

var ElementGroups = require('./elementgroups.js');

module.exports = FillBucket;

function FillBucket(info, buffers, placement, elementGroups) {
    this.info = info;
    this.buffers = buffers;
    this.elementGroups = elementGroups || new ElementGroups(buffers.fillVertex, buffers.fillElement, buffers.outlineElement);
}

FillBucket.prototype.addFeatures = function() {
    var features = this.features;
    for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        this.addFeature(feature.loadGeometry());
    }
};

FillBucket.prototype.addFeature = function(lines) {
    for (var i = 0; i < lines.length; i++) {
        this.addFill(lines[i]);
    }
};

FillBucket.prototype.addFill = function(vertices) {
    if (vertices.length < 3) {
        //console.warn('a fill must have at least three vertices');
        return;
    }

    // Calculate the total number of vertices we're going to produce so that we
    // can resize the buffer beforehand, or detect whether the current line
    // won't fit into the buffer anymore.
    // In order to be able to use the vertex buffer for drawing the antialiased
    // outlines, we separate all polygon vertices with a degenerate (out-of-
    // viewplane) vertex.

    var len = vertices.length;

    // Check whether this geometry buffer can hold all the required vertices.
    this.elementGroups.makeRoomFor(len + 1);
    var elementGroup = this.elementGroups.current;

    var fillVertex = this.buffers.fillVertex;
    var fillElement = this.buffers.fillElement;
    var outlineElement = this.buffers.outlineElement;

    // Start all lines with a degenerate vertex
    elementGroup.vertexLength++;

    // We're generating triangle fans, so we always start with the first coordinate in this polygon.
    var firstIndex = fillVertex.index - elementGroup.vertexStartIndex,
        prevIndex, currentIndex, currentVertex;

    for (var i = 0; i < vertices.length; i++) {
        currentIndex = fillVertex.index - elementGroup.vertexStartIndex;
        currentVertex = vertices[i];

        fillVertex.add(currentVertex.x, currentVertex.y);
        elementGroup.vertexLength++;

        // Only add triangles that have distinct vertices.
        if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
            fillElement.add(firstIndex, prevIndex, currentIndex);
            elementGroup.elementLength++;
        }

        if (i >= 1) {
            outlineElement.add(prevIndex, currentIndex);
            elementGroup.secondElementLength++;
        }

        prevIndex = currentIndex;
    }
};

FillBucket.prototype.hasData = function() {
    return !!this.elementGroups.current;
};

},{"./elementgroups.js":11}],14:[function(require,module,exports){
'use strict';

var ElementGroups = require('./elementgroups.js');

module.exports = LineBucket;

function LineBucket(info, buffers, placement, elementGroups) {
    this.info = info;
    this.buffers = buffers;
    this.elementGroups = elementGroups || new ElementGroups(buffers.lineVertex, buffers.lineElement);
}

LineBucket.prototype.addFeatures = function() {
    var features = this.features;
    for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        this.addFeature(feature.loadGeometry());
    }
};

LineBucket.prototype.addFeature = function(lines) {
    var info = this.info;
    for (var i = 0; i < lines.length; i++) {
        this.addLine(lines[i], info['line-join'], info['line-cap'],
                info['line-miter-limit'], info['line-round-limit']);
    }
};

LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {
    if (vertices.length < 2) {
        //console.warn('a line must have at least two vertices');
        return;
    }

    if (join === 'bevel') miterLimit = 1.05;

    var len = vertices.length,
        firstVertex = vertices[0],
        lastVertex = vertices[len - 1],
        closed = firstVertex.equals(lastVertex);

    var lineVertex = this.buffers.lineVertex;
    var lineElement = this.buffers.lineElement;

    // we could be more precies, but it would only save a negligible amount of space
    this.elementGroups.makeRoomFor(len * 4);
    var elementGroup = this.elementGroups.current;
    var vertexStartIndex = elementGroup.vertexStartIndex;

    if (len == 2 && closed) {
        // console.warn('a line may not have coincident points');
        return;
    }

    var beginCap = cap,
        endCap = closed ? 'butt' : cap,
        flip = 1,
        distance = 0,
        currentVertex, prevVertex,  nextVertex, prevNormal,  nextNormal;

    // the last three vertices added
    var e1, e2, e3;

    if (closed) {
        currentVertex = vertices[len - 2];
        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
    }

    for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
            vertices[1] : // if the line is closed, we treat the last vertex like the first
            vertices[i + 1]; // just the next vertex

        // if two consecutive vertices exist, skip the current one
        if (nextVertex && vertices[i].equals(nextVertex)) continue;

        if (nextNormal) prevNormal = nextNormal;
        if (currentVertex) prevVertex = currentVertex;

        currentVertex = vertices[i];

        // Calculate how far along the line the currentVertex is
        if (prevVertex) distance += currentVertex.dist(prevVertex);

        // Calculate the normal towards the next vertex in this line. In case
        // there is no next vertex, pretend that the line is continuing straight,
        // meaning that we are just using the previous normal.
        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

        // If we still don't have a previous normal, this is the beginning of a
        // non-closed line, so we're doing a straight "join".
        prevNormal = prevNormal || nextNormal;

        // Determine the normal of the join extrusion. It is the angle bisector
        // of the segments between the previous line and the next line.
        var joinNormal = prevNormal.add(nextNormal)._unit();

        /*  joinNormal     prevNormal
         *             ↖      ↑
         *                .________. prevVertex
         *                |
         * nextNormal  ←  |  currentVertex
         *                |
         *     nextVertex !
         *
         */

        // Calculate the length of the miter (the ratio of the miter to the width).
        // Find the cosine of the angle between the next and join normals
        // using dot product. The inverse of that is the miter length.
        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
        var miterLength = 1 / cosHalfAngle;

        // Whether any vertices have been
        var startOfLine = e1 === undefined || e2 === undefined;

        // The join if a middle vertex, otherwise the cap.
        var middleVertex = prevVertex && nextVertex;
        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

        if (middleVertex && currentJoin === 'round' && miterLength < roundLimit) {
            currentJoin = 'miter';
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
            currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
            // The maximum extrude length is 63 / 256 = 4 times the width of the line
            // so if miterLength >= 4 we need to draw a different type of bevel where.
            if (miterLength > 4) currentJoin = 'flipbevel';

            // If the miterLength is really small and the line bevel wouldn't be visible,
            // just draw a miter join to save a triangle.
            if (miterLength < miterLimit) currentJoin = 'miter';
        }

        // Mitered joins
        if (currentJoin === 'miter') {
            // scale the unit vector by the miter length
            joinNormal._mult(miterLength);
            addCurrentVertex(joinNormal, 0, 0, false);

        } else if (currentJoin === 'flipbevel') {
            // miter is too big, flip the direction to make a beveled join

            if (miterLength > 100) {
                // Almost parallel lines
                flip = -flip;
                joinNormal = nextNormal;

            } else {
                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(flip * bevelLength);
                flip = -flip;
            }
            addCurrentVertex(joinNormal, 0, 0, false);

        // All other types of joins
        } else {

            var offsetA, offsetB;
            if (currentJoin === 'bevel') {
                var dir = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
                var offset = -Math.sqrt(miterLength * miterLength - 1);
                if (flip * dir > 0) {
                    offsetB = 0;
                    offsetA = offset;
                } else {
                    offsetA = 0;
                    offsetB = offset;
                }
            } else if (currentJoin === 'square') {
                offsetA = offsetB = 1;
            } else {
                offsetA = offsetB = 0;
            }

            // Close previous segment with a butt or a square cap or bevel
            if (!startOfLine) {
                addCurrentVertex(prevNormal, offsetA, offsetB, false);
            }

            // Add round cap or linejoin at end of segment
            if (!startOfLine && currentJoin === 'round') {
                addCurrentVertex(prevNormal, 1, 1, true);
            }

            // Segment include cap are done, unset vertices to disconnect segments.
            // Or leave them to create a bevel.
            if (startOfLine || currentJoin !== 'bevel') {
                e1 = e2 = -1;
                flip = 1;
            }

            // Add round cap before first segment
            if (startOfLine && beginCap === 'round') {
                addCurrentVertex(nextNormal, -1, -1, true);
            }

            // Start next segment with a butt or square cap or bevel
            if (nextVertex) {
                addCurrentVertex(nextNormal, -offsetA, -offsetB, false);
            }
        }

    }


    /*
     * Adds two vertices to the buffer that are
     * normal and -normal from the currentVertex.
     *
     * endBox moves the extrude one unit in the direction of the line
     * to create square or round cap.
     *
     * endLeft and endRight shifts the extrude along the line
     * endLeft === 1 moves the extrude in the direction of the line
     * endLeft === -1 moves the extrude in the reverse direction
     */
    function addCurrentVertex(normal, endLeft, endRight, round) {

        var tx = round ? 1 : 0;
        var extrude;

        extrude = normal.mult(flip);
        if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
        e3 = lineVertex.add(currentVertex, extrude, tx, 0, distance) - vertexStartIndex;
        if (e1 >= 0 && e2 >= 0) {
            lineElement.add(e1, e2, e3);
            elementGroup.elementLength++;
        }
        e1 = e2;
        e2 = e3;

        extrude = normal.mult(-flip);
        if (endRight) extrude._sub(normal.perp()._mult(endRight));
        e3 = lineVertex.add(currentVertex, extrude, tx, 1, distance) - vertexStartIndex;
        if (e1 >= 0 && e2 >= 0) {
            lineElement.add(e1, e2, e3);
            elementGroup.elementLength++;
        }
        e1 = e2;
        e2 = e3;

        elementGroup.vertexLength += 2;
    }
};

LineBucket.prototype.hasData = function() {
    return !!this.elementGroups.current;
};

},{"./elementgroups.js":11}],15:[function(require,module,exports){
'use strict';

module.exports = RasterBucket;

function RasterBucket(info) {
    this.info = info;
}

},{}],16:[function(require,module,exports){
'use strict';

var ElementGroups = require('./elementgroups.js');
var Anchor = require('../symbol/anchor.js');
var interpolate = require('../symbol/interpolate.js');
var Point = require('point-geometry');
var resolveTokens = require('../util/token.js');
var Placement = require('../symbol/placement.js');
var Shaping = require('../symbol/shaping.js');
var resolveText = require('../symbol/resolvetext.js');

module.exports = SymbolBucket;

var fullRange = [2 * Math.PI , 0];

function SymbolBucket(info, buffers, collision, elementGroups) {
    this.info = info;
    this.buffers = buffers;
    this.collision = collision;

    if (info['symbol-placement'] === 'line') {
        if (!info.hasOwnProperty('text-rotation-alignment')) {
            info['text-rotation-alignment'] = 'map';
        }
        if (!info.hasOwnProperty('icon-rotation-alignment')) {
            info['icon-rotation-alignment'] = 'map';
        }

        info['symbol-avoid-edges'] = true;
    }

    if (elementGroups) {
        this.elementGroups = elementGroups;
    } else {
        this.elementGroups = {
            text: new ElementGroups(buffers.glyphVertex),
            icon: new ElementGroups(buffers.iconVertex)
        };
    }
}

SymbolBucket.prototype.addFeatures = function() {
    var info = this.info;
    var features = this.features;
    var textFeatures = this.textFeatures;

    var horizontalAlign = 0.5;
    if (info['text-horizontal-align'] === 'right') horizontalAlign = 1;
    else if (info['text-horizontal-align'] === 'left') horizontalAlign = 0;

    var verticalAlign = 0.5;
    if (info['text-vertical-align'] === 'bottom') verticalAlign = 1;
    else if (info['text-vertical-align'] === 'top') verticalAlign = 0;

    var justify = 0.5;
    if (info['text-justify'] === 'right') justify = 1;
    else if (info['text-justify'] === 'left') justify = 0;

    var oneEm = 24;
    var lineHeight = info['text-line-height'] * oneEm;
    var maxWidth = info['symbol-placement'] !== 'line' && info['text-max-width'] * oneEm;
    var spacing = info['text-letter-spacing'] * oneEm;
    var fontstack = info['text-font'];
    var textOffset = [info['text-offset'][0] * oneEm, info['text-offset'][1] * oneEm];

    for (var k = 0; k < features.length; k++) {

        var feature = features[k];
        var text = textFeatures[k];
        var lines = feature.loadGeometry();

        var shaping = false;
        if (text) {
            shaping = Shaping.shape(text, fontstack, this.stacks, maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
        }

        var image = false;
        if (this.sprite && this.info['icon-image']) {
            image = this.sprite[resolveTokens(feature.properties, info['icon-image'])];

            if (image) {
                // match glyph tex object. TODO change
                image.w = image.width;
                image.h = image.height;

                if (image.sdf) this.elementGroups.sdfIcons = true;
            }
        }

        if (!shaping && !image) continue;
        this.addFeature(lines, this.stacks, shaping, image);
    }
};

function byScale(a, b) {
    return a.scale - b.scale;
}

SymbolBucket.prototype.addFeature = function(lines, faces, shaping, image) {
    var info = this.info;
    var collision = this.collision;

    var minScale = 0.5;
    var glyphSize = 24;

    var horizontalText = info['text-rotation-alignment'] === 'viewport',
        horizontalIcon = info['icon-rotation-alignment'] === 'viewport',
        fontScale = info['text-max-size'] / glyphSize,
        textBoxScale = collision.tilePixelRatio * fontScale,
        iconBoxScale = collision.tilePixelRatio * info['icon-max-size'],
        iconWithoutText = info['text-optional'] || !shaping,
        textWithoutIcon = info['icon-optional'] || !image,
        avoidEdges = info['symbol-avoid-edges'];

    for (var i = 0; i < lines.length; i++) {

        var line = lines[i];
        var anchors;

        if (info['symbol-placement'] === 'line') {
            // Line labels
            anchors = interpolate(line, info['symbol-min-distance'], minScale, collision.maxPlacementScale, collision.tilePixelRatio);

            // Sort anchors by segment so that we can start placement with the
            // anchors that can be shown at the lowest zoom levels.
            anchors.sort(byScale);

        } else {
            // Point labels
            anchors = [new Anchor(line[0].x, line[0].y, 0, minScale)];
        }


        // TODO: figure out correct ascender height.
        var origin = new Point(0, -17);

        for (var j = 0, len = anchors.length; j < len; j++) {
            var anchor = anchors[j];
            var inside = !(anchor.x < 0 || anchor.x > 4096 || anchor.y < 0 || anchor.y > 4096);

            if (avoidEdges && !inside) continue;

            // Calculate the scales at which the text and icons can be first shown without overlap
            var glyph;
            var icon;
            var glyphScale = null;
            var iconScale = null;

            if (shaping) {
                glyph = Placement.getGlyphs(anchor, origin, shaping, faces, textBoxScale, horizontalText, line, info);
                glyphScale = info['text-allow-overlap'] ? glyph.minScale
                    : collision.getPlacementScale(glyph.boxes, glyph.minScale, avoidEdges);
                if (!glyphScale && !iconWithoutText) continue;
            }

            if (image) {
                icon = Placement.getIcon(anchor, image, iconBoxScale, line, info);
                iconScale = info['icon-allow-overlap'] ? icon.minScale
                    : collision.getPlacementScale(icon.boxes, icon.minScale, avoidEdges);
                if (!iconScale && !textWithoutIcon) continue;
            }

            if (!iconWithoutText && !textWithoutIcon) {
                iconScale = glyphScale = Math.max(iconScale, glyphScale);
            } else if (!textWithoutIcon && glyphScale) {
                glyphScale = Math.max(iconScale, glyphScale);
            } else if (!iconWithoutText && iconScale) {
                iconScale = Math.max(iconScale, glyphScale);
            }

            // Get the rotation ranges it is safe to show the glyphs
            var glyphRange = (!glyphScale || info['text-allow-overlap']) ? fullRange
                : collision.getPlacementRange(glyph.boxes, glyphScale, horizontalText);
            var iconRange = (!iconScale || info['icon-allow-overlap']) ? fullRange
                : collision.getPlacementRange(icon.boxes, iconScale, horizontalIcon);

            var maxRange = [
                Math.min(iconRange[0], glyphRange[0]),
                Math.max(iconRange[1], glyphRange[1])];

            if (!iconWithoutText && !textWithoutIcon) {
                iconRange = glyphRange = maxRange;
            } else if (!textWithoutIcon) {
                glyphRange = maxRange;
            } else if (!iconWithoutText) {
                iconRange = maxRange;
            }

            // Insert final placement into collision tree and add glyphs/icons to buffers
            if (glyphScale) {
                if (!info['text-ignore-placement']) {
                    collision.insert(glyph.boxes, anchor, glyphScale, glyphRange, horizontalText);
                }
                if (inside) this.addSymbols(this.buffers.glyphVertex, this.elementGroups.text, glyph.shapes, glyphScale, glyphRange);
            }

            if (iconScale) {
                if (!info['icon-ignore-placement']) {
                    collision.insert(icon.boxes, anchor, iconScale, iconRange, horizontalIcon);
                }
                if (inside) this.addSymbols(this.buffers.iconVertex, this.elementGroups.icon, icon.shapes, iconScale, iconRange);
            }

        }
    }
};

SymbolBucket.prototype.addSymbols = function(buffer, elementGroups, symbols, scale, placementRange) {

    var zoom = this.collision.zoom;

    elementGroups.makeRoomFor(0);
    var elementGroup = elementGroups.current;

    var placementZoom = Math.log(scale) / Math.LN2 + zoom;

    for (var k = 0; k < symbols.length; k++) {

        var symbol = symbols[k],
            tl = symbol.tl,
            tr = symbol.tr,
            bl = symbol.bl,
            br = symbol.br,
            tex = symbol.tex,
            angle = symbol.angle,
            anchor = symbol.anchor,


            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

        if (maxZoom <= minZoom) continue;

        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
        if (minZoom === placementZoom) minZoom = 0;

        // first triangle
        buffer.add(anchor.x, anchor.y, tl.x, tl.y, tex.x, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);

        // second triangle
        buffer.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);
        buffer.add(anchor.x, anchor.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, angle, minZoom, placementRange, maxZoom, placementZoom);

        elementGroup.vertexLength += 6;
    }

};

SymbolBucket.prototype.getDependencies = function(tile, actor, callback) {
    var firstdone = false;
    var firsterr;
    this.getTextDependencies(tile, actor, done);
    this.getIconDependencies(tile, actor, done);
    function done(err) {
        if (err || firstdone) callback(err);
        firstdone = true;
        firsterr = err;
    }
};

SymbolBucket.prototype.getIconDependencies = function(tile, actor, callback) {
    var bucket = this;
    if (this.info['icon-image']) {
        if (SymbolBucket.sprite) {
            this.sprite = SymbolBucket.sprite;
            callback();
        } else {
            actor.send('get sprite json', {}, function(err, data) {
                SymbolBucket.sprite = bucket.sprite = data.sprite;
                callback(err);
            });
        }
    } else {
        callback();
    }
};

SymbolBucket.prototype.getTextDependencies = function(tile, actor, callback) {
    var features = this.features;
    var info = this.info;

    if (tile.stacks === undefined) tile.stacks = {};
    var stacks = this.stacks = tile.stacks;
    var fontstack = info['text-font'];
    if (stacks[fontstack] === undefined) {
        stacks[fontstack] = { glyphs: {}, rects: {} };
    }
    var stack = stacks[fontstack];

    var data = resolveText(features, info, stack.glyphs);
    this.textFeatures = data.textFeatures;

    actor.send('get glyphs', {
        id: tile.id,
        fontstack: fontstack,
        codepoints: data.codepoints
    }, function(err, newstack) {
        if (err) return callback(err);

        var newglyphs = newstack.glyphs;
        var newrects = newstack.rects;
        var glyphs = stack.glyphs;
        var rects = stack.rects;

        for (var codepoint in newglyphs) {
            glyphs[codepoint] = newglyphs[codepoint];
            rects[codepoint] = newrects[codepoint];
        }

        callback();
    });
};

SymbolBucket.prototype.hasData = function() {
    return !!this.elementGroups.text.current || !!this.elementGroups.icon.current;
};

},{"../symbol/anchor.js":56,"../symbol/interpolate.js":61,"../symbol/placement.js":62,"../symbol/resolvetext.js":63,"../symbol/shaping.js":65,"../util/token.js":84,"./elementgroups.js":11,"point-geometry":97}],17:[function(require,module,exports){
'use strict';

module.exports = LatLng;

function LatLng(lat, lng) {
    if (isNaN(lat) || isNaN(lng)) {
        throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    }
    this.lat = +lat;
    this.lng = +lng;
}


// constructs LatLng from an array if necessary

LatLng.convert = function (a) {
    if (a instanceof LatLng) {
        return a;
    }
    if (Array.isArray(a)) {
        return new LatLng(a[0], a[1]);
    }
    return a;
};

},{}],18:[function(require,module,exports){
'use strict';

module.exports = LatLngBounds;

var LatLng = require('./latlng.js');

function LatLngBounds(sw, ne) {
    if (!sw) return;

    var latlngs = ne ? [sw, ne] : sw;

    for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
    }
}

LatLngBounds.prototype = {

    // extend the bounds to contain the given point or bounds
    extend: function (obj) {
        var sw = this._sw,
            ne = this._ne,
            sw2, ne2;

        if (obj instanceof LatLng) {
            sw2 = obj;
            ne2 = obj;

        } else if (obj instanceof LatLngBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;

            if (!sw2 || !ne2) return this;

        } else {
            return obj ? this.extend(LatLng.convert(obj) || LatLngBounds.convert(obj)) : this;
        }

        if (!sw && !ne) {
            this._sw = new LatLng(sw2.lat, sw2.lng);
            this._ne = new LatLng(ne2.lat, ne2.lng);

        } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
        }

        return this;
    },

    getCenter: function () {
        return new LatLng((this._sw.lat + this._ne.lat) / 2, (this._sw.lng + this._ne.lng) / 2);
    },

    getSouthWest: function () { return this._sw; },
    getNorthEast: function () { return this._ne; },
    getNorthWest: function () { return new LatLng(this.getNorth(), this.getWest()); },
    getSouthEast: function () { return new LatLng(this.getSouth(), this.getEast()); },

    getWest:  function () { return this._sw.lng; },
    getSouth: function () { return this._sw.lat; },
    getEast:  function () { return this._ne.lng; },
    getNorth: function () { return this._ne.lat; }
};

// constructs LatLngBounds from an array if necessary
LatLngBounds.convert = function (a) {
    if (!a || a instanceof LatLngBounds) return a;
    return new LatLngBounds(a);
};

},{"./latlng.js":17}],19:[function(require,module,exports){
'use strict';

var LatLng = require('./latlng.js'),
    Point = require('point-geometry');

module.exports = Transform;

// A single transform, generally used for a single tile to be scaled, rotated, and zoomed.

function Transform(minZoom, maxZoom) {
    this.tileSize = 512; // constant

    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;

    this.latRange = [-85, 85];

    this.width = 0;
    this.height = 0;
    this.zoom = 0;
    this.center = new LatLng(0, 0);
    this.angle = 0;
}

Transform.prototype = {
    get minZoom() { return this._minZoom; },
    set minZoom(zoom) {
        this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
    },

    get maxZoom() { return this._maxZoom; },
    set maxZoom(zoom) {
        this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
    },

    get worldSize() {
        return this.tileSize * this.scale;
    },

    get centerPoint() {
        return this.size._div(2);
    },

    get size() {
        return new Point(this.width, this.height);
    },

    get bearing() {
        return -this.angle / Math.PI * 180;
    },
    set bearing(bearing) {
        // confine the angle to within [-180,180]
        bearing = ((((bearing + 180) % 360) + 360) % 360) - 180;
        this.angle = -bearing * Math.PI / 180;
    },

    get zoom() { return this._zoom; },
    set zoom(zoom) {
        zoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        this._zoom = zoom;
        this.scale = this.zoomScale(zoom);
        this.tileZoom = Math.floor(zoom);
        this.zoomFraction = zoom - this.tileZoom;
        this._constrain();
    },

    zoomScale: function(zoom) { return Math.pow(2, zoom); },
    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

    project: function(latlng, worldSize) {
        return new Point(
            this.lngX(latlng.lng, worldSize),
            this.latY(latlng.lat, worldSize));
    },

    unproject: function(point, worldSize) {
        return new LatLng(
            this.yLat(point.y, worldSize),
            this.xLng(point.x, worldSize));
    },

    get x() { return this.lngX(this.center.lng); },
    get y() { return this.latY(this.center.lat); },

    get point() { return new Point(this.x, this.y); },

    // lat/lon <-> absolute pixel coords convertion
    lngX: function(lon, worldSize) {
        return (180 + lon) * (worldSize || this.worldSize) / 360;
    },
    // latitude to absolute y coord
    latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
        return (180 - y) * (worldSize || this.worldSize) / 360;
    },

    xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
    },
    yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    },

    panBy: function(offset) {
        var point = this.centerPoint._add(offset);
        this.center = this.pointLocation(point);
        this._constrain();
    },

    setZoomAround: function(zoom, center) {
        var p = this.locationPoint(center),
            p1 = this.size._sub(p),
            latlng = this.pointLocation(p1);
        this.zoom = zoom;
        this.panBy(p1.sub(this.locationPoint(latlng)));
    },

    setBearingAround: function(bearing, center) {
        var offset = this.locationPoint(center).sub(this.centerPoint);
        this.panBy(offset);
        this.bearing = bearing;
        this.panBy(offset.mult(-1));
    },

    locationPoint: function(latlng) {
        var p = this.project(latlng);
        return this.centerPoint._sub(this.point._sub(p)._rotate(this.angle));
    },

    pointLocation: function(p) {
        var p2 = this.centerPoint._sub(p)._rotate(-this.angle);
        return this.unproject(this.point.sub(p2));
    },

    locationCoordinate: function(latlng) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize;
        return {
            column: this.lngX(latlng.lng) * k,
            row: this.latY(latlng.lat) * k,
            zoom: this.tileZoom
        };
    },

    pointCoordinate: function(tileCenter, p) {
        var zoomFactor = this.zoomScale(this.zoomFraction),
            kt = this.zoomScale(this.tileZoom - tileCenter.zoom),
            p2 = this.centerPoint._sub(p)._rotate(-this.angle)._div(this.tileSize * zoomFactor);

        return {
            column: tileCenter.column * kt - p2.x,
            row: tileCenter.row * kt - p2.y,
            zoom: this.tileZoom
        };
    },

    _constrain: function() {
        if (!this.center) return;

        var minY, maxY, minX, maxX, sy, sx, x2, y2,
            size = this.size;

        if (this.latRange) {
            minY = this.latY(this.latRange[1]);
            maxY = this.latY(this.latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
            minX = this.lngX(this.lngRange[0]);
            maxX = this.lngX(this.lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);

        if (s) {
            this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            return;
        }

        if (this.latRange) {
            var y = this.y,
                h2 = size.y / 2;

            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
            var x = this.x,
                w2 = size.x / 2;

            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
            this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }
    }
};

},{"./latlng.js":17,"point-geometry":97}],20:[function(require,module,exports){
// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplex_font = {
    " ": [16, []],
    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "-": [26, [4, 9, 22, 9]],
    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "/": [22, [20, 25, 2, -7]],
    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "<": [24, [20, 18, 4, 9, 20, 0]],
    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
    ">": [24, [4, 18, 20, 9, 4, 0]],
    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
    "I": [8, [4, 21, 4, 0]],
    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
    "\\": [14, [0, 21, 14, -3]],
    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
    "_": [16, [0, -2, 16, -2]],
    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
    "l": [8, [4, 21, 4, 0]],
    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
    "|": [8, [4, 25, 4, -7]],
    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]],
};

module.exports = function textVertices(text, left, baseline, scale) {
    scale = scale || 1;

    var strokes = [],
        i, len, j, len2, glyph, data, x, y, prev;

    for (i = 0, len = text.length; i < len; i++) {
        glyph = simplex_font[text[i]];
        if (!glyph) continue;
        prev = null;

        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                prev = null;

            } else {
                x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
                    strokes.push(prev.x, prev.y, x, y);
                }
                prev = {x: x, y: y};
            }
        }
        left += glyph[0] * scale;
    }

    return strokes;
};

},{}],21:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.0
 */
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(e){"use strict";var t={};typeof exports=="undefined"?typeof define=="function"&&typeof define.amd=="object"&&define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!="undefined"?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!="undefined"?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!="undefined"&&(e.glMatrix=i);var s={};s.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},s.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},s.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},s.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},s.set=function(e,t,n){return e[0]=t,e[1]=n,e},s.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},s.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},s.sub=s.subtract,s.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},s.mul=s.multiply,s.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},s.div=s.divide,s.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},s.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},s.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},s.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},s.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},s.dist=s.distance,s.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},s.sqrDist=s.squaredDistance,s.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},s.len=s.length,s.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},s.sqrLen=s.squaredLength,s.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},s.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},s.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},s.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},s.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},s.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},s.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},s.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},s.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},s.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},s.forEach=function(){var e=s.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),s.str=function(e){return"vec2("+e[0]+", "+e[1]+")"},typeof e!="undefined"&&(e.vec2=s);var o={};o.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},o.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},o.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},o.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},o.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},o.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),o.str=function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},typeof e!="undefined"&&(e.vec3=o);var u={};u.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},u.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},u.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},u.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},u.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),u.normalize(e,e),u.scale(e,e,t),e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),u.str=function(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.vec4=u);var a={};a.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},a.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},a.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},a.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},a.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},a.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+i*f,e[1]=r*a+i*l,e[2]=s*u+o*f,e[3]=s*a+o*l,e},a.mul=a.multiply,a.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=r*-u+i*a,e[2]=s*a+o*u,e[3]=s*-u+o*a,e},a.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*a,e[2]=s*u,e[3]=o*a,e},a.str=function(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.mat2=a);var f={};f.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},f.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},f.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+i*c,e[1]=r*l+i*h,e[2]=s*f+o*c,e[3]=s*l+o*h,e[4]=f*u+c*a+p,e[5]=l*u+h*a+d,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+i*f,e[1]=-r*f+i*l,e[2]=s*l+o*f,e[3]=-s*f+l*o,e[4]=l*u+f*a,e[5]=l*a-f*u,e},f.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=t[0]*r,e[1]=t[1]*i,e[2]=t[2]*r,e[3]=t[3]*i,e[4]=t[4]*r,e[5]=t[5]*i,e},f.translate=function(e,t,n){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4]+n[0],e[5]=t[5]+n[1],e},f.str=function(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"},typeof e!="undefined"&&(e.mat2d=f);var l={};l.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},l.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},l.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},l.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},l.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},l.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},l.mul=l.multiply,l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},l.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},l.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},l.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=n*u,c=n*a,h=r*u,p=r*a,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-(h+d),e[3]=l+g,e[6]=c-m,e[1]=l-g,e[4]=1-(f+d),e[7]=p+v,e[2]=c+m,e[5]=p-v,e[8]=1-(f+h),e},l.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},l.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},typeof e!="undefined"&&(e.mat3=l);var c={};c.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},c.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},c.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)<t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},c.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},c.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},c.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},c.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=n*u,c=n*a,h=r*u,p=r*a,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-(h+d),e[1]=l+g,e[2]=c-m,e[3]=0,e[4]=l-g,e[5]=1-(f+d),e[6]=p+v,e[7]=0,e[8]=c+m,e[9]=p-v,e[10]=1-(f+h),e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},c.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},c.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},c.lookAt=function(e,n,r,i){var s,o,u,a,f,l,h,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)<t&&Math.abs(g-x)<t&&Math.abs(y-T)<t?c.identity(e):(h=m-S,p=g-x,d=y-T,v=1/Math.sqrt(h*h+p*p+d*d),h*=v,p*=v,d*=v,s=w*d-E*p,o=E*h-b*d,u=b*p-w*h,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-h*u,l=h*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=h,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(h*m+p*g+d*y),e[15]=1,e)},c.str=function(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"},typeof e!="undefined"&&(e.mat4=c);var h={};h.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},h.rotationTo=function(){var e=o.create(),t=o.fromValues(1,0,0),n=o.fromValues(0,1,0);return function(r,i,s){var u=o.dot(i,s);return u<-0.999999?(o.cross(e,t,i),o.length(e)<1e-6&&o.cross(e,n,i),o.normalize(e,e),h.setAxisAngle(r,e,Math.PI),r):u>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(o.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+u,h.normalize(r,r))}}(),h.setAxes=function(){var e=l.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=n[0],e[5]=n[1],e[8]=n[2],h.normalize(t,h.fromMat3(t,e))}}(),h.clone=u.clone,h.fromValues=u.fromValues,h.copy=u.copy,h.set=u.set,h.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},h.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},h.add=u.add,h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},h.mul=h.multiply,h.scale=u.scale,h.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},h.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},h.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},h.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},h.dot=u.dot,h.lerp=u.lerp,h.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p<0&&(p=-p,a=-a,f=-f,l=-l,c=-c),1-p>1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},h.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},h.length=u.length,h.len=h.length,h.squaredLength=u.squaredLength,h.sqrLen=h.squaredLength,h.normalize=u.normalize,h.fromMat3=function(){var e=typeof Int8Array!="undefined"?new Int8Array([1,2,0]):[1,2,0];return function(t,n){var r=n[0]+n[4]+n[8],i;if(r>0)i=Math.sqrt(r+1),t[3]=.5*i,i=.5/i,t[0]=(n[7]-n[5])*i,t[1]=(n[2]-n[6])*i,t[2]=(n[3]-n[1])*i;else{var s=0;n[4]>n[0]&&(s=1),n[8]>n[s*3+s]&&(s=2);var o=e[s],u=e[o];i=Math.sqrt(n[s*3+s]-n[o*3+o]-n[u*3+u]+1),t[s]=.5*i,i=.5/i,t[3]=(n[u*3+o]-n[o*3+u])*i,t[o]=(n[o*3+s]+n[s*3+o])*i,t[u]=(n[u*3+s]+n[s*3+u])*i}return t}}(),h.str=function(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.quat=h)}(t.exports)})(this);

},{}],22:[function(require,module,exports){
'use strict';

if (typeof window === 'undefined') {
    new (require('./source/worker.js'))(self);
} else {
    // jshint -W079
    var mapboxgl = module.exports = window.mapboxgl = {};

    mapboxgl.Map = require('./ui/map.js');
    mapboxgl.Navigation = require('./ui/control/navigation.js');
    mapboxgl.Attribution = require('./ui/control/attribution.js');

    mapboxgl.Source = require('./source/source');
    mapboxgl.GeoJSONSource = require('./source/geojsonsource');
    mapboxgl.VideoSource = require('./source/videosource');

    mapboxgl.Style = require('./style/style.js');

    mapboxgl.LatLng = require('./geo/latlng.js');
    mapboxgl.LatLngBounds = require('./geo/latlngbounds.js');
    mapboxgl.Point = require('point-geometry');

    mapboxgl.Evented = require('./util/evented.js');
    mapboxgl.util = require('./util/util.js');

    var browser = require('./util/browser.js');
    mapboxgl.util.supported = browser.supported;

    var ajax = require('./util/ajax.js');
    mapboxgl.util.getJSON = ajax.getJSON;
    mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

    var config = require('./util/config.js');
    mapboxgl.config = config;

    Object.defineProperty(mapboxgl, 'accessToken', {
        get: function() { return config.ACCESS_TOKEN; },
        set: function(token) { config.ACCESS_TOKEN = token; }
    });
}

},{"./geo/latlng.js":17,"./geo/latlngbounds.js":18,"./source/geojsonsource":35,"./source/source":39,"./source/videosource":44,"./source/worker.js":45,"./style/style.js":52,"./ui/control/attribution.js":66,"./ui/control/navigation.js":68,"./ui/map.js":73,"./util/ajax.js":75,"./util/browser.js":76,"./util/config.js":79,"./util/evented.js":81,"./util/util.js":86,"point-geometry":97}],23:[function(require,module,exports){
'use strict';

var mat3 = require('../lib/glmatrix.js').mat3;

module.exports = drawBackground;

function drawBackground(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
    var color = layerStyle['background-color'];
    var image = layerStyle['background-image'];
    var opacity = layerStyle['background-opacity'] || 1;
    var shader;

    if (image) {
        // Draw texture fill
        var imagePos = imageSprite.getPosition(image, true);
        if (!imagePos) return;

        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_mix, painter.transform.zoomFraction);
        gl.uniform1f(shader.u_opacity, opacity);

        var transform = painter.transform;
        var size = imagePos.size;
        var center = transform.locationCoordinate(transform.center);
        var scale = 1 / Math.pow(2, transform.zoomFraction);
        var matrix = mat3.create();

        mat3.scale(matrix, matrix, [1 / size[0], 1 / size[1], 1]);
        mat3.translate(matrix, matrix, [
            (center.column * transform.tileSize) % size[0],
            (center.row    * transform.tileSize) % size[1],
            0
        ]);
        mat3.rotate(matrix, matrix, -transform.angle);
        mat3.scale(matrix, matrix, [
            scale * transform.width  / 2,
           -scale * transform.height / 2,
            1
        ]);

        gl.uniformMatrix3fv(shader.u_patternmatrix, false, matrix);

        imageSprite.bind(gl, true);

    } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
        gl.switchShader(shader, params.padded || posMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    gl.disable(gl.STENCIL_TEST);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.backgroundBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.backgroundBuffer.itemCount);
    gl.enable(gl.STENCIL_TEST);

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../lib/glmatrix.js":21}],24:[function(require,module,exports){
'use strict';

var textVertices = require('../lib/debugtext.js');
var browser = require('../util/browser.js');

module.exports = drawDebug;

function drawDebug(gl, painter, tile, params) {
    // Blend to the front, not the back.
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.switchShader(painter.debugShader, painter.tile.posMatrix, painter.tile.exMatrix);

    // draw bounding rectangle
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
    gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4f(painter.debugShader.u_color, 1, 0, 0, 1);
    gl.lineWidth(4);
    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);

    // draw tile coordinate
    var coord = params.z + '/' + params.x + '/' + params.y;

    var vertices = textVertices(coord, 50, 200, 5);

    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
    gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.lineWidth(8 * browser.devicePixelRatio);
    gl.uniform4f(painter.debugShader.u_color, 1, 1, 1, 1);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
    gl.lineWidth(2 * browser.devicePixelRatio);
    gl.uniform4f(painter.debugShader.u_color, 0, 0, 0, 1);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);

    // Revert blending mode to blend to the back.
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
}

},{"../lib/debugtext.js":20,"../util/browser.js":76}],25:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');
var mat3 = require('../lib/glmatrix.js').mat3;

module.exports = drawFill;

function drawFill(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {

    var translatedPosMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle['fill-translate'], layerStyle['fill-translate-anchor']);

    var color = layerStyle['fill-color'];

    var vertex, elements, group, count;

    // Draw the stencil mask.

    // We're only drawing to the first seven bits (== support a maximum of
    // 127 overlapping polygons in one place before we get rendering errors).
    gl.stencilMask(0x3F);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
    // increasing the lower 7 bits by one if the triangle is a front-facing
    // triangle. This means that all visible polygons should be in CCW
    // orientation, while all holes (see below) are in CW orientation.
    gl.stencilFunc(gl.NOTEQUAL, 0x80, 0x80);

    // When we do a nonzero fill, we count the number of times a pixel is
    // covered by a counterclockwise polygon, and subtract the number of
    // times it is "uncovered" by a clockwise polygon.
    gl.stencilOpSeparate(gl.FRONT, gl.INCR_WRAP, gl.KEEP, gl.KEEP);
    gl.stencilOpSeparate(gl.BACK, gl.DECR_WRAP, gl.KEEP, gl.KEEP);

    // When drawing a shape, we first draw all shapes to the stencil buffer
    // and incrementing all areas where polygons are
    gl.colorMask(false, false, false, false);

    // Draw the actual triangle fan into the stencil buffer.
    gl.switchShader(painter.fillShader, translatedPosMatrix, painter.tile.exMatrix);

    // Draw all buffers
    vertex = bucket.buffers.fillVertex;
    vertex.bind(gl);
    elements = bucket.buffers.fillElement;
    elements.bind(gl);

    var offset, elementOffset;
    for (var i = 0; i < bucket.elementGroups.groups.length; i++) {
        group = bucket.elementGroups.groups[i];
        offset = group.vertexStartIndex * vertex.itemSize;
        gl.vertexAttribPointer(painter.fillShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

        count = group.elementLength * 3;
        elementOffset = group.elementStartIndex * elements.itemSize;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
    }

    // Now that we have the stencil mask in the stencil buffer, we can start
    // writing to the color buffer.
    gl.colorMask(true, true, true, true);

    // From now on, we don't want to update the stencil buffer anymore.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(0x0);

    var strokeColor = layerStyle['fill-outline-color'];

    // Because we're drawing top-to-bottom, and we update the stencil mask
    // below, we have to draw the outline first (!)
    if (layerStyle['fill-antialias'] === true && params.antialiasing && !(layerStyle['fill-image'] && !strokeColor)) {
        gl.switchShader(painter.outlineShader, translatedPosMatrix, painter.tile.exMatrix);
        gl.lineWidth(2 * browser.devicePixelRatio);

        if (strokeColor) {
            // If we defined a different color for the fill outline, we are
            // going to ignore the bits in 0x3F and just care about the global
            // clipping mask.
            gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        } else {
            // Otherwise, we only want to draw the antialiased parts that are
            // *outside* the current shape. This is important in case the fill
            // or stroke color is translucent. If we wouldn't clip to outside
            // the current shape, some pixels from the outline stroke overlapped
            // the (non-antialiased) fill.
            gl.stencilFunc(gl.EQUAL, 0x80, 0xBF);
        }

        gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform4fv(painter.outlineShader.u_color, strokeColor ? strokeColor : color);

        // Draw all buffers
        vertex = bucket.buffers.fillVertex;
        elements = bucket.buffers.outlineElement;
        elements.bind(gl);

        for (var k = 0; k < bucket.elementGroups.groups.length; k++) {
            group = bucket.elementGroups.groups[k];
            offset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(painter.outlineShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

            count = group.secondElementLength * 2;
            elementOffset = group.secondElementStartIndex * elements.itemSize;
            gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }

    var image = layerStyle['fill-image'];
    var opacity = layerStyle['fill-opacity'] || 1;
    var shader;

    if (image) {
        // Draw texture fill
        var imagePos = imageSprite.getPosition(image, true);
        if (!imagePos) return;

        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_mix, painter.transform.zoomFraction);
        gl.uniform1f(shader.u_opacity, opacity);

        var factor = 8 / Math.pow(2, painter.transform.tileZoom - params.z);

        var matrix = mat3.create();
        mat3.scale(matrix, matrix, [
            1 / (imagePos.size[0] * factor),
            1 / (imagePos.size[1] * factor),
            1, 1
        ]);

        gl.uniformMatrix3fv(shader.u_patternmatrix, false, matrix);

        imageSprite.bind(gl, true);

    } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
        gl.switchShader(shader, params.padded || posMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    // Only draw regions that we marked
    gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x3F);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../lib/glmatrix.js":21,"../util/browser.js":76}],26:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');

module.exports = function drawLine(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {

    posMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle['line-translate'], layerStyle['line-translate-anchor']);

    // don't draw zero-width lines
    if (layerStyle['line-width'] <= 0) return;

    var gamma = 1;
    var antialiasing = gamma / browser.devicePixelRatio;

    var lineOffset = layerStyle['line-offset'] / 2;
    var inset = Math.max(-1, lineOffset - layerStyle['line-width'] / 2 - antialiasing / 2) + 1;
    var outset = lineOffset + layerStyle['line-width'] / 2 + antialiasing / 2;

    var imagePos = layerStyle['line-image'] && imageSprite.getPosition(layerStyle['line-image']);
    var shader;

    if (imagePos) {
        var factor = 8 / Math.pow(2, painter.transform.tileZoom - params.z);

        imageSprite.bind(gl, true);

        //factor = Math.pow(2, 4 - painter.transform.tileZoom + params.z);
        shader = painter.linepatternShader;
        gl.switchShader(shader, posMatrix, painter.tile.exMatrix);
        gl.uniform2fv(shader.u_pattern_size, [imagePos.size[0] * factor, imagePos.size[1] ]);
        gl.uniform2fv(shader.u_pattern_tl, imagePos.tl);
        gl.uniform2fv(shader.u_pattern_br, imagePos.br);
        gl.uniform1f(shader.u_fade, painter.transform.zoomFraction);

    } else {
        shader = painter.lineShader;
        gl.switchShader(shader, posMatrix, painter.tile.exMatrix);
        gl.uniform2fv(shader.u_dasharray, layerStyle['line-dasharray']);
        gl.uniform4fv(shader.u_color, layerStyle['line-color']);
    }

    var tilePixelRatio = painter.transform.scale / (1 << params.z) / 8;
    gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
    gl.uniform1f(shader.u_ratio, tilePixelRatio);
    gl.uniform1f(shader.u_blur, layerStyle['line-blur'] + antialiasing);


    var vertex = bucket.buffers.lineVertex;
    vertex.bind(gl);
    var element = bucket.buffers.lineElement;
    element.bind(gl);

    var groups = bucket.elementGroups.groups;
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var offset = group.vertexStartIndex * vertex.itemSize;
        gl.vertexAttribPointer(shader.a_pos, 4, gl.SHORT, false, 8, offset + 0);
        gl.vertexAttribPointer(shader.a_extrude, 2, gl.BYTE, false, 8, offset + 6);
        gl.vertexAttribPointer(shader.a_linesofar, 2, gl.SHORT, false, 8, offset + 4);

        var count = group.elementLength * 3;
        var elementOffset = group.elementStartIndex * element.itemSize;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
    }

};

},{"../util/browser.js":76}],27:[function(require,module,exports){
'use strict';

var TileCoord = require('../source/tilecoord.js');
var PrerenderedTexture = require('./prerendered.js');
var mat4 = require('../lib/glmatrix.js').mat4;

module.exports = drawRaster;

function drawRaster(gl, painter, bucket, layerStyle, params, style, layer, tile) {

    if (layer && layer.layers) {

        if (!bucket.prerendered) {
            bucket.prerendered = new PrerenderedTexture(gl, bucket.info, painter);
            bucket.prerendered.bindFramebuffer();

            gl.clearStencil(0x80);
            gl.stencilMask(0xFF);
            gl.clear(gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            gl.stencilMask(0x00);

            gl.viewport(0, 0, bucket.prerendered.size, bucket.prerendered.size);

            var buffer = bucket.prerendered.buffer * 4096;

            var matrix = mat4.create();
            mat4.ortho(matrix, -buffer, 4096 + buffer, -4096 - buffer, buffer, 0, 1);
            mat4.translate(matrix, matrix, [0, -4096, 0]);

            params.padded = mat4.create();
            mat4.ortho(params.padded, 0, 4096, -4096, 0, 0, 1);
            mat4.translate(params.padded, params.padded, [0, -4096, 0]);

            painter.draw(tile, style, layer.layers, params, matrix);

            delete params.padded;

            if (bucket.info['raster-blur'] > 0) {
                bucket.prerendered.blur(painter, bucket.info['raster-blur']);
            }

            bucket.prerendered.unbindFramebuffer();
            gl.viewport(0, 0, painter.width, painter.height);
        }

    }

    var texture = bucket.tile ? bucket.tile : bucket.prerendered;

    gl.disable(gl.STENCIL_TEST);

    var shader = painter.rasterShader;
    gl.switchShader(shader, painter.tile.posMatrix, painter.tile.exMatrix);

    // color parameters
    gl.uniform1f(shader.u_brightness_low, layerStyle['raster-brightness'][0]);
    gl.uniform1f(shader.u_brightness_high, layerStyle['raster-brightness'][1]);
    gl.uniform1f(shader.u_saturation_factor, saturationFactor(layerStyle['raster-saturation']));
    gl.uniform1f(shader.u_contrast_factor, contrastFactor(layerStyle['raster-contrast']));
    gl.uniform3fv(shader.u_spin_weights, spinWeights(layerStyle['raster-hue-rotate']));


    var parentTile, opacities;
    if (layer && layer.layers) {
        parentTile = null;
        opacities = [layerStyle['raster-opacity'], 0];
    } else {
        parentTile = findParent(texture);
        opacities = getOpacities(texture, parentTile);
    }
    var parentScaleBy, parentTL;

    gl.activeTexture(gl.TEXTURE0);
    texture.bind(gl);

    if (parentTile) {
        gl.activeTexture(gl.TEXTURE1);
        parentTile.bind(gl);

        var tilePos = TileCoord.fromID(texture.id);
        var parentPos = parentTile && TileCoord.fromID(parentTile.id);
        parentScaleBy = Math.pow(2, parentPos.z - tilePos.z);
        parentTL = [tilePos.x * parentScaleBy % 1, tilePos.y * parentScaleBy % 1];
    } else {
        opacities[1] = 0;
    }

    var bufferScale = bucket.prerendered ? (4096 * (1 + 2 * bucket.prerendered.buffer)) / 4096 : 1;

    // cross-fade parameters
    gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
    gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
    gl.uniform1f(shader.u_buffer_scale, bufferScale);
    gl.uniform1f(shader.u_opacity0, opacities[0]);
    gl.uniform1f(shader.u_opacity1, opacities[1]);
    gl.uniform1i(shader.u_image0, 0);
    gl.uniform1i(shader.u_image1, 1);

    gl.bindBuffer(gl.ARRAY_BUFFER, texture.boundsBuffer || painter.tileExtentBuffer);

    gl.vertexAttribPointer(shader.a_pos,         2, gl.SHORT, false, 8, 0);
    gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.enable(gl.STENCIL_TEST);
}

function findParent(tile) {
    var source = tile.source;
    if (!source) return;
    var parentTiles = {};
    source._findLoadedParent(tile.id, source.options.minZoom, parentTiles);
    return source.tiles[Object.keys(parentTiles)[0]];
}

function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
}

function spinWeights(angle) {
    angle *= Math.PI / 180;
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    return [
        (2 * c + 1) / 3,
        (-Math.sqrt(3) * s - c + 1) / 3,
        (Math.sqrt(3) * s - c + 1) / 3
    ];
}

function contrastFactor(contrast) {
    return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
}

function saturationFactor(saturation) {
    return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        -saturation;
}

function getOpacities(tile, parentTile) {
    if (!tile.source) return [1, 0];

    var now = new Date().getTime();
    var fadeDuration = tile.source.map.style.rasterFadeDuration;

    var sinceTile = (now - tile.timeAdded) / fadeDuration;
    var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

    var tilePos = TileCoord.fromID(tile.id);
    var parentPos = parentTile && TileCoord.fromID(parentTile.id);

    var idealZ = tile.source._coveringZoomLevel(tile.source._getZoom());
    var parentFurther = parentTile ? Math.abs(parentPos.z - idealZ) > Math.abs(tilePos.z - idealZ) : false;

    var opacity = [];
    if (!parentTile || parentFurther) {
        // if no parent or parent is older
        opacity[0] = clamp(sinceTile, 0, 1);
        opacity[1] = 1 - opacity[0];
    } else {
        // parent is younger, zooming out
        opacity[0] = clamp(1 - sinceParent, 0, 1);
        opacity[1] = 1 - opacity[0];
    }

    return opacity;
}

},{"../lib/glmatrix.js":21,"../source/tilecoord.js":41,"./prerendered.js":33}],28:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');
var mat4 = require('../lib/glmatrix.js').mat4;

module.exports = drawSymbols;

function drawSymbols(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite) {
    gl.disable(gl.STENCIL_TEST);
    if (bucket.elementGroups.text.groups.length) {
        drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, 'text');
    }
    if (bucket.elementGroups.icon.groups.length) {
        drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, 'icon');
    }
    gl.enable(gl.STENCIL_TEST);
}

var defaultSizes = {
    icon: 1,
    text: 24
};

function drawSymbol(gl, painter, bucket, layerStyle, posMatrix, params, imageSprite, prefix) {

    posMatrix = painter.translateMatrix(posMatrix, params.z, layerStyle[prefix + '-translate'], layerStyle[prefix + '-translate-anchor']);

    var info = bucket.info;

    var exMatrix = mat4.clone(painter.projectionMatrix);
    var alignedWithMap = info[prefix + '-rotation-alignment'] === 'map';
    var angleOffset = (alignedWithMap ? painter.transform.angle : 0);

    if (angleOffset) {
        mat4.rotateZ(exMatrix, exMatrix, angleOffset);
    }

    // If layerStyle.size > info[prefix + '-max-size'] then labels may collide
    var fontSize = layerStyle[prefix + '-size'] || info[prefix + '-max-size'];
    var fontScale = fontSize / defaultSizes[prefix];
    mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);

    var text = prefix === 'text';
    var sdf = text || bucket.elementGroups.sdfIcons;
    var shader, buffer, texsize;

    if (!text && !imageSprite.loaded())
        return;

    gl.activeTexture(gl.TEXTURE0);

    if (sdf) {
        shader = painter.sdfShader;
    } else {
        shader = painter.iconShader;
    }

    if (text) {
        painter.glyphAtlas.updateTexture(gl);
        buffer = bucket.buffers.glyphVertex;
        texsize = [painter.glyphAtlas.width / 4, painter.glyphAtlas.height / 4];
    } else {
        imageSprite.bind(gl, alignedWithMap || params.rotating || params.zooming || fontScale != 1 || sdf);
        buffer = bucket.buffers.iconVertex;
        texsize = [imageSprite.img.width, imageSprite.img.height];
    }

    gl.switchShader(shader, posMatrix, exMatrix);
    gl.uniform1i(shader.u_texture, 0);
    gl.uniform2fv(shader.u_texsize, texsize);

    buffer.bind(gl);

    var ubyte = gl.UNSIGNED_BYTE;

    var stride = text ? 16 : 20;

    gl.vertexAttribPointer(shader.a_pos,          2, gl.SHORT, false, stride, 0);
    gl.vertexAttribPointer(shader.a_offset,       2, gl.SHORT, false, stride, 4);
    gl.vertexAttribPointer(shader.a_labelminzoom, 1, ubyte,    false, stride, 8);
    gl.vertexAttribPointer(shader.a_minzoom,      1, ubyte,    false, stride, 9);
    gl.vertexAttribPointer(shader.a_maxzoom,      1, ubyte,    false, stride, 10);
    gl.vertexAttribPointer(shader.a_angle,        1, ubyte,    false, stride, 11);
    gl.vertexAttribPointer(shader.a_rangeend,     1, ubyte,    false, stride, 12);
    gl.vertexAttribPointer(shader.a_rangestart,   1, ubyte,    false, stride, 13);

    if (text) {
        gl.vertexAttribPointer(shader.a_tex,          2, ubyte,     false, stride, 14);
    } else {
        gl.vertexAttribPointer(shader.a_tex,          2, gl.SHORT,  false, stride, 16);
    }

    // Convert the -pi..pi to an int8 range.
    var angle = Math.round((painter.transform.angle) / Math.PI * 128);

    // adjust min/max zooms for variable font sies
    var zoomAdjust = Math.log(fontSize / info[prefix + '-max-size']) / Math.LN2 || 0;

    var flip = alignedWithMap && info[prefix + '-keep-upright'];
    gl.uniform1f(shader.u_flip, flip ? 1 : 0);
    gl.uniform1f(shader.u_angle, (angle + 256) % 256);
    gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

    var f = painter.frameHistory.getFadeProperties(300);
    gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
    gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
    gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
    gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);

    if (!sdf) gl.uniform1f(shader.u_opacity, layerStyle['icon-opacity']);

    var sdfFontSize = text ? 24 : 1;
    var sdfPx = 8;
    var blurOffset = 1.19;
    var haloOffset = 6;

    if (sdf) {

        gl.uniform1f(shader.u_gamma, 0.105 * sdfFontSize / fontSize / browser.devicePixelRatio);
        gl.uniform4fv(shader.u_color, layerStyle[prefix + '-color']);
        gl.uniform1f(shader.u_buffer, (256 - 64) / 256);
    }

    var begin = bucket.elementGroups[prefix].groups[0].vertexStartIndex,
        len = bucket.elementGroups[prefix].groups[0].vertexLength;

    gl.drawArrays(gl.TRIANGLES, begin, len);

    if (sdf && layerStyle[prefix + '-halo-color']) {
        // Draw halo underneath the text.
        gl.uniform1f(shader.u_gamma, (layerStyle[prefix + '-halo-blur'] * blurOffset / (fontSize / sdfFontSize) / sdfPx) + (0.105 * sdfFontSize / fontSize) / browser.devicePixelRatio);
        gl.uniform4fv(shader.u_color, layerStyle[prefix + '-halo-color']);
        gl.uniform1f(shader.u_buffer, (haloOffset - layerStyle[prefix + '-halo-width'] / (fontSize / sdfFontSize)) / sdfPx);

        gl.drawArrays(gl.TRIANGLES, begin, len);
    }
}

},{"../lib/glmatrix.js":21,"../util/browser.js":76}],29:[function(require,module,exports){
'use strict';

var browser = require('../util/browser.js');
var mat4 = require('../lib/glmatrix.js').mat4;

module.exports = drawVertices;

function drawVertices(gl, painter, bucket) {
    // Blend to the front, not the back.
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.switchShader(painter.dotShader, painter.tile.posMatrix, painter.tile.exMatrix);

    // // Draw debug points.
    gl.uniform1f(painter.dotShader.u_size, 4 * browser.devicePixelRatio);
    gl.uniform1f(painter.dotShader.u_blur, 0.25);
    gl.uniform4fv(painter.dotShader.u_color, [0.25, 0, 0, 0.25]);

    // Draw the actual triangle fan into the stencil buffer.

    var vertex, groups, group, begin, count;

    // Draw all buffers
    if (bucket.info.fill) {
        vertex = bucket.buffers.fillVertex;
        vertex.bind(gl);
        groups = bucket.elementGroups.groups;
        for (var i = 0; i < groups.length; i++) {
            group = groups[i];
            begin = group.vertexStartIndex;
            count = group.vertexLength;
            gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, 0, 0);
            gl.drawArrays(gl.POINTS, begin, count);
        }
    }

    var newPosMatrix = mat4.clone(painter.tile.posMatrix);
    mat4.scale(newPosMatrix, newPosMatrix, [0.5, 0.5, 1]);

    gl.switchShader(painter.dotShader, newPosMatrix, painter.tile.exMatrix);

    // Draw all line buffers
    if (bucket.info.line) {
        vertex = bucket.buffers.lineVertex;
        vertex.bind(gl);
        groups = bucket.elementGroups.groups;
        for (var k = 0; k < groups.length; k++) {
            group = groups[k];
            begin = group.vertexStartIndex;
            count = group.vertexLength;
            gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, 0, 0);
            gl.drawArrays(gl.POINTS, begin, count);
        }

    }

    // Revert blending mode to blend to the back.
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
}

},{"../lib/glmatrix.js":21,"../util/browser.js":76}],30:[function(require,module,exports){
'use strict';

module.exports = FrameHistory;

function FrameHistory() {
}

FrameHistory.prototype.getFadeProperties = function(duration) {
    if (duration === undefined) duration = 300;
    var currentTime = (new Date()).getTime();

    // Remove frames until only one is outside the duration, or until there are only three
    while (frameHistory.length > 3 && frameHistory[1].time + duration < currentTime) {
        frameHistory.shift();
    }

    if (frameHistory[1].time + duration < currentTime) {
        frameHistory[0].z = frameHistory[1].z;
    }

    var frameLen = frameHistory.length;
    if (frameLen < 3) console.warn('there should never be less than three frames in the history');

    // Find the range of zoom levels we want to fade between
    var startingZ = frameHistory[0].z,
        lastFrame = frameHistory[frameLen - 1],
        endingZ = lastFrame.z,
        lowZ = Math.min(startingZ, endingZ),
        highZ = Math.max(startingZ, endingZ);

    // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
    var zoomDiff = lastFrame.z - frameHistory[1].z,
        timeDiff = lastFrame.time - frameHistory[1].time;
    var fadedist = zoomDiff / (timeDiff / duration);

    if (isNaN(fadedist)) console.warn('fadedist should never be NaN');

    // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
    // bump is how much farther it would have been if it had continued zooming at the same rate
    var bump = (currentTime - lastFrame.time) / duration * fadedist;

    return {
        fadedist: fadedist,
        minfadezoom: lowZ,
        maxfadezoom: highZ,
        bump: bump
    };
};

// Store previous render times
var frameHistory = [];

// Record frame history that will be used to calculate fading params
FrameHistory.prototype.record = function(zoom) {
    var currentTime = (new Date()).getTime();

    // first frame ever
    if (!frameHistory.length) {
        frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
    }

    if (frameHistory.length === 2 || frameHistory[frameHistory.length - 1].z !== zoom) {
        frameHistory.push({
            time: currentTime,
            z: zoom
        });
    }
};


},{}],31:[function(require,module,exports){
'use strict';

var shaders = require('./shaders.js');

exports.extend = function(context) {
    context.getShader = function(name, type) {
        var kind = type == this.FRAGMENT_SHADER ? 'fragment' : 'vertex';
        if (!shaders[name] || !shaders[name][kind]) {
            throw new Error("Could not find shader " + name);
        }

        var shader = this.createShader(type);
        this.shaderSource(shader, shaders[name][kind]);
        this.compileShader(shader);
        if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
            throw new Error(this.getShaderInfoLog(shader));
        }
        return shader;
    };

    context.initializeShader = function(name, attributes, uniforms) {
        var shader = {
            program: this.createProgram(),
            fragment: this.getShader(name, this.FRAGMENT_SHADER),
            vertex: this.getShader(name, this.VERTEX_SHADER),
            attributes: []
        };
        this.attachShader(shader.program, shader.vertex);
        this.attachShader(shader.program, shader.fragment);
        this.linkProgram(shader.program);

        if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
            console.error(this.getProgramInfoLog(shader.program));
            alert("Could not initialize shader " + name);
        } else {
            for (var i = 0; i < attributes.length; i++) {
                shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                shader.attributes.push(shader[attributes[i]]);
            }
            for (var k = 0; k < uniforms.length; k++) {
                shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
            }
        }

        return shader;
    };

    // Switches to a different shader program.
    context.switchShader = function(shader, posMatrix, exMatrix) {
        if (!posMatrix) {
            console.trace('posMatrix does not have required argument');
        }

        if (this.currentShader !== shader) {
            this.useProgram(shader.program);

            // Disable all attributes from the existing shader that aren't used in
            // the new shader. Note: attribute indices are *not* program specific!
            var enabled = this.currentShader ? this.currentShader.attributes : [];
            var required = shader.attributes;

            for (var i = 0; i < enabled.length; i++) {
                if (required.indexOf(enabled[i]) < 0) {
                    this.disableVertexAttribArray(enabled[i]);
                }
            }

            // Enable all attributes for the new shader.
            for (var j = 0; j < required.length; j++) {
                if (enabled.indexOf(required[j]) < 0) {
                    this.enableVertexAttribArray(required[j]);
                }
            }

            this.currentShader = shader;
        }

        // Update the matrices if necessary. Note: This relies on object identity!
        // This means changing the matrix values without the actual matrix object
        // will FAIL to update the matrix properly.
        if (shader.posMatrix !== posMatrix) {
            this.uniformMatrix4fv(shader.u_posmatrix, false, posMatrix);
            shader.posMatrix = posMatrix;
        }
        if (exMatrix && shader.exMatrix !== exMatrix && shader.u_exmatrix) {
            this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
            shader.exMatrix = exMatrix;
        }
    };

    return context;
};

},{"./shaders.js":34}],32:[function(require,module,exports){
'use strict';

var glutil = require('./glutil.js');
var browser = require('../util/browser.js');
var GlyphAtlas = require('../symbol/glyphatlas.js');
var glmatrix = require('../lib/glmatrix.js');
var FrameHistory = require('./framehistory.js');

var mat4 = glmatrix.mat4;

var drawSymbol = require('./drawsymbol.js');
var drawLine = require('./drawline.js');
var drawFill = require('./drawfill.js');
var drawRaster = require('./drawraster.js');
var drawDebug = require('./drawdebug.js');
var drawBackground = require('./drawbackground.js');
var drawVertices = require('./drawvertices.js');

/*
 * Initialize a new painter object.
 *
 * @param {Canvas} gl an experimental-webgl drawing context
 */
module.exports = GLPainter;
function GLPainter(gl, transform) {
    this.gl = glutil.extend(gl);
    this.transform = transform;

    this.reusableTextures = {};
    this.preFbos = {};

    this.tileExtent = 4096;
    this.frameHistory = new FrameHistory();

    this.setup();
}

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
GLPainter.prototype.resize = function(width, height) {
    var gl = this.gl;
    // Initialize projection matrix
    this.projectionMatrix = mat4.create();
    mat4.ortho(this.projectionMatrix, 0, width, height, 0, 0, -1);

    this.width = width * browser.devicePixelRatio;
    this.height = height * browser.devicePixelRatio;
    gl.viewport(0, 0, this.width, this.height);

};


GLPainter.prototype.setup = function() {
    var gl = this.gl;

    gl.verbose = true;

    // We are blending the new pixels *behind* the existing pixels. That way we can
    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);

    gl.enable(gl.STENCIL_TEST);

    this.glyphAtlas = new GlyphAtlas(1024, 1024);
    // this.glyphAtlas.debug = true;
    this.glyphAtlas.bind(gl);

    // Initialize shaders
    this.debugShader = gl.initializeShader('debug',
        ['a_pos'],
        ['u_posmatrix', 'u_pointsize', 'u_color']);

    this.compositeShader = gl.initializeShader('composite',
        ['a_pos'],
        ['u_posmatrix', 'u_opacity']);

    this.gaussianShader = gl.initializeShader('gaussian',
        ['a_pos'],
        ['u_posmatrix', 'u_opacity', 'u_image', 'u_offset']);

    this.rasterShader = gl.initializeShader('raster',
        ['a_pos', 'a_texture_pos'],
        ['u_posmatrix', 'u_brightness_low', 'u_brightness_high', 'u_saturation_factor', 'u_spin_weights', 'u_contrast_factor', 'u_opacity0', 'u_opacity1', 'u_image0', 'u_image1', 'u_tl_parent', 'u_scale_parent', 'u_buffer_scale']);

    this.lineShader = gl.initializeShader('line',
        ['a_pos', 'a_extrude', 'a_linesofar'],
        ['u_posmatrix', 'u_exmatrix', 'u_linewidth', 'u_color', 'u_debug', 'u_ratio', 'u_dasharray', 'u_blur']);

    this.linepatternShader = gl.initializeShader('linepattern',
        ['a_pos', 'a_extrude', 'a_linesofar'],
        ['u_posmatrix', 'u_exmatrix', 'u_linewidth', 'u_ratio', 'u_pattern_size', 'u_pattern_tl', 'u_pattern_br', 'u_point', 'u_blur', 'u_fade']);

    this.dotShader = gl.initializeShader('dot',
        ['a_pos'],
        ['u_posmatrix', 'u_size', 'u_color', 'u_blur']);

    this.sdfShader = gl.initializeShader('sdf',
        ['a_pos', 'a_tex', 'a_offset', 'a_angle', 'a_minzoom', 'a_maxzoom', 'a_rangeend', 'a_rangestart', 'a_labelminzoom'],
        ['u_posmatrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_color', 'u_gamma', 'u_buffer', 'u_angle', 'u_zoom', 'u_flip', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom']);

    this.iconShader = gl.initializeShader('icon',
        ['a_pos', 'a_tex', 'a_offset', 'a_angle', 'a_minzoom', 'a_maxzoom', 'a_rangeend', 'a_rangestart', 'a_labelminzoom'],
        ['u_posmatrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_angle', 'u_zoom', 'u_flip', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_opacity']);

    this.outlineShader = gl.initializeShader('outline',
        ['a_pos'],
        ['u_posmatrix', 'u_color', 'u_world']
    );

    this.patternShader = gl.initializeShader('pattern',
        ['a_pos'],
        ['u_posmatrix', 'u_pattern_tl', 'u_pattern_br', 'u_mix', 'u_patternmatrix', 'u_opacity', 'u_image']
    );

    this.fillShader = gl.initializeShader('fill',
        ['a_pos'],
        ['u_posmatrix', 'u_color']
    );

    this.identityMatrix = mat4.create();

    // The backgroundBuffer is used when drawing to the full *canvas*
    this.backgroundBuffer = gl.createBuffer();
    this.backgroundBuffer.itemSize = 2;
    this.backgroundBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

    // The tileExtentBuffer is used when drawing to a full *tile*
    this.tileExtentBuffer = gl.createBuffer();
    this.tileExtentBuffer.itemSize = 4;
    this.tileExtentBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([
        // tile coord x, tile coord y, texture coord x, texture coord y
                      0, 0,                    0, 0,
        this.tileExtent, 0,                32767, 0,
                      0, this.tileExtent,      0, 32767,
        this.tileExtent, this.tileExtent,  32767, 32767
    ]), gl.STATIC_DRAW);

    // The debugBuffer is used to draw tile outlines for debugging
    this.debugBuffer = gl.createBuffer();
    this.debugBuffer.itemSize = 2;
    this.debugBuffer.itemCount = 5;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([0, 0, 4095, 0, 4095, 4095, 0, 4095, 0, 0]), gl.STATIC_DRAW);

    // The debugTextBuffer is used to draw tile IDs for debugging
    this.debugTextBuffer = gl.createBuffer();
    this.debugTextBuffer.itemSize = 2;
};

/*
 * Reset the color buffers of the drawing canvas.
 */
GLPainter.prototype.clearColor = function() {
    var gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/*
 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
 * new tiles at the same location, while retaining previously drawn pixels.
 */
GLPainter.prototype.clearStencil = function() {
    var gl = this.gl;
    gl.clearStencil(0x0);
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
};

GLPainter.prototype.drawClippingMask = function() {
    var gl = this.gl;
    gl.switchShader(this.fillShader, this.tile.posMatrix, this.tile.exMatrix);
    gl.colorMask(false, false, false, false);

    // Clear the entire stencil buffer, except for the 7th bit, which stores
    // the global clipping mask that allows us to avoid drawing in regions of
    // tiles we've already painted in.
    gl.clearStencil(0x0);
    gl.stencilMask(0xBF);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // The stencil test will fail always, meaning we set all pixels covered
    // by this geometry to 0x80. We use the highest bit 0x80 to mark the regions
    // we want to draw in. All pixels that have this bit *not* set will never be
    // drawn in.
    gl.stencilFunc(gl.EQUAL, 0xC0, 0x40);
    gl.stencilMask(0xC0);
    gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);

    // Draw the clipping mask
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
    gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);

    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    gl.stencilMask(0x00);
    gl.colorMask(true, true, true, true);
};

/*
 * Draw a new tile to the context, assuming that the viewport is
 * already correctly set.
 */
GLPainter.prototype.draw = function glPainterDraw(tile, style, layers, params, matrix) {
    this.tile = tile;

    // false when drawing a group of composited layers
    if (tile && !matrix) {
        // Draw the root clipping mask.
        this.drawClippingMask();
    }

    if (!Array.isArray(layers)) console.warn('Layers is not an array');

    this.frameHistory.record(this.transform.zoom);

    // Draw layers front-to-back.
    // Layers are already in reverse order from style.restructure()
    for (var i = 0, len = layers.length; i < len; i++) {
        this.applyStyle(layers[i], style, tile && tile.buckets, params, tile, matrix);
    }

    if (params.debug) {
        drawDebug(this.gl, this, tile, params);
    }
};

GLPainter.prototype.applyStyle = function(layer, style, buckets, params, tile, matrix) {
    var gl = this.gl;

    var layerStyle = style.computed[layer.id];
    if (!layerStyle || layerStyle.hidden) return;

    if (layer.layers && layer.type === 'raster') {
        drawRaster(gl, this, buckets[layer.bucket], layerStyle, params, style, layer, tile);
    } else if (params.background) {
        drawBackground(gl, this, undefined, layerStyle, this.identityMatrix, params, style.sprite);
    } else {

        var bucket = buckets[layer.bucket];
        // There are no vertices yet for this layer.
        if (!bucket || (bucket.hasData && !bucket.hasData())) return;

        var type = bucket.type;

        if (bucket.minZoom && this.transform.zoom < bucket.minZoom) return;
        if (bucket.maxZoom && this.transform.zoom >= bucket.maxZoom) return;

        var draw = type === 'symbol' ? drawSymbol :
                   type === 'fill' ? drawFill :
                   type === 'line' ? drawLine :
                   type === 'raster' ? drawRaster : null;

        if (draw) {
            var useMatrix = matrix || this.tile.posMatrix;

            draw(gl, this, bucket, layerStyle, useMatrix, params, style.sprite);
        } else {
            console.warn('No bucket type specified');
        }

        if (params.vertices && !layer.layers) {
            drawVertices(gl, this, bucket);
        }
    }
};

// Draws non-opaque areas. This is for debugging purposes.
GLPainter.prototype.drawStencilBuffer = function() {
    var gl = this.gl;
    gl.switchShader(this.fillShader, this.identityMatrix);

    // Blend to the front, not the back.
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);

    // Drw the filling quad where the stencil buffer isn't set.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4fv(this.fillShader.u_color, [0, 0, 0, 0.5]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.backgroundBuffer.itemCount);

    // Revert blending mode to blend to the back.
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
};

GLPainter.prototype.translateMatrix = function(matrix, z, translate, anchor) {
    if (!translate[0] && !translate[1]) return matrix;

    if (anchor === 'viewport') {
        var sin_a = Math.sin(-this.transform.angle);
        var cos_a = Math.cos(-this.transform.angle);
        translate = [
            translate[0] * cos_a - translate[1] * sin_a,
            translate[0] * sin_a + translate[1] * cos_a
        ];
    }

    var tilePixelRatio = this.transform.scale / (1 << z) / 8;
    var translation = [
        translate[0] / tilePixelRatio,
        translate[1] / tilePixelRatio,
        0
    ];

    var translatedMatrix = new Float32Array(16);
    mat4.translate(translatedMatrix, matrix, translation);
    return translatedMatrix;
};

GLPainter.prototype.saveTexture = function(texture) {
    var textures = this.reusableTextures[texture.size];
    if (!textures) {
        this.reusableTextures[texture.size] = [texture];
    } else {
        textures.push(texture);
    }
};


GLPainter.prototype.getTexture = function(size) {
    var textures = this.reusableTextures[size];
    return textures && textures.length > 0 ? textures.pop() : null;
};

},{"../lib/glmatrix.js":21,"../symbol/glyphatlas.js":59,"../util/browser.js":76,"./drawbackground.js":23,"./drawdebug.js":24,"./drawfill.js":25,"./drawline.js":26,"./drawraster.js":27,"./drawsymbol.js":28,"./drawvertices.js":29,"./framehistory.js":30,"./glutil.js":31}],33:[function(require,module,exports){
'use strict';

var glmatrix = require('../lib/glmatrix.js');
var mat4 = glmatrix.mat4;

module.exports = PrerenderedTexture;

function PrerenderedTexture(gl, bucket, painter) {
    this.gl = gl;
    this.buffer = bucket['raster-buffer'] || (1/32);
    this.size = (bucket['raster-size'] || 512) * (1 + 2 * this.buffer);
    this.painter = painter;

    this.texture = null;
    this.fbo = null;
    this.fbos = this.painter.preFbos[this.size];
}

PrerenderedTexture.prototype.bindFramebuffer = function() {
    var gl = this.gl;

    // try to reuse available raster textures
    this.texture = this.painter.getTexture(this.size);

    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size, this.size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.texture.size = this.size;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    if (!this.fbos) {
        this.fbo = gl.createFramebuffer();
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, this.size, this.size);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    } else {
        this.fbo = this.fbos.pop();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    }
};

PrerenderedTexture.prototype.unbindFramebuffer = function() {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (this.fbos) this.fbos.push(this.fbo); else this.painter.preFbos[this.size] = [this.fbo];
};

PrerenderedTexture.prototype.bind = function() {
    if (!this.texture) throw('pre-rendered texture does not exist');
    var gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
};

PrerenderedTexture.prototype.blur = function(painter, passes) {
    var gl = this.gl;
    var originalTexture = this.texture;
    var secondaryTexture = this.painter.getTexture(this.size);
    if (!secondaryTexture) {
        secondaryTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size, this.size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        secondaryTexture.size = this.size;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);

    var matrix = mat4.create();
    mat4.ortho(matrix, 0, 4096, -4096, 0, 0, 1);
    mat4.translate(matrix, matrix, [0, -4096, 0]);

    gl.switchShader(painter.gaussianShader, matrix);
    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(painter.gaussianShader.u_image, 0);
    gl.uniform1f(painter.gaussianShader.u_opacity, 1);

    for (var i = 0; i < passes; i++) {

        // Render horizontal
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, secondaryTexture, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2fv(painter.gaussianShader.u_offset, [1 / this.size, 0]);
        gl.bindTexture(gl.TEXTURE_2D, originalTexture);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
        gl.vertexAttribPointer(painter.gaussianShader.a_pos, 2, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);


        // Render vertical
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, originalTexture, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2fv(painter.gaussianShader.u_offset, [0, 1 / this.size]);
        gl.bindTexture(gl.TEXTURE_2D, secondaryTexture);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
        gl.vertexAttribPointer(painter.gaussianShader.a_pos, 2, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    this.painter.saveTexture(secondaryTexture);
};

},{"../lib/glmatrix.js":21}],34:[function(require,module,exports){
'use strict';

var glify = undefined;

module.exports = {
    "composite": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_posmatrix;\nvarying highp vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_posmatrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  a = ((tmpvar_2.xy / 2.0) + 0.5);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_image;\nuniform float u_opacity;\nvarying vec2 a;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (texture2D (u_image, a) * u_opacity);\n  gl_FragColor = tmpvar_1;\n}\n\n"},
    "debug": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform float u_pointsize;\nuniform mat4 u_posmatrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = a_pos;\n  tmpvar_1.z = float((a_pos.x >= 32767.0));\n  gl_Position = (u_posmatrix * tmpvar_1);\n  gl_PointSize = u_pointsize;\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n"},
    "dot": {"vertex":"precision mediump float;\nuniform mat4 u_posmatrix;\nuniform float u_size;\nattribute vec2 a_pos;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_posmatrix * tmpvar_1);\n  gl_PointSize = u_size;\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nuniform float u_blur;\nvoid main ()\n{\n  mediump vec2 x_1;\n  x_1 = (gl_PointCoord - 0.5);\n  mediump float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 0.5) / (\n    (0.5 - u_blur)\n   - 0.5)), 0.0, 1.0);\n  gl_FragColor = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n}\n\n"},
    "fill": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_posmatrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_posmatrix * tmpvar_1);\n  gl_PointSize = 2.0;\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n"},
    "gaussian": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_posmatrix;\nuniform vec2 u_offset;\nvarying highp vec2 b[3];\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_posmatrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((tmpvar_2.xy / 2.0) + 0.5);\n  b[0] = tmpvar_3;\n  vec2 cse_4;\n  cse_4 = (u_offset * 1.18243);\n  b[1] = (tmpvar_3 + cse_4);\n  b[2] = (tmpvar_3 - cse_4);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_image;\nvarying vec2 b[3];\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (((texture2D (u_image, b[0]) * 0.40262) + (texture2D (u_image, b[1]) * 0.29869)) + (texture2D (u_image, b[2]) * 0.29869));\n  gl_FragColor = tmpvar_1;\n}\n\n"},
    "line": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\nuniform mat4 u_posmatrix;\nuniform mat4 u_exmatrix;\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 c_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  c_1.x = tmpvar_2.x;\n  c_1.y = sign((tmpvar_2.y - 0.5));\n  a = c_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 1.0);\n  tmpvar_3.xy = floor((a_pos / 2.0));\n  vec4 tmpvar_4;\n  tmpvar_4.zw = vec2(0.0, 0.0);\n  tmpvar_4.xy = (u_linewidth.x * (a_extrude / 63.0));\n  gl_Position = ((u_posmatrix * tmpvar_3) + (u_exmatrix * tmpvar_4));\n  b = (a_linesofar * u_ratio);\n}\n\n","fragment":"precision mediump float;\nuniform float u_debug;\nuniform float u_blur;\nuniform vec2 u_linewidth;\nuniform vec2 u_dasharray;\nuniform vec4 u_color;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (sqrt(dot (a, a)) * u_linewidth.x);\n  float tmpvar_2;\n  tmpvar_2 = (float(mod (b, (u_dasharray.x + u_dasharray.y))));\n  gl_FragColor = (u_color * (clamp (\n    (min ((tmpvar_1 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_1)) / u_blur)\n  , 0.0, 1.0) * max (\n    float((-(u_dasharray.y) >= 0.0))\n  , \n    clamp (min (tmpvar_2, (u_dasharray.x - tmpvar_2)), 0.0, 1.0)\n  )));\n  if ((u_debug > 0.0)) {\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  };\n}\n\n"},
    "linepattern": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\nuniform mat4 u_posmatrix;\nuniform mat4 u_exmatrix;\nuniform float u_point;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 c_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  c_1.x = tmpvar_2.x;\n  c_1.y = sign((tmpvar_2.y - 0.5));\n  a = c_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 1.0);\n  tmpvar_3.xy = floor((a_pos / 2.0));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 0.0;\n  tmpvar_4.xy = ((u_linewidth.x * (a_extrude / 63.0)) * (1.0 - u_point));\n  tmpvar_4.z = (float((a_pos.x >= 32767.0)) + (u_point * float(\n    (c_1.y >= 1.0)\n  )));\n  gl_Position = ((u_posmatrix * tmpvar_3) + (u_exmatrix * tmpvar_4));\n  b = a_linesofar;\n  gl_PointSize = ((2.0 * u_linewidth.x) - 1.0);\n}\n\n","fragment":"precision mediump float;\nuniform float u_point;\nuniform float u_blur;\nuniform float u_fade;\nuniform vec2 u_linewidth;\nuniform vec2 u_pattern_size;\nuniform vec2 u_pattern_tl;\nuniform vec2 u_pattern_br;\nuniform sampler2D u_image;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 j_1;\n  mediump vec2 x_2;\n  x_2 = ((gl_PointCoord * 2.0) - 1.0);\n  mediump float tmpvar_3;\n  tmpvar_3 = (((\n    sqrt(dot (a, a))\n   * \n    (1.0 - u_point)\n  ) + (u_point * \n    sqrt(dot (x_2, x_2))\n  )) * u_linewidth.x);\n  float tmpvar_4;\n  tmpvar_4 = (float(mod ((b / u_pattern_size.x), 1.0)));\n  float tmpvar_5;\n  tmpvar_5 = (0.5 + ((a.y * u_linewidth.x) / u_pattern_size.y));\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_4;\n  tmpvar_6.y = tmpvar_5;\n  vec2 tmpvar_7;\n  tmpvar_7.x = (float(mod ((tmpvar_4 * 2.0), 1.0)));\n  tmpvar_7.y = tmpvar_5;\n  lowp vec4 tmpvar_8;\n  tmpvar_8 = ((texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_6)) * (1.0 - u_fade)) + (u_fade * texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_7))));\n  j_1.w = tmpvar_8.w;\n  j_1.xyz = (tmpvar_8.xyz * tmpvar_8.w);\n  gl_FragColor = (j_1 * clamp ((\n    min ((tmpvar_3 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_3))\n   / u_blur), 0.0, 1.0));\n}\n\n"},
    "outline": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_posmatrix;\nuniform vec2 u_world;\nvarying highp vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_posmatrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  a = (((tmpvar_2.xy + 1.0) / 2.0) * u_world);\n}\n\n","fragment":"precision mediump float;\nuniform vec4 u_color;\nvarying vec2 a;\nvoid main ()\n{\n  highp vec2 x_1;\n  x_1 = (a - gl_FragCoord.xy);\n  highp float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 1.0) / -1.0), 0.0, 1.0);\n  highp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n  gl_FragColor = tmpvar_3;\n}\n\n"},
    "pattern": {"vertex":"precision mediump float;\nuniform mat4 u_posmatrix;\nuniform mat3 u_patternmatrix;\nattribute vec2 a_pos;\nvarying vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_posmatrix * tmpvar_1);\n  vec3 tmpvar_2;\n  tmpvar_2.z = 1.0;\n  tmpvar_2.xy = a_pos;\n  a = (u_patternmatrix * tmpvar_2).xy;\n}\n\n","fragment":"precision mediump float;\nuniform float u_opacity;\nuniform float u_mix;\nuniform vec2 u_pattern_tl;\nuniform vec2 u_pattern_br;\nuniform sampler2D u_image;\nvarying vec2 a;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1 = (vec2(mod (a, 1.0)));\n  lowp vec4 tmpvar_2;\n  tmpvar_2 = (mix (texture2D (u_image, mix (u_pattern_tl, u_pattern_br, tmpvar_1)), texture2D (u_image, mix (u_pattern_tl, u_pattern_br, \n    (vec2(mod ((tmpvar_1 * 2.0), 1.0)))\n  )), u_mix) * u_opacity);\n  gl_FragColor = tmpvar_2;\n}\n\n"},
    "raster": {"vertex":"precision mediump float;\nuniform mat4 u_posmatrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\nvarying vec2 a;\nvarying vec2 b;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_posmatrix * tmpvar_1);\n  vec2 tmpvar_2;\n  tmpvar_2 = (((\n    (a_texture_pos / 32767.0)\n   - 0.5) / u_buffer_scale) + 0.5);\n  a = tmpvar_2;\n  b = ((tmpvar_2 * u_scale_parent) + u_tl_parent);\n}\n\n","fragment":"precision mediump float;\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform float u_brightness_low;\nuniform float u_brightness_high;\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 a;\nvarying vec2 b;\nuniform vec3 u_spin_weights;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = ((texture2D (u_image0, a) * u_opacity0) + (texture2D (u_image1, b) * u_opacity1));\n  lowp vec3 tmpvar_2;\n  tmpvar_2.x = dot (tmpvar_1.xyz, u_spin_weights);\n  tmpvar_2.y = dot (tmpvar_1.xyz, u_spin_weights.zxy);\n  tmpvar_2.z = dot (tmpvar_1.xyz, u_spin_weights.yzx);\n  lowp vec4 tmpvar_3;\n  tmpvar_3.xyz = mix (vec3(u_brightness_low), vec3(u_brightness_high), ((\n    ((tmpvar_2 + ((\n      (((tmpvar_1.x + tmpvar_1.y) + tmpvar_1.z) / 3.0)\n     - tmpvar_2) * u_saturation_factor)) - 0.5)\n   * u_contrast_factor) + 0.5));\n  tmpvar_3.w = tmpvar_1.w;\n  gl_FragColor = tmpvar_3;\n}\n\n"},
    "icon": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\nattribute float a_maxzoom;\nattribute float a_rangeend;\nattribute float a_rangestart;\nattribute float a_labelminzoom;\nuniform mat4 u_posmatrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\nuniform float u_flip;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform float u_opacity;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float d_1;\n  d_1 = 0.0;\n  float tmpvar_2;\n  tmpvar_2 = (float(mod ((a_angle + u_angle), 256.0)));\n  if ((((u_flip > 0.0) && (tmpvar_2 >= 64.0)) && (tmpvar_2 < 192.0))) {\n    d_1 = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (((2.0 - \n    float((u_zoom >= a_minzoom))\n  ) - (1.0 - \n    float((u_zoom >= a_maxzoom))\n  )) + d_1);\n  float tmpvar_4;\n  tmpvar_4 = clamp (((u_fadezoom - a_labelminzoom) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist >= 0.0)) {\n    b = tmpvar_4;\n  } else {\n    b = (1.0 - tmpvar_4);\n  };\n  if ((u_maxfadezoom < a_labelminzoom)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom >= a_labelminzoom)) {\n    b = 1.0;\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = a_pos;\n  vec4 tmpvar_6;\n  tmpvar_6.w = 0.0;\n  tmpvar_6.xy = (a_offset / 64.0);\n  tmpvar_6.z = ((tmpvar_3 + float(\n    (0.0 >= b)\n  )) + (float(\n    (u_angle >= a_rangeend)\n  ) * (1.0 - \n    float((u_angle >= a_rangestart))\n  )));\n  gl_Position = ((u_posmatrix * tmpvar_5) + (u_exmatrix * tmpvar_6));\n  a = (a_tex / u_texsize);\n  b = (b * u_opacity);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_texture;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (texture2D (u_texture, a) * b);\n  gl_FragColor = tmpvar_1;\n}\n\n"},
    "sdf": {"vertex":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\nattribute float a_maxzoom;\nattribute float a_rangeend;\nattribute float a_rangestart;\nattribute float a_labelminzoom;\nuniform mat4 u_posmatrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\nuniform float u_flip;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float d_1;\n  d_1 = 0.0;\n  float tmpvar_2;\n  tmpvar_2 = (float(mod ((a_angle + u_angle), 256.0)));\n  if ((((u_flip > 0.0) && (tmpvar_2 >= 64.0)) && (tmpvar_2 < 192.0))) {\n    d_1 = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (((2.0 - \n    float((u_zoom >= a_minzoom))\n  ) - (1.0 - \n    float((u_zoom >= a_maxzoom))\n  )) + d_1);\n  float tmpvar_4;\n  tmpvar_4 = clamp (((u_fadezoom - a_labelminzoom) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist >= 0.0)) {\n    b = tmpvar_4;\n  } else {\n    b = (1.0 - tmpvar_4);\n  };\n  if ((u_maxfadezoom < a_labelminzoom)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom >= a_labelminzoom)) {\n    b = 1.0;\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = a_pos;\n  vec4 tmpvar_6;\n  tmpvar_6.w = 0.0;\n  tmpvar_6.xy = (a_offset / 64.0);\n  tmpvar_6.z = ((tmpvar_3 + float(\n    (0.0 >= b)\n  )) + (float(\n    (u_angle >= a_rangeend)\n  ) * (1.0 - \n    float((u_angle >= a_rangestart))\n  )));\n  gl_Position = ((u_posmatrix * tmpvar_5) + (u_exmatrix * tmpvar_6));\n  a = (a_tex / u_texsize);\n}\n\n","fragment":"precision mediump float;\nuniform sampler2D u_texture;\nuniform vec4 u_color;\nuniform float u_buffer;\nuniform float u_gamma;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float edge0_1;\n  edge0_1 = (u_buffer - u_gamma);\n  lowp float tmpvar_2;\n  tmpvar_2 = clamp (((texture2D (u_texture, a).w - edge0_1) / (\n    (u_buffer + u_gamma)\n   - edge0_1)), 0.0, 1.0);\n  lowp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * ((tmpvar_2 * \n    (tmpvar_2 * (3.0 - (2.0 * tmpvar_2)))\n  ) * b));\n  gl_FragColor = tmpvar_3;\n}\n\n"}
};

},{}],35:[function(require,module,exports){
'use strict';

var Source = require('./source.js');
var GeoJSONTile = require('./geojsontile.js');

var GeoJSONSource = module.exports = function(options) {
    this.tiles = {};
    this.alltiles = {};
    this.enabled = true;

    this.zooms = [1, 5, 9, 13];
    this.minTileZoom = this.zooms[0];
    this.maxTileZoom = this.zooms[this.zooms.length - 1];

    this.loadNewTiles = true;
    this.tileJSON = {
        minZoom: 1,
        maxZoom: 13
    };

    this.data = options.data;
};

GeoJSONSource.prototype = Object.create(Source.prototype);

GeoJSONSource.prototype.setData = function(data) {
    this.data = data;
    if (this.map) this._updateData();
    return this;
};

GeoJSONSource.prototype.onAdd = function(map) {
    this.map = map;
    this.painter = map.painter;

    if (this.map.style) this._updateData();
    map.on('style.change', this._updateData.bind(this));
};

GeoJSONSource.prototype._updateData = function() {
    var source = this;
    this.workerID = this.map.dispatcher.send('parse geojson', {
        data: this.data,
        zooms: this.zooms,
        tileSize: 512,
        source: this.id
    }, function(err, tiles) {
        if (err) return;
        for (var i = 0; i < tiles.length; i++) {
            source.alltiles[tiles[i].id] = new GeoJSONTile(tiles[i].id, source, tiles[i]);
        }
        if (source.map) source.map.update();
    });
    return this;
};

GeoJSONSource.prototype._addTile = function(id) {
    var tile = this.alltiles[id];
    if (tile) {
        tile._load();
        this.tiles[id] = tile;
        this.fire('tile.add', {tile: tile});
    }
    return tile || {};
};

GeoJSONSource.prototype._coveringZoomLevel = function(zoom) {
    for (var i = this.zooms.length - 1; i >= 0; i--) {
        if (this.zooms[i] <= zoom) {
            var z = this.zooms[i];
            return z;
        }
    }
    return 0;
};

},{"./geojsontile.js":36,"./source.js":39}],36:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js');
var BufferSet = require('../data/buffer/bufferset.js');
var createBucket = require('../data/createbucket.js');

module.exports = GeoJSONTile;

function GeoJSONTile(id, source, data) {
    this.id = id;
    this.source = source;
    this.data = data;
    this.workerID = source.workerID;
}

GeoJSONTile.prototype = Object.create(Tile.prototype);

GeoJSONTile.prototype._load = function() {
    if (this.loaded) return;
    this.loaded = true;

    var data = this.data;
    this.buffers = new BufferSet(data.buffers);

    this.buckets = {};
    for (var b in data.elementGroups) {
        this.buckets[b] = createBucket(this.source.map.style.buckets[b], this.buffers, undefined, data.elementGroups[b]);
    }


};

// noops
GeoJSONTile.prototype.abort = function() { };
GeoJSONTile.prototype.remove = function() { };

},{"../data/buffer/bufferset.js":2,"../data/createbucket.js":10,"./tile.js":40}],37:[function(require,module,exports){
'use strict';

module.exports = Wrapper;

// conform to vectortile api
function Wrapper(features) {
    this.features = features;
    this.length = features.length;
}

Wrapper.prototype.feature = function(i) {
    return new FeatureWrapper(this.features[i]);
};

var mapping = {
    'Point': 1,
    'LineString': 2,
    'Polygon': 3
};

function FeatureWrapper(feature) {
    this.feature = feature;
    this.type = mapping[feature.type];
    this.properties = feature.properties;
}

FeatureWrapper.prototype.loadGeometry = function() {
    return this.feature.coords;
};

FeatureWrapper.prototype.bbox = function() {

    if (this.type === mapping.Point) {
        return [
            this.feature.coords[0][0].x,
            this.feature.coords[0][0].y,
            this.feature.coords[0][0].x,
            this.feature.coords[0][0].y
        ];
    }

    var rings = this.feature.coords;

    var x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];

        for (var j = 0; j < ring.length; j++) {
            var coord = ring[j];

            x1 = Math.min(x1, coord.x);
            x2 = Math.max(x2, coord.x);
            y1 = Math.min(y1, coord.y);
            y2 = Math.max(y2, coord.y);
        }
    }

    return [x1, y1, x2, y2];
};

},{}],38:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js');
var ajax = require('../util/ajax.js');

module.exports = RasterTile;

function RasterTile(id, source, url, callback) {
    this.id = id;
    this.loaded = false;
    this.url = url;
    this.source = source;
    this.map = source.map;
    this._load();
    this.callback = callback;
    this.uses = 1;

    // Todo finish figuring out what raster buckets are
    this.buckets = {};
    this.info = { raster: true };
    var buckets = this.map.style.buckets;
    for (var b in buckets) {
        var bucket = buckets[b];
        var sourceid = bucket && bucket.source;
        if (source.id === sourceid) {
            this.buckets[b] = {
                info: bucket.render,
                type: 'raster',
                tile: this
            };
        }
    }
}

RasterTile.prototype = Object.create(Tile.prototype);

RasterTile.prototype._load = function() {
    var tile = this;
    ajax.getImage(this.url, function(err, img) {
        // @TODO handle errors.
        if (err) return;
        tile.img = img;
        if (tile.map) tile.onTileLoad();
    });
};

RasterTile.prototype.onTileLoad = function() {
    // start texture upload
    this.bind(this.map.painter.gl);

    this.loaded = true;
    this.callback();
};

RasterTile.prototype.abort = function() {
    this.aborted = true;
    if (this.img) this.img.src = '';
    delete this.img;
};

RasterTile.prototype.bind = function(gl) {
    if (!this.texture) {
        // try to find reusable texture
        this.texture = this.map.painter.getTexture(this.img.width);
        if (this.texture) {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.img);
        } else {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.img);
            this.texture.size = this.img.width;
        }
        gl.generateMipmap(gl.TEXTURE_2D);
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

RasterTile.prototype.remove = function() {
    if (this.texture) this.map.painter.saveTexture(this.texture);
    delete this.map;
};

RasterTile.prototype.featuresAt = function(pos, params, callback) {
    // noop
    callback(null, []);
};

},{"../util/ajax.js":75,"./tile.js":40}],39:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    ajax = require('../util/ajax.js'),
    tileJSON = require('../util/url.js').tileJSON,
    Evented = require('../util/evented.js'),
    Cache = require('../util/mrucache.js'),
    TileCoord = require('./tilecoord'),
    VectorTile = require('./vectortile'),
    RasterTile = require('./rastertile.js'),
    Point = require('point-geometry');

module.exports = Source;

Source.protocols = {
    "mapbox": function(url, callback) {
        //console.log(url, callback);
        //console.log(url.split('://')[1]);
        console.log(tileJSON(url.split('://')[1]));
        ajax.getJSON(tileJSON(url.split('://')[1]), callback);
    },
    "https": ajax.getJSON,
    "http": ajax.getJSON
};

function Source(options) {
    this.tiles = {};
    this.enabled = false;
    this.type = options.type;
    if (this.type === 'vector' && options.tileSize && options.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
    }
    this.Tile = this.type === 'vector' ? VectorTile : RasterTile;
    this.options = util.inherit(this.options, options);
    this.cache = new Cache(this.options.cacheSize, function(tile) {
        tile.remove();
    });

    var loadTileJSON = function(url, callback) {
        callback(null, options);
    };

    if (options.url) {
        loadTileJSON = Source.protocols[options.url.split(':')[0]];
        if (!loadTileJSON) throw new Error('unknown protocol for source URL ' + options.url);
    }

    loadTileJSON(options.url, function(err, tileJSON) {
        if (err) throw err;
        console.log(options.url, JSON.stringify(tileJSON));
        if (!tileJSON.tiles)
            throw new Error('missing tiles property');

        this.tileJSON = util.extend({ minzoom: 0, maxzoom: 22 }, tileJSON);
        this.loadNewTiles = true;
        this.enabled = true;
        this.update();

        if (this.map) this.map.fire('source.add', {source: this});
    }.bind(this));

    this._updateTiles = util.throttle(this._updateTiles, 50, this);
}

Source.prototype = util.inherit(Evented, {
    options: {
        tileSize: 512,
        cacheSize: 20
    },

    onAdd: function(map) {
        this.map = map;
        this.painter = map.painter;
    },

    load: function() {
        for (var t in this.tiles) {
            this.tiles[t]._load();
        }
    },

    loaded: function() {
        for (var t in this.tiles) {
            if (!this.tiles[t].loaded)
                return false;
        }
        return true;
    },

    update: function() {
        if (!this.enabled) return;
        this._updateTiles();
    },

    render: function(layers) {
        // Iteratively paint every tile.
        if (!this.enabled) return;
        var order = Object.keys(this.tiles);
        order.sort(this._z_order);
        for (var i = 0; i < order.length; i++) {
            var id = order[i];
            var tile = this.tiles[id];
            if (tile.loaded ) {
                this._renderTile(tile, id, layers);
            }
        }
    },

    featuresAt: function(point, params, callback) {
        point = Point.convert(point);

        if (params.layer) {
            var style = this.map.style,
                layer = style.getLayer(params.layer);
            params.bucket = style.buckets[layer.ref || layer.id];
        }

        var order = Object.keys(this.tiles);
        order.sort(this._z_order);
        for (var i = 0; i < order.length; i++) {
            var id = order[i];
            var tile = this.tiles[id];
            var pos = tile.positionAt(id, point);

            if (pos && pos.x >= 0 && pos.x < 4096 && pos.y >= 0 && pos.y < 4096) {
                // The click is within the viewport. There is only ever one tile in
                // a layer that has this property.
                return tile.featuresAt(pos, params, callback);
            }
        }

        callback(null, []);
    },

    // get the zoom level adjusted for the difference in map and source tilesizes
    _getZoom: function() {
        var zOffset = Math.log(this.map.transform.tileSize/this.options.tileSize) / Math.LN2;
        return this.map.transform.zoom + zOffset;
    },

    _coveringZoomLevel: function(zoom) {
        for (var z = this.tileJSON.maxzoom; z >= this.tileJSON.minzoom; z--) {
            if (z <= zoom) {
                if (this.type === 'raster') {
                    // allow underscaling by rounding to the nearest zoom level
                    if (z < this.tileJSON.maxzoom) {
                        z += Math.round(zoom - z);
                    }
                }
                return z;
            }
        }
        return 0;
    },

    _childZoomLevel: function(zoom) {
        zoom = Math.max(this.tileJSON.minzoom, zoom + 1);
        return zoom <= this.tileJSON.maxzoom ? zoom : null;
    },

    _getCoveringTiles: function(zoom) {
        if (zoom === undefined) zoom = this._getZoom();
        var z = this._coveringZoomLevel(zoom),
            tiles = 1 << z,
            tr = this.map.transform,
            tileCenter = TileCoord.zoomTo(tr.locationCoordinate(tr.center), z);

        var points = [
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: 0, y: 0}), z),
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: tr.width, y: 0}), z),
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: tr.width, y: tr.height}), z),
            TileCoord.zoomTo(tr.pointCoordinate(tileCenter, {x: 0, y: tr.height}), z)
        ], t = {};

        // Divide the screen up in two triangles and scan each of them:
        // +---/
        // | / |
        // /---+
        this._scanTriangle(points[0], points[1], points[2], 0, tiles, scanLine);
        this._scanTriangle(points[2], points[3], points[0], 0, tiles, scanLine);

        return Object.keys(t).sort(fromCenter);

        function fromCenter(a, b) {
            var ad = Math.abs(a.x - tileCenter.column) +
                    Math.abs(a.y - tileCenter.row),
                bd = Math.abs(b.x - tileCenter.column) +
                    Math.abs(b.y - tileCenter.row);

            return ad - bd;
        }

        function scanLine(x0, x1, y) {
            var x, wx;
            if (y >= 0 && y <= tiles) {
                for (x = x0; x < x1; x++) {
                    wx = (x + tiles) % tiles;
                    t[TileCoord.toID(z, wx, y, Math.floor(x/tiles))] = {x: wx, y: y};
                }
            }
        }
    },

    // Given a tile of data, its id, and a style layers, render the tile to the canvas
    _renderTile: function(tile, id, layers) {
        var pos = TileCoord.fromID(id);
        var z = pos.z, x = pos.x, y = pos.y, w = pos.w;
        x += w * (1 << z);

        tile.calculateMatrices(z, x, y, this.map.transform, this.painter);

        this.painter.draw(tile, this.map.style, layers, {
            z: z, x: x, y: y,
            debug: this.map.debug,
            antialiasing: this.map.antialiasing,
            vertices: this.map.vertices,
            rotating: this.map.rotating,
            zooming: this.map.zooming
        });
    },

    // Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
    // adds found tiles to retain object; returns true if children completely cover the tile

    _findLoadedChildren: function(id, maxCoveringZoom, retain) {
        var complete = true;
        var z = TileCoord.fromID(id).z;
        var ids = TileCoord.children(id);
        for (var i = 0; i < ids.length; i++) {
            if (this.tiles[ids[i]] && this.tiles[ids[i]].loaded) {
                retain[ids[i]] = true;
            } else {
                complete = false;
                if (z < maxCoveringZoom) {
                    // Go further down the hierarchy to find more unloaded children.
                    this._findLoadedChildren(ids[i], maxCoveringZoom, retain);
                }
            }
        }
        return complete;
    },

    // Find a loaded parent of the given tile (up to minCoveringZoom);
    // adds the found tile to retain object and returns true if a parent was found

    _findLoadedParent: function(id, minCoveringZoom, retain) {
        for (var z = TileCoord.fromID(id).z; z >= minCoveringZoom; z--) {
            id = TileCoord.parent(id);
            if (this.tiles[id] && this.tiles[id].loaded) {
                retain[id] = true;
                return true;
            }
        }
        return false;
    },

    // Removes tiles that are outside the viewport and adds new tiles that are inside the viewport.
    _updateTiles: function() {
        if (!this.map || !this.map.loadNewTiles || !this.loadNewTiles || !this.map.sources[this.id]) return;

        var zoom = Math.floor(this._getZoom());
        var required = this._getCoveringTiles().sort(this._centerOut.bind(this));
        var i;
        var id;
        var complete;
        var tile;

        // Determine the overzooming/underzooming amounts.
        var minCoveringZoom = Math.max(this.tileJSON.minzoom, zoom - 10);
        var maxCoveringZoom = this.tileJSON.minzoom;
        while (maxCoveringZoom < zoom + 1) {
            var level = this._childZoomLevel(maxCoveringZoom);
            if (level === null) break;
            else maxCoveringZoom = level;
        }

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
        // Covered is a list of retained tiles who's areas are full covered by other,
        // better, retained tiles. They are not drawn separately.
        this.coveredTiles = {};

        var fullyComplete = true;

        // Add existing child/parent tiles if the actual tile is not yet loaded
        for (i = 0; i < required.length; i++) {
            id = +required[i];
            retain[id] = true;
            tile = this._addTile(id);

            if (!tile.loaded) {
                // The tile we require is not yet loaded. Try to find a parent or
                // child tile that we already have.

                // First, try to find existing child tiles that completely cover the
                // missing tile.
                complete = this._findLoadedChildren(id, maxCoveringZoom, retain);

                // Then, if there are no complete child tiles, try to find existing
                // parent tiles that completely cover the missing tile.
                if (!complete) {
                    complete = this._findLoadedParent(id, minCoveringZoom, retain);
                }

                // The unloaded tile's area is not completely covered loaded tiles
                if (!complete) {
                    fullyComplete = false;
                }
            }
        }

        var now = new Date().getTime();
        var fadeDuration = this.type === 'raster' ? this.map.style.rasterFadeDuration : 0;

        for (id in retain) {
            tile = this.tiles[id];
            if (tile && tile.timeAdded > now - fadeDuration) {
                // This tile is still fading in. Find tiles to cross-fade with it.

                complete = this._findLoadedChildren(id, maxCoveringZoom, retain);

                if (complete) {
                    this.coveredTiles[id] = true;
                } else {
                    this._findLoadedParent(id, minCoveringZoom, retain);
                }
            }
        }

        for (id in this.coveredTiles) retain[id] = true;

        // Remove the tiles we don't need anymore.
        var remove = util.keysDifference(this.tiles, retain);
        for (i = 0; i < remove.length; i++) {
            id = +remove[i];
            this._removeTile(id);
        }
    },

    _loadTile: function(id) {
        var layer = this;
        var map = this.map,
            pos = TileCoord.fromID(id),
            tile;

        if (pos.w === 0) {
             console.time('loading ' + pos.z + '/' + pos.x + '/' + pos.y);
            var url = TileCoord.url(id, this.tileJSON.tiles);
            console.log(url);
            tile = this.tiles[id] = new this.Tile(id, this, url, tileComplete);
        } else {
            var wrapped = TileCoord.toID(pos.z, pos.x, pos.y, 0);
            tile = this.tiles[id] = this.tiles[wrapped] || this._addTile(wrapped);
            tile.uses++;
        }

        function tileComplete(err) {
             console.timeEnd('loading ' + pos.z + '/' + pos.x + '/' + pos.y);
            if (err) {
                console.warn('failed to load tile %d/%d/%d: %s', pos.z, pos.x, pos.y, err.stack || err);
            } else {
                layer.fire('tile.load', {tile: tile});
                map.update();
            }
        }

        return tile;
    },

    // Adds a vector tile to the map. It will trigger a rerender of the map and will
    // be part in all future renders of the map. The map object will handle copying
    // the tile data to the GPU if it is required to paint the current viewport.
    _addTile: function(id) {
        var tile = this.tiles[id];

        if (!tile) {
            tile = this.cache.get(id);
            if (tile) {
                tile.uses = 1;
                this.tiles[id] = tile;
            }
        }

        if (!tile) {
            tile = this._loadTile(id);
            this.fire('tile.add', {tile: tile});
        }

        if (tile && tile.loaded && !tile.timeAdded) {
            tile.timeAdded = new Date().getTime();
            if (this.type === 'raster') {
                this.map.animationLoop.set(this.map.style.rasterFadeDuration);
            }
        }

        return tile;
    },

    _removeTile: function(id) {
        var tile = this.tiles[id];
        if (tile) {
            tile.uses--;
            delete this.tiles[id];

            if (tile.uses <= 0) {
                delete tile.timeAdded;
                if (!tile.loaded) {
                    tile.abort();
                    tile.remove();
                } else {
                    this.cache.add(id, tile);
                }

                this.fire('tile.remove', {tile: tile});
            }
        }
    },

    // Taken from polymaps src/Layer.js
    // https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

    // scan-line conversion
    _scanTriangle: function(a, b, c, ymin, ymax, scanLine) {
        var ab = this._edge(a, b),
            bc = this._edge(b, c),
            ca = this._edge(c, a);

        var t;

        // sort edges by y-length
        if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
        if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
        if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

        // scan span! scan span!
        if (ab.dy) this._scanSpans(ca, ab, ymin, ymax, scanLine);
        if (bc.dy) this._scanSpans(ca, bc, ymin, ymax, scanLine);
    },

    // scan-line conversion
    _edge: function(a, b) {
        if (a.row > b.row) { var t = a; a = b; b = t; }
        return {
            x0: a.column,
            y0: a.row,
            x1: b.column,
            y1: b.row,
            dx: b.column - a.column,
            dy: b.row - a.row
        };
    },

    // scan-line conversion
    _scanSpans: function(e0, e1, ymin, ymax, scanLine) {
        var y0 = Math.max(ymin, Math.floor(e1.y0)),
            y1 = Math.min(ymax, Math.ceil(e1.y1));

        // sort edges by x-coordinate
        if ((e0.x0 == e1.x0 && e0.y0 == e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
            var t = e0; e0 = e1; e1 = t;
        }

        // scan lines!
        var m0 = e0.dx / e0.dy,
            m1 = e1.dx / e1.dy,
            d0 = e0.dx > 0, // use y + 1 to compute x0
            d1 = e1.dx < 0; // use y + 1 to compute x1
        for (var y = y0; y < y1; y++) {
            var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0,
                x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
            scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
    },

    _z_order: function(a, b) {
        return (b % 32) - (a % 32);
    },

    _centerOut: function(a, b) {
        var tr = this.map.transform;
        var aPos = TileCoord.fromID(a);
        var bPos = TileCoord.fromID(b);
        var c = TileCoord.zoomTo(tr.locationCoordinate(tr.center), aPos.z);
        var center = new Point(c.column - 0.5, c.row - 0.5);
        return center.dist(aPos) - center.dist(bPos);
    },
});

var sources = {
    vector: Source,
    raster: Source,
    geojson: require('./geojsonsource'),
    video: require('./videosource')
};

Source.create = function(source) {
    return new sources[source.type](source);
};

},{"../util/ajax.js":75,"../util/evented.js":81,"../util/mrucache.js":83,"../util/url.js":85,"../util/util.js":86,"./geojsonsource":35,"./rastertile.js":38,"./tilecoord":41,"./vectortile":43,"./videosource":44,"point-geometry":97}],40:[function(require,module,exports){
'use strict';

var glmatrix = require('../lib/glmatrix.js'),
    mat2 = glmatrix.mat2,
    mat4 = glmatrix.mat4,
    vec2 = glmatrix.vec2;

module.exports = Tile;

function Tile() {}

Tile.prototype = {
    // todo unhardcode
    tileExtent: 4096,

    calculateMatrices: function(z, x, y, transform, painter) {

        // Initialize model-view matrix that converts from the tile coordinates
        // to screen coordinates.
        var tileScale = Math.pow(2, z);
        var scale = transform.worldSize / tileScale;

        // TODO: remove
        this.scale = scale;

        // The position matrix
        this.posMatrix = mat4.create();
        mat4.translate(this.posMatrix, this.posMatrix, [transform.centerPoint.x, transform.centerPoint.y, 0]);
        mat4.rotateZ(this.posMatrix, this.posMatrix, transform.angle);
        mat4.translate(this.posMatrix, this.posMatrix, [-transform.centerPoint.x, -transform.centerPoint.y, 0]);

        var pixelX = transform.width / 2 - transform.x,
            pixelY = transform.height / 2 - transform.y;

        mat4.translate(this.posMatrix, this.posMatrix, [pixelX + x * scale, pixelY + y * scale, 1]);

        // Create inverted matrix for interaction
        this.invPosMatrix = mat4.create();
        mat4.invert(this.invPosMatrix, this.posMatrix);

        mat4.scale(this.posMatrix, this.posMatrix, [ scale / this.tileExtent, scale / this.tileExtent, 1 ]);
        mat4.multiply(this.posMatrix, painter.projectionMatrix, this.posMatrix);

        // The extrusion matrix.
        this.exMatrix = mat4.clone(painter.projectionMatrix);
        mat4.rotateZ(this.exMatrix, this.exMatrix, transform.angle);

        // 2x2 matrix for rotating points
        this.rotationMatrix = mat2.create();
        mat2.rotate(this.rotationMatrix, this.rotationMatrix, transform.angle);
    },

    positionAt: function(id, point) {
        // tile hasn't finished loading
        if (!this.invPosMatrix) return null;

        var pos = vec2.transformMat4([], [point.x, point.y], this.invPosMatrix);
        vec2.scale(pos, pos, 4096 / this.scale);
        return {
            x: pos[0],
            y: pos[1],
            scale: this.scale
        };
    },

    featuresAt: function(pos, params, callback) {
        this.source.map.dispatcher.send('query features', {
            id: this.id,
            x: pos.x,
            y: pos.y,
            scale: pos.scale,
            source: this.source.id,
            params: params
        }, callback, this.workerID);
    }
};

},{"../lib/glmatrix.js":21}],41:[function(require,module,exports){
'use strict';

/*
 * Tiles are generally represented as packed integer ids constructed by
 * `TileCoord.toID(x, y, z)`
 */

var TileCoord = exports;

TileCoord.toID = function(z, x, y, w) {
    w = w || 0;
    w *= 2;
    if (w < 0) w = w * -1 -1;
    var dim = 1 << z;
    return ((dim * dim * w + dim * y + x) * 32) + z;
};

TileCoord.asString = function(id) {
    var pos = TileCoord.fromID(id);
    return pos.z + "/" + pos.x + "/" + pos.y;
};

/*
 * Parse a packed integer id into an object with x, y, and z properties
 */
TileCoord.fromID = function(id) {
    var z = id % 32, dim = 1 << z;
    var xy = ((id - z) / 32);
    var x = xy % dim, y = ((xy - x) / dim) % dim;
    var w = Math.floor(xy / (dim * dim));
    if (w % 2 !== 0) w = w * -1 -1;
    w /= 2;
    return { z: z, x: x, y: y, w: w };
};

/*
 * Given a packed integer id, return its zoom level
 */
TileCoord.zoom = function(id) {
    return id % 32;
};

// Given an id and a list of urls, choose a url template and return a tile URL
TileCoord.url = function(id, urls) {
    var pos = TileCoord.fromID(id);

    return urls[(pos.x + pos.y) % urls.length]
        .replace('{h}', (pos.x % 16).toString(16) + (pos.y % 16).toString(16))
        .replace('{z}', pos.z)
        .replace('{x}', pos.x)
        .replace('{y}', pos.y);
};

/*
 * Given a packed integer id, return the id of its parent tile
 */
TileCoord.parent = function(id) {
    var pos = TileCoord.fromID(id);
    if (pos.z === 0) return id;
    else return TileCoord.toID(pos.z - 1, Math.floor(pos.x / 2), Math.floor(pos.y / 2));
};

TileCoord.parentWithZoom = function(id, zoom) {
    var pos = TileCoord.fromID(id);
    while (pos.z > zoom) {
        pos.z--;
        pos.x = Math.floor(pos.x / 2);
        pos.y = Math.floor(pos.y / 2);
    }
    return TileCoord.toID(pos.z, pos.x, pos.y);
};

/*
 * Given a packed integer id, return an array of integer ids representing
 * its four children.
 */
TileCoord.children = function(id) {
    var pos = TileCoord.fromID(id);
    pos.z += 1;
    pos.x *= 2;
    pos.y *= 2;
    return [
        TileCoord.toID(pos.z, pos.x, pos.y, pos.w),
        TileCoord.toID(pos.z, pos.x + 1, pos.y, pos.w),
        TileCoord.toID(pos.z, pos.x, pos.y + 1, pos.w),
        TileCoord.toID(pos.z, pos.x + 1, pos.y + 1, pos.w)
    ];
};

TileCoord.zoomTo = function(c, z) {
    c.column = c.column * Math.pow(2, z - c.zoom);
    c.row = c.row * Math.pow(2, z - c.zoom);
    c.zoom = z;
    return c;
};


},{}],42:[function(require,module,exports){
'use strict';

var rewind = require('geojson-rewind');

var TileCoord = require('./tilecoord.js');
var Transform = require('../geo/transform.js');
var Point = require('point-geometry');
var LatLng = require('../geo/latlng.js');

module.exports = tileGeoJSON;

function tileGeoJSON(geojson, zoom) {
    var tiles = {};
    var tileExtent = 4096;
    var transform = new Transform();
    transform.zoom = zoom;

    geojson = rewind(geojson);

    if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            tileFeature(geojson.features[i], transform, tiles, tileExtent);
        }

    } else if (geojson.type === 'Feature') {
        tileFeature(geojson, transform, tiles, tileExtent);

    } else {
        throw('Unrecognized geojson type');
    }

    return tiles;
}

function tileFeature(feature, transform, tiles, tileExtent) {
    var coords = feature.geometry.coordinates;
    var type = feature.geometry.type;

    var tiled;
    if (type === 'Point') {
        tiled = tileLineString([coords], transform, tileExtent);

    } else if (type === 'LineString' || type === 'MultiPoint') {
        tiled = tileLineString(coords, transform, tileExtent);

    } else if (type === 'Polygon' || type === 'MultiLineString') {
        tiled = {};
        for (var i = 0; i < coords.length; i++) {
            var tiled_ = tileLineString(coords[i], transform, tileExtent, type === 'Polygon');
            for (var tileID in tiled_) {
                if (!tiled[tileID]) tiled[tileID] = [];
                tiled[tileID] = (tiled[tileID] || []).concat(tiled_[tileID]);
            }
        }

    } else if (type === 'MultiPolygon') {
        throw("todo");
    } else {
        throw("unrecognized geometry type");
    }

    for (var id in tiled) {
        tiles[id] = tiles[id] || [];
        tiles[id].push({
            properties: feature.properties,
            coords: tiled[id],
            type: feature.geometry.type
        });
    }
}

function tileLineString(coords, transform, tileExtent, rejoin) {

    var padding = 0.01;
    var paddedExtent = tileExtent * (1 + 2 * padding);
    var coord = transform.locationCoordinate(new LatLng(coords[0][1], coords[0][0]));
    var prevCoord;

    var tiles = {};

    for (var i = 0; i < coords.length; i++) {
        prevCoord = coord;
        coord = transform.locationCoordinate(new LatLng(coords[i][1], coords[i][0]));

        var dx = coord.column - prevCoord.column || Number.MIN_VALUE,
            dy = coord.row - prevCoord.row || Number.MIN_VALUE,
            dirX = dx / Math.abs(dx),
            dirY = dy / Math.abs(dy);

        // Find the rectangular bounding box, in tiles, of the polygon
        var startTileX = Math.floor(prevCoord.column - dirX * padding);
        var endTileX = Math.floor(coord.column + dirX * padding);
        var startTileY = Math.floor(prevCoord.row - dirY * padding);
        var endTileY = Math.floor(coord.row + dirY * padding);

        // Iterate over all tiles the segment might intersect
        // and split the segment across those tiles
        for (var x = startTileX; (x - endTileX) * dirX <= 0; x += dirX) {
            var leftX = (x - padding - prevCoord.column) / dx;
            var rightX = (x + 1 + padding - prevCoord.column) / dx;

            for (var y = startTileY; (y - endTileY) * dirY <= 0; y += dirY) {
                var topY = (y - padding - prevCoord.row) / dy;
                var bottomY = (y + 1 + padding - prevCoord.row) / dy;

                // fraction of the distance along the segment at which the segment
                // enters or exits the tile
                var enter = Math.max(Math.min(leftX, rightX), Math.min(topY, bottomY));
                var exit = Math.min(Math.max(leftX, rightX), Math.max(topY, bottomY));

                var tileID = TileCoord.toID(transform.tileZoom, x, y),
                    tile = tiles[tileID],
                    point;

                // segments starts outside the tile, add entry point
                if (0 <= enter && enter < 1) {
                    point = new Point(
                        ((prevCoord.column + enter * dx) - x) * tileExtent,
                        ((prevCoord.row + enter * dy) - y) * tileExtent);

                    point.continues = true;

                    if (!tile) tiles[tileID] = tile = [];
                    tile.push([point]);
                }

                // segments ends outside the tile, add exit point
                if (0 <= exit && exit < 1) {
                    point = new Point(
                        ((prevCoord.column + exit * dx) - x) * tileExtent,
                        ((prevCoord.row + exit * dy) - y) * tileExtent);

                    point.continues = true;

                    tile[tile.length - 1].push(point);

                // add the point itself
                } else {
                    point = new Point(
                        (coord.column - x) * tileExtent,
                        (coord.row - y) * tileExtent);

                    if (!tile) tiles[tileID] = tile = [[point]];
                    else tile[tile.length - 1].push(point);
                }
            }
        }
    }

    if (false && rejoin) {
        // reassemble the disconnected segments into a linestring
        // sections of the linestring outside the tile are replaced with segments
        // that follow the tile's edge
        for (var id in tiles) {

            var segments = tiles[id];

            if (!segments[0][0].continues && segments.length > 1) {
                // if the first segment is the beginning of the linestring
                // then join it with the last so that all segments start and
                // end at tile boundaries
                var last = segments.pop();
                Array.prototype.unshift.apply(segments[0], last.slice(0, last.length - 1));
            }

            var start = edgeDist(segments[0][0], tileExtent, padding);

            for (var k = 0; k < segments.length; k++) {
                // Add all tile corners along the path between the current segment's exit point
                // and the next segment's entry point

                var thisExit = edgeDist(segments[k][segments[k].length - 1], paddedExtent);
                var nextEntry = edgeDist(segments[(k + 1) % segments.length][0], paddedExtent);

                var startToExit = (thisExit - start + 4) % 4;
                var startToNextEntry = (nextEntry - start + 4) % 4;
                var direction = (thisExit === nextEntry || startToExit < startToNextEntry) ? 1 : -1;
                var roundFn = direction > 0 ? Math.ceil : Math.floor;

                for (var c = roundFn(thisExit) % 4; c != roundFn(nextEntry) % 4; c = (c + direction + 4) % 4) {
                    var corner = corners[c];
                    segments[k].push(new Point(
                        (corner.x + (corner.x - 0.5 > 0 ? 1 : -1) * padding) * tileExtent,
                        (corner.y + (corner.y - 0.5 > 0 ? 1 : -1) * padding) * tileExtent));
                }
            }

            // Join all segments
            tiles[id] = [Array.prototype.concat.apply([], segments)];
        }
    }

    return tiles;

}

var corners = [
    new Point(0, 0),
    new Point(1, 0),
    new Point(1, 1),
    new Point(0, 1)];

/*
 * Converts to a point to the distance along the edge of the tile (out of 4).
 *
 *         0.5
 *     0 _______ 1
 *      |       |
 *  3.5 |       | 1.5
 *      |       |
 *      |_______|
 *     3   2.5   2
 */
function edgeDist(point, extent) {
    var x = point.x / extent;
    var y = point.y / extent;
    var d;
    if (Math.abs(y - 0.5) >= Math.abs(x - 0.5)) {
        d = Math.round(y) * 2 + (y < 0.5 ? x : 1 - x);
    } else {
        d = Math.round(1 - x) * 2 + (x > 0.5 ? y : 1 - y) + 1;
    }

    return d % 4;
}

},{"../geo/latlng.js":17,"../geo/transform.js":19,"./tilecoord.js":41,"geojson-rewind":91,"point-geometry":97}],43:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js'),
    TileCoord = require('./tilecoord.js'),
    BufferSet = require('../data/buffer/bufferset.js'),
    util = require('../util/util.js');

var createBucket = require('../data/createbucket.js');

module.exports = VectorTile;

function VectorTile(id, source, url, callback) {
    this.id = id;
    this.loaded = false;
    this.url = url;
    this.zoom = TileCoord.fromID(id).z;
    this.map = source.map;
    this.options = source.options;
    this.id = util.uniqueId();
    this.callback = callback;
    this.source = source;

    if (this.zoom >= source.tileJSON.maxzoom) {
        this.depth = this.map.options.maxZoom - this.zoom;
    } else {
        this.depth = 1;
    }
    this.uses = 1;
    this._load();
}

VectorTile.prototype = util.inherit(Tile, {

    _load: function() {
        var tile = this;
        this.workerID = this.map.dispatcher.send('load tile', {
            url: this.url,
            id: this.id,
            zoom: this.zoom,
            maxZoom: this.source.tileJSON.maxzoom,
            tileSize: this.options.tileSize,
            source: this.source.id,
            depth: this.depth
        }, function(err, data) {
            if (!err && data) {
                tile.onTileLoad(data);
            }
            tile.callback(err);
        });
    },

    onTileLoad: function(data) {

        // Tile has been removed from the map
        if (!this.map) return;

        this.buffers = new BufferSet(data.buffers);

        this.buckets = {};
        for (var b in data.elementGroups) {
            this.buckets[b] = createBucket(this.map.style.buckets[b], this.buffers, undefined, data.elementGroups[b]);
        }

        this.loaded = true;
    },

    remove: function() {

        // reuse prerendered textures
        for (var bucket in this.buckets) {
            if (this.buckets[bucket].prerendered) this.map.painter.saveTexture(this.buckets[bucket].prerendered.texture);
        }

        this.map.dispatcher.send('remove tile', { id: this.id, source: this.source.id }, null, this.workerID);
        this.map.painter.glyphAtlas.removeGlyphs(this.id);

        var gl = this.map.painter.gl;
        var buffers = this.buffers;
        if (buffers) {
            for (var b in buffers) {
                buffers[b].destroy(gl);
            }
        }
        delete this.map;
    },

    abort: function() {
        this.map.dispatcher.send('abort tile', { id: this.id, source: this.source.id }, null, this.workerID);
    }
});

},{"../data/buffer/bufferset.js":2,"../data/createbucket.js":10,"../util/util.js":86,"./tile.js":40,"./tilecoord.js":41}],44:[function(require,module,exports){
'use strict';

var Tile = require('./tile.js');
var TileCoord = require('./tilecoord.js');
var LatLng = require('../geo/latlng.js');
var Point = require('point-geometry');

module.exports = VideoSource;

function VideoSource(options) {

    this.video = document.createElement('video');
    this.video.crossOrigin = 'Anonymous';
    this.video.loop = true;

    var urls = (typeof options.url === 'string') ? [options.url] : options.url;

    for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
        s.src = urls[i];
        this.video.appendChild(s);
    }

    this.coordinates = options.coordinates;
    this.enabled = true;

    var loopID;
    var source = this;

    // start repainting when video starts playing
    this.video.addEventListener('playing', function() {
        loopID = source.map.style.animationLoop.set(Infinity);
        source.map._rerender();
    });

    // stop repainting when video stops
    this.video.addEventListener('pause', function() {
        source.map.style.animationLoop.cancel(loopID);
    });

}

VideoSource.prototype.onAdd = function(map) {
    this.map = map;
    this.video.play();
    this.createTile();
};

VideoSource.prototype.createTile = function() {
    /*
     * Calculate which mercator tile is suitable for rendering the video in
     * and create a buffer with the corner coordinates. These coordinates
     * may be outside the tile, because raster tiles aren't clipped when rendering.
     */
    var map = this.map;
    var coords = this.coordinates.map(function(latlng) {
        var loc = LatLng.convert(latlng);
        return TileCoord.zoomTo(map.transform.locationCoordinate(loc), 0);
    });

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i].column);
        minY = Math.min(minY, coords[i].row);
        maxX = Math.max(maxX, coords[i].column);
        maxY = Math.max(maxY, coords[i].row);
    }

    var dx = maxX - minX;
    var dy = maxY - minY;
    var dMax = Math.max(dx, dy);
    var center = TileCoord.zoomTo({
        column: (minX + maxX) / 2,
        row: (minY + maxY) / 2,
        zoom: 0
    }, Math.floor(-Math.log(dMax) / Math.LN2));

    var tileExtent = 4096;
    var tileCoords = coords.map(function(coord) {
        var zoomedCoord = TileCoord.zoomTo(coord, center.zoom);
        return new Point(
            Math.round((zoomedCoord.column - center.column) * tileExtent),
            Math.round((zoomedCoord.row - center.row) * tileExtent));
    });

    var gl = map.painter.gl;
    var maxInt16 = 32767;
    var array = new Int16Array([
        tileCoords[0].x, tileCoords[0].y, 0, 0,
        tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
        tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
        tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
    ]);
    this.boundsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.boundsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

    this.tile = new Tile();
    this.center = center;
};

VideoSource.prototype.load = function() {
    // noop
};

VideoSource.prototype.update = function() {
    // noop
};

VideoSource.prototype.render = function(layers) {
    if (!this.enabled) return;
    if (this.video.readyState < 2) return; // not enough data for current position

    var layer = layers[0];

    var bucket = {
        type: 'raster',
        tile: this,
        boundsBuffer: this.boundsBuffer,
        bind: this.bind.bind(this)
    };

    var buckets = {};
    buckets[layer.bucket] = bucket;

    var c = this.center;
    this.tile.calculateMatrices(c.zoom, c.column, c.row, this.map.transform, this.map.painter);
    this.map.painter.tile = this.tile;
    this.map.painter.applyStyle(layer, this.map.style, buckets, {});
};

VideoSource.prototype.bind = function(gl) {

    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
    }

};


VideoSource.prototype.featuresAt = function(point, params, callback) {
    // TODO return pixel?
    return callback(null, []);
};

},{"../geo/latlng.js":17,"./tile.js":40,"./tilecoord.js":41,"point-geometry":97}],45:[function(require,module,exports){
'use strict';

var Actor = require('../util/actor.js'),
    bucketFilter = require('../style/bucketfilter.js'),
    WorkerTile = require('./workertile.js'),
    tileGeoJSON = require('./tilegeojson.js'),
    Wrapper = require('./geojsonwrapper.js'),
    util = require('../util/util.js'),
    queue = require('queue-async'),
    ajax = require('../util/ajax.js');

module.exports = Worker;

function Worker(self) {
    this.self = self;
    this.actor = new Actor(self, this);
}

util.extend(Worker.prototype, {
    alert: function() {
        this.self.postMessage({
            type: 'alert message',
            data: [].slice.call(arguments)
        });
    },

    // Updates the style to use for this map.
    'set buckets': function(data) {
        var buckets = WorkerTile.buckets = data;
        for (var i = 0; i < buckets.length; i++) {
            var bucket = buckets[i];
            bucket.compare = bucketFilter(bucket.filter);
        }
    },

    'set glyphs': function(data) {
        WorkerTile.prototype.glyphs = data;
    },

    /*
     * Load and parse a tile at `url`, and call `callback` with
     * (err, response)
     *
     * @param {string} url
     * @param {function} callback
     */
    'load tile': function(params, callback) {
        new WorkerTile(params.url, undefined, params.id, params.zoom, params.maxZoom, params.tileSize, params.source, params.depth, this.actor, callback);
    },

    /*
     * Abort the request keyed under `url`
     *
     * @param {string} url
     */
    'abort tile': function(params) {
        WorkerTile.cancel(params.id, params.source);
    },

    'remove tile': function(params) {
        var id = params.id;
        var source = params.source;
        if (WorkerTile.loaded[source] && WorkerTile.loaded[source][id]) {
            delete WorkerTile.loaded[source][id];
        }
    },

    'parse geojson': function(params, callback) {
        var data = params.data,
            zooms = params.zooms,
            len = zooms.length,
            maxZoom = zooms[len - 1],
            actor = this.actor,
            q = queue();

        function worker(id, tile, zoom, callback) {
            new WorkerTile(undefined, new Wrapper(tile), id, zoom, maxZoom, params.tileSize, params.source, 4, actor, function(err, data) {
                if (err) return callback(err);
                data.id = id;
                callback(null, data);
            });
        }

        function tileData(err, data) {
            if (err) throw err;
            for (var i = 0; i < len; i++) {
                var zoom = zooms[i];
                var tiles = tileGeoJSON(data, zoom);
                for (var id in tiles) {
                    q.defer(worker, id, tiles[id], zoom);
                }
            }
            q.awaitAll(callback);
        }

        if (typeof data === 'string') ajax.getJSON(data, tileData);
        else tileData(null, data);
    },

    'query features': function(params, callback) {
        var tile = WorkerTile.loaded[params.source] && WorkerTile.loaded[params.source][params.id];
        if (tile) {
            tile.featureTree.query(params, callback);
        } else {
            callback(null, []);
        }
    }
});

},{"../style/bucketfilter.js":48,"../util/actor.js":74,"../util/ajax.js":75,"../util/util.js":86,"./geojsonwrapper.js":37,"./tilegeojson.js":42,"./workertile.js":46,"queue-async":98}],46:[function(require,module,exports){
'use strict';

var FeatureTree = require('../data/featuretree.js');
var Protobuf = require('pbf');
var vt = require('vector-tile');
var Collision = require('../symbol/collision.js');
var getArrayBuffer = require('../util/ajax.js').getArrayBuffer;

var BufferSet = require('../data/buffer/bufferset.js');
var createBucket = require('../data/createbucket.js');

module.exports = WorkerTile;
function WorkerTile(url, data, id, zoom, maxZoom, tileSize, source, depth, actor, callback) {
    var tile = this;
    this.id = id;
    this.zoom = zoom;
    this.maxZoom = maxZoom;
    this.tileSize = tileSize;
    this.source = source;
    this.depth = depth;
    this.buffers = new BufferSet();

    function loaded(data) {
        console.log("Data loaded:"  + data +" via url: " + url);
        //console.log(JSON.stringify(data));
        //throw new Error(JSON.stringify(data));
        //console.log(JSON.stringify(data, null, 4));
        WorkerTile.loaded[source] = WorkerTile.loaded[source] || {};
        WorkerTile.loaded[source][id] = tile;
        tile.data = data;
        tile.parse(data, actor, callback);
    }

    if (url) {
        if (WorkerTile.loading[source] === undefined) WorkerTile.loading[source] = {};
        WorkerTile.loading[source][id] = getArrayBuffer(url, function(err, data) {
            delete WorkerTile.loading[source][id];
            if (err) {
                callback(err);
            } else {
                loaded(new vt.VectorTile(new Protobuf(new Uint8Array(data))));
            }
        });
    } else {
        loaded(data);
    }
}

WorkerTile.cancel = function(id, sourceID) {
    var source = WorkerTile.loading[sourceID];
    if (source && source[id]) {
        source[id].abort();
        delete source[id];
    }
};

// Stores tiles that are currently loading.
WorkerTile.loading = {};

// Stores tiles that are currently loaded.
WorkerTile.loaded = {};

// Stores the style information.
WorkerTile.buckets = [];

/*
 * Given tile data, parse raw vertices and data, create a vector
 * tile and parse it into ready-to-render vertices.
 *
 * @param {object} data
 * @param {function} respond
 */
WorkerTile.prototype.parse = function(data, actor, callback) {
    var tile = this;
    var bucketInfo = WorkerTile.buckets;
    this.callback = callback;

    var tileExtent = 4096;
    this.collision = new Collision(this.zoom, tileExtent, this.tileSize, this.depth);
    this.featureTree = new FeatureTree(getGeometry, getType);

    var buckets = this.buckets = sortTileIntoBuckets(this, data, bucketInfo);

    var key, bucket;
    var prevPlacementBucket;

    var remaining = WorkerTile.buckets.length;

    /*
     *  The async parsing here is a bit tricky.
     *  Some buckets depend on resources that may need to be loaded async (glyphs).
     *  Some buckets need to be parsed in order (to get placement priorities right).
     *
     *  Dependencies calls are initiated first to get those rolling.
     *  Buckets that don't need to be parsed in order, aren't to save time.
     */

    var orderedBuckets = WorkerTile.buckets;
    for (var i = 0; i < orderedBuckets.length; i++) {
        bucket = buckets[orderedBuckets[i].id];
        if (!bucket) {
            remaining--;
            continue; // raster bucket, etc
        }

        var filter = bucket.info.filter;
        if (filter && filter.source !== this.source) continue;

        // Link buckets that need to be parsed in order
        if (bucket.collision) {
            if (prevPlacementBucket) {
                prevPlacementBucket.next = bucket;
            } else {
                bucket.previousPlaced = true;
            }
            prevPlacementBucket = bucket;
        }

        if (bucket.getDependencies) {
            bucket.getDependencies(this, actor, dependenciesDone(bucket));
        }

    }

    // parse buckets where order doesn't matter and no dependencies
    for (key in buckets) {
        bucket = buckets[key];
        if (!bucket.getDependencies && !bucket.collision) {
            parseBucket(tile, bucket);
        }
    }

    function dependenciesDone(bucket) {
        return function(err) {
            bucket.dependenciesLoaded = true;
            parseBucket(tile, bucket, err);
        };
    }

    function parseBucket(tile, bucket, skip) {
        if (bucket.getDependencies && !bucket.dependenciesLoaded) return;
        if (bucket.collision && !bucket.previousPlaced) return;

        if (!skip) {
            var now = Date.now();
            if (bucket.type !== 'raster') bucket.addFeatures();
            var time = Date.now() - now;
            if (bucket.interactive) {
                for (var i = 0; i < bucket.features.length; i++) {
                    var feature = bucket.features[i];
                    tile.featureTree.insert(feature.bbox(), bucket.name, feature);
                }
            }
            if (typeof self !== 'undefined') {
                self.bucketStats = self.bucketStats || {_total: 0};
                self.bucketStats._total += time;
                self.bucketStats[bucket.name] = (self.bucketStats[bucket.name] || 0) + time;
            }
        }

        remaining--;
        if (!remaining) return tile.done();

        // try parsing the next bucket, if it is ready
        if (bucket.next) {
            bucket.next.previousPlaced = true;
            parseBucket(tile, bucket.next);
        }
    }
};

WorkerTile.prototype.done = function() {
    // Collect all buffers to mark them as transferable object.
    var buffers = [];

    for (var type in this.buffers) {
        buffers.push(this.buffers[type].array);
    }

    // Convert buckets to a transferable format
    var buckets = this.buckets;
    var elementGroups = {};
    for (var b in buckets) elementGroups[b] = buckets[b].elementGroups;

    this.callback(null, {
        elementGroups: elementGroups,
        buffers: this.buffers
    }, buffers);

    // we don't need anything except featureTree at this point, so we mark it for GC
    this.buffers = null;
    this.collision = null;
    this.buckets = null;
};

function sortTileIntoBuckets(tile, data, bucketInfo) {

    var sourceLayers = {},
        buckets = {},
        layerName;

    // For each source layer, find a list of buckets that use data from it
    for (var i = 0; i < bucketInfo.length; i++) {
        var info = bucketInfo[i];
        var bucketName = info.id;

        var minZoom = info['min-zoom'];
        var maxZoom = info['max-zoom'];

        if (info.source !== tile.source) continue;
        if (minZoom && tile.zoom < minZoom && minZoom < tile.maxZoom) continue;
        if (maxZoom && tile.zoom >= maxZoom) continue;

        var bucket = createBucket(info, tile.buffers, tile.collision);
        if (!bucket) continue;
        bucket.features = [];
        bucket.name = bucketName;
        buckets[bucketName] = bucket;

        if (data.layers) {
            // vectortile
            layerName = info['source-layer'];
            if (!sourceLayers[layerName]) sourceLayers[layerName] = {};
            sourceLayers[layerName][bucketName] = info;
        } else {
            // geojson tile
            sourceLayers[bucketName] = info;
        }
    }

    // read each layer, and sort its feature's into buckets
    if (data.layers) {
        // vectortile
        for (layerName in sourceLayers) {
            var layer = data.layers[layerName];
            if (!layer) continue;
            sortLayerIntoBuckets(layer, sourceLayers[layerName], buckets);
        }
    } else {
        // geojson
        sortLayerIntoBuckets(data, sourceLayers, buckets);
    }

    return buckets;
}

/*
 * Sorts features in a layer into different buckets, according to the maping
 *
 * Layers in vector tiles contain many different features, and feature types,
 * e.g. the landuse layer has parks, industrial buildings, forests, playgrounds
 * etc. However, when styling, we need to separate these features so that we can
 * render them separately with different styles.
 *
 * @param {VectorTileLayer} layer
 * @param {Mapping} mapping
 */
function sortLayerIntoBuckets(layer, mapping, buckets) {
    for (var i = 0; i < layer.length; i++) {
        var feature = layer.feature(i);
        for (var key in mapping) {
            if (mapping[key].compare(feature)) {
                buckets[key].features.push(feature);
            }
        }
    }
}

function getGeometry(feature) {
    return feature.loadGeometry();
}

function getType(feature) {
    return vt.VectorTileFeature.types[feature.type];
}

},{"../data/buffer/bufferset.js":2,"../data/createbucket.js":10,"../data/featuretree.js":12,"../symbol/collision.js":58,"../util/ajax.js":75,"pbf":95,"vector-tile":101}],47:[function(require,module,exports){
'use strict';

module.exports = AnimationLoop;

function AnimationLoop() {
    this.n = 0;
    this.times = [];
}

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
    this.times = this.times.filter(function(t) {
        return t.time >= (new Date()).getTime();
    });
    return !this.times.length;
};

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
AnimationLoop.prototype.set = function(t) {
    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
    return this.n++;
};

// Cancel an animation
AnimationLoop.prototype.cancel = function(n) {
    this.times = this.times.filter(function(t) {
        return t.id != n;
    });
};

},{}],48:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('vector-tile').VectorTileFeature;

function infix(operator) {
    return function(left, right) { return left + ' ' + operator + ' ' + right; };
}

var infixOperators = {
    '==': infix('==='),
    '>': infix('>'), '$gt': infix('>'),
    '<': infix('<'), '$lt': infix('<'),
    '<=': infix('<='), '$lte': infix('<='),
    '>=': infix('>='), '$gte': infix('>='),
    '!=': infix('!=='), '$ne': infix('!=='),
    '$exists': function (value) { return value + ' !== undefined'; }
};

function or(items)  { return '(' + items.join(' || ') + ')'; }
function and(items) { return '(' + items.join(' && ') + ')'; }
function not(item)  { return '!' + item; }
function nor(items) { return not(or(items)); }

var arrayOperators = {
    '||': or, '$or': or,
    '&&': and, '$and': and,
    '!': nor, '$nor': nor
};

var objOperators = {
    '!': not, '$not': not
};

module.exports = function (filter) {
    // simple key & value comparison
    function valueFilter(key, value, operator) {
        return operator('p[' + JSON.stringify(key) + ']', JSON.stringify(value));
    }

    // compares key & value or key & or(values)
    function simpleFieldFilter(key, value, operator) {
        var operatorFn = infixOperators[operator || '=='];
        if (!operatorFn) throw new Error('Unknown operator: ' + operator);

        if (Array.isArray(value)) {
            return or(value.map(function (v) {
                return valueFilter(key, v, operatorFn);
            }));

        } else return valueFilter(key, value, operatorFn);
    }

    // handles any filter key/value pair
    function fieldFilter(key, value) {

        if (Array.isArray(value)) {
            if (key in arrayOperators) { // handle and/or operators
                return arrayOperators[key](value.map(fieldsFilter));
            }

        } else if (typeof value === 'object') {

            // handle not operator
            if (key in objOperators) return objOperators[key](fieldsFilter(value));

            // handle {key: {operator: value}} notation
            var filters = [];
            for (var op in value) {
                filters.push(simpleFieldFilter(key, value[op], op));
            }
            return and(filters);

        }
        // handle simple key/value or key/values comparison
        return simpleFieldFilter(key, value);
    }

    function typeFilter(type) {
        return 'f.type === ' + VectorTileFeature.types.indexOf(type);
    }

    function fieldsFilter(obj) {
        var filters = [];

        for (var key in obj) {
            if (key === '$type') {
                filters.push(typeFilter(obj[key]));
            } else {
                filters.push(fieldFilter(key, obj[key]));
            }
        }

        return filters.length ? and(filters) : 'true';
    }

    var filterStr = 'var p = f.properties || {}; return ' + fieldsFilter(filter || {}) + ';';

    // jshint evil: true
    return new Function('f', filterStr);
};

},{"vector-tile":101}],49:[function(require,module,exports){
'use strict';

var reference = require('mapbox-gl-style-spec/reference/v4');

module.exports = {};

reference['class'].forEach(function(className) {
    var Calculated = function() {};
    var style = reference[className];
    for (var prop in style) {
        if (style[prop]['default'] === undefined) continue;
        Calculated.prototype[prop] = style[prop]['default'];
    }
    module.exports[className.replace('class_','')] = Calculated;
});


},{"mapbox-gl-style-spec/reference/v4":94}],50:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented.js');
var ajax = require('../util/ajax.js');
var browser = require('../util/browser.js');

module.exports = ImageSprite;

function ImageSprite(base) {

    var sprite = this;
    this.base = base;
    this.retina = browser.devicePixelRatio > 1;

    base = sprite.base + (sprite.retina ? '@2x' : '');

    ajax.getJSON(base + '.json', function(err, data) {
        // @TODO handle errors via sprite event.
        if (err) return;
        sprite.data = data;
        if (sprite.img) sprite.fire('loaded');
    });

    ajax.getImage(base + '.png', function(err, img) {
        // @TODO handle errors via sprite event.
        if (err) return;

        // premultiply the sprite
        var data = img.getData();
        var newdata = img.data = new Uint8Array(data.length);
        for (var i = 0; i < data.length; i+=4) {
            var alpha = data[i + 3] / 255;
            newdata[i + 0] = data[i + 0] * alpha;
            newdata[i + 1] = data[i + 1] * alpha;
            newdata[i + 2] = data[i + 2] * alpha;
            newdata[i + 3] = data[i + 3];
        }

        sprite.img = img;
        if (sprite.data) sprite.fire('loaded');
    });
}

ImageSprite.prototype = Object.create(Evented);

ImageSprite.prototype.toJSON = function() {
    return this.base;
};

ImageSprite.prototype.loaded = function() {
    return !!(this.data && this.img);
};

ImageSprite.prototype.resize = function(gl) {
    var sprite = this;
    if (browser.devicePixelRatio > 1 !== sprite.retina) {

        var newSprite = new ImageSprite(sprite.base);
        newSprite.on('loaded', function() {

            sprite.img = newSprite.img;
            sprite.data = newSprite.data;
            sprite.retina = newSprite.retina;

            if (sprite.texture) {
                gl.deleteTexture(sprite.texture);
                delete sprite.texture;
            }

        });
    }
};

ImageSprite.prototype.bind = function(gl, linear) {
    var sprite = this;

    if (!sprite.loaded())
        return;

    if (!sprite.texture) {
        sprite.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, sprite.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var img = sprite.img;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, img.width, img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, img.data);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, sprite.texture);
    }

    var filter = linear ? gl.LINEAR : gl.NEAREST;
    if (filter !== sprite.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    }
};

ImageSprite.prototype.getPosition = function(name, repeating) {

    // `repeating` indicates that the image will be used in a repeating pattern
    // repeating pattern images are assumed to have a 1px padding that mirrors the opposite edge
    // positions for repeating images are adjusted to exclude the edge
    repeating = repeating === true ? 1 : 0;

    var pos = this.data && this.data[name];
    if (pos && this.img) {
        var width = this.img.width;
        var height = this.img.height;
        return {
            size: [pos.width / pos.pixelRatio, pos.height / pos.pixelRatio],
            tl: [(pos.x + repeating)/ width, (pos.y + repeating) / height],
            br: [(pos.x + pos.width - 2 * repeating) / width, (pos.y + pos.height - 2 * repeating) / height]
        };
    }
};

},{"../util/ajax.js":75,"../util/browser.js":76,"../util/evented.js":81}],51:[function(require,module,exports){
'use strict';

var reference = require('mapbox-gl-style-spec/reference/v4');

module.exports = {};

reference.render.forEach(function(className) {
    var Properties = function(props) {
        for (var p in props) {
            this[p] = props[p];
        }
    };

    var properties = reference[className];
    for (var prop in properties) {
        if (properties[prop]['default'] === undefined) continue;
        Properties.prototype[prop] = properties[prop]['default'];
    }
    module.exports[className.replace('render_','')] = Properties;
});


},{"mapbox-gl-style-spec/reference/v4":94}],52:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented.js');

var StyleTransition = require('./styletransition.js');
var StyleDeclaration = require('./styledeclaration.js');
var StyleConstant = require('./styleconstant.js');
var CalculatedStyle = require('./calculatedstyle.js');
var ImageSprite = require('./imagesprite.js');

var util = require('../util/util.js');

module.exports = Style;

/*
 * The map style's current state
 *
 * The stylesheet object is not modified. To change the style, just change
 * the the stylesheet object and trigger a cascade.
 */
function Style(stylesheet, animationLoop) {
    if (stylesheet.version !== 4) console.warn('Stylesheet version must be 4');
    if (!Array.isArray(stylesheet.layers)) console.warn('Stylesheet must have layers');

    this.classes = {};
    this.stylesheet = stylesheet;
    this.animationLoop = animationLoop;

    this.buckets = {};
    this.orderedBuckets = [];
    this.transitions = {};
    this.computed = {};
    this.sources = {};

    this.cascade({transition: false});

    if (stylesheet.sprite) this.setSprite(stylesheet.sprite);
}

Style.prototype = Object.create(Evented);

function premultiplyLayer(layer, type) {
    var colorProp = type + '-color',
        haloProp = type + '-halo-color',
        outlineProp = type + '-outline-color',
        color = layer[colorProp],
        haloColor = layer[haloProp],
        outlineColor = layer[outlineProp],
        opacity = layer[type + '-opacity'];

    var colorOpacity = color && (opacity * color[3]);
    var haloOpacity = haloColor && (opacity * haloColor[3]);
    var outlineOpacity = outlineColor && (opacity * outlineColor[3]);

    if (colorOpacity !== undefined && colorOpacity < 1) {
        layer[colorProp] = util.premultiply([color[0], color[1], color[2], colorOpacity]);
    }
    if (haloOpacity !== undefined && haloOpacity < 1) {
        layer[haloProp] = util.premultiply([haloColor[0], haloColor[1], haloColor[2], haloOpacity]);
    }
    if (outlineOpacity !== undefined && outlineOpacity < 1) {
        layer[outlineProp] = util.premultiply([outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity]);
    }
}

// Formerly known as zoomed styles
Style.prototype.recalculate = function(z) {
    if (typeof z !== 'number') console.warn('recalculate expects zoom level');

    var transitions = this.transitions;
    var layerValues = {};

    this.sources = {};

    this.rasterFadeDuration = 300;

    for (var name in transitions) {
        var layer = transitions[name],
            bucket = this.buckets[layer.ref || name],
            layerType = this.layermap[name].type;

        if (!CalculatedStyle[layerType]) {
            console.warn('unknown layer type ' + layerType);
            continue;
        }
        var appliedLayer = layerValues[name] = new CalculatedStyle[layerType]();
        for (var rule in layer) {
            var transition = layer[rule];
            appliedLayer[rule] = transition.at(z);
        }

        if (layerType === 'symbol') {
            appliedLayer.hidden =
                (appliedLayer['text-opacity'] === 0 || !bucket.render['text-field']) &&
                (appliedLayer['icon-opacity'] === 0 || !bucket.render['icon-image']);
            if (!appliedLayer.hidden) {
                premultiplyLayer(appliedLayer, 'text');
                premultiplyLayer(appliedLayer, 'icon');
            }
        } else {
            appliedLayer.hidden = (appliedLayer[layerType + '-opacity'] === 0);
            if (!appliedLayer.hidden) {
                premultiplyLayer(appliedLayer, layerType);
            }
        }

        // Find all the sources that are currently being used
        // so that we can automatically enable/disable them as needed
        if (!appliedLayer.hidden) {
            var source = bucket && bucket.source;

            // mark source as used so that tiles are downloaded
            if (source) this.sources[source] = true;
        }

        if (appliedLayer['raster-fade']) {
            this.rasterFadeDuration = Math.max(this.rasterFadeDuration, appliedLayer['raster-fade']);
        }
    }

    this.computed = layerValues;

    this.z = z;
    this.fire('zoom');
};

Style.prototype._simpleLayer = function(layer) {
    var simple = {};
    simple.id = layer.id;

    var bucket = this.buckets[layer.ref || layer.id];
    if (bucket) simple.bucket = bucket.id;
    if (layer.type) simple.type = layer.type;

    if (layer.layers) {
        simple.layers = [];
        for (var i = 0; i < layer.layers.length; i++) {
            simple.layers.push(this._simpleLayer(layer.layers[i]));
        }
    }
    return simple;
};

// Split the layers into groups of consecutive layers with the same datasource
Style.prototype._groupLayers = function(layers) {
    var g = 0;
    var groups = [];
    var group;

    // loop over layers top down
    for (var i = layers.length - 1; i >= 0; i--) {
        var layer = layers[i];

        var bucket = this.buckets[layer.ref || layer.id];
        var source = bucket && bucket.source;

        // if the current layer is in a different source
        if (group && source !== group.source) g++;

        if (!groups[g]) {
            group = [];
            group.source = source;
            groups[g] = group;
        }

        group.push(this._simpleLayer(layer));
    }

    return groups;
};

/*
 * Take all the rules and declarations from the stylesheet,
 * and figure out which apply currently
 */
Style.prototype.cascade = function(options) {
    options = options || {
        transition: true
    };

    var a, b;
    var id;
    var prop;
    var layer;
    var className;
    var styleName;
    var style;
    var styleTrans;
    var constants = this.stylesheet.constants;

    // derive buckets from layers
    this.orderedBuckets = [];
    this.buckets = getbuckets({}, this.orderedBuckets, this.stylesheet.layers);
    function getbuckets(buckets, ordered, layers) {
        for (var a = 0; a < layers.length; a++) {
            var layer = layers[a];
            if (layer.layers) {
                buckets = getbuckets(buckets, ordered, layer.layers);
            }
            if (!layer.source || !layer.type) {
                continue;
            }
            var bucket = { id: layer.id };
            for (var prop in layer) {
                if ((/^style/).test(prop)) continue;
                bucket[prop] = layer[prop];
            }
            bucket.render = StyleConstant.resolve(bucket.render, constants);
            buckets[layer.id] = bucket;
            ordered.push(bucket);
        }
        return buckets;
    }

    // style class keys
    var styleNames = ['style'];
    for (className in this.classes) styleNames.push('style.' + className);

    // apply layer group inheritance resulting in a flattened array
    var flattened = flattenLayers(this.stylesheet.layers);

    // map layer ids to layer definitions for resolving refs
    var layermap = this.layermap = {};
    for (a = 0; a < flattened.length; a++) {
        layer = flattened[a];

        var newLayer = {};
        for (var k in layer) {
            if (k === 'layers') continue;
            newLayer[k] = layer[k];
        }

        layermap[layer.id] = newLayer;
        flattened[a] = newLayer;
    }

    for (a = 0; a < flattened.length; a++) {
        flattened[a] = resolveLayer(layermap, flattened[a]);
    }

    // Resolve layer references.
    function resolveLayer(layermap, layer) {
        if (!layer.ref || !layermap[layer.ref]) return layer;

        var parent = resolveLayer(layermap, layermap[layer.ref]);
        layer.render = parent.render;
        layer.type = parent.type;
        layer.filter = parent.filter;
        layer.source = parent.source;
        layer['source-layer'] = parent['source-layer'];
        layer['min-zoom'] = parent['min-zoom'];
        layer['max-zoom'] = parent['max-zoom'];

        return layer;
    }

    // Flatten composite layer structures.
    function flattenLayers(layers) {
        var flat = [];
        for (var i = 0; i < layers.length; i++) {
            flat.push(layers[i]);
            if (layers[i].layers) {
                flat.push.apply(flat, flattenLayers(layers[i].layers));
            }
        }
        return flat;
    }

    var transitions = {};
    var globalTrans = this.stylesheet.transition;

    for (a in flattened) {
        layer = flattened[a];

        id = layer.id;
        style = {};
        styleTrans = {};

        // basic cascading of styles
        for (b = 0; b < styleNames.length; b++) {
            styleName = styleNames[b];
            if (!layer[styleName]) continue;
            // set style properties
            for (prop in layer[styleName]) {
                if (prop.indexOf('transition-') === -1) {
                    style[prop] = layer[styleName][prop];
                } else {
                    styleTrans[prop.replace('transition-', '')] = layer[styleName][prop];
                }
            }
        }

        style = StyleConstant.resolve(style, constants);

        var renderType = layer.type;
        transitions[id] = {};

        for (prop in style) {
            var newDeclaration = new StyleDeclaration(renderType, prop, style[prop]);
            var oldTransition = this.transitions[id] && this.transitions[id][prop];
            var newStyleTrans = {};
            newStyleTrans.duration = styleTrans[prop] && styleTrans[prop].duration ? styleTrans[prop].duration : globalTrans && globalTrans.duration ? globalTrans.duration : 300;
            newStyleTrans.delay = styleTrans[prop] && styleTrans[prop].delay ? styleTrans[prop].delay : globalTrans && globalTrans.delay ? globalTrans.delay : 0;

            if (!options.transition) {
                newStyleTrans.duration = 0;
                newStyleTrans.delay = 0;
            }

            // Only create a new transition if the declaration changed
            if (!oldTransition || oldTransition.declaration.json !== newDeclaration.json) {
                var newTransition = new StyleTransition(newDeclaration, oldTransition, newStyleTrans);
                transitions[id][prop] = newTransition;

                // Run the animation loop until the end of the transition
                if (!newTransition.instant()) {
                    newTransition.loopID = this.animationLoop.set(newTransition.endTime - (new Date()).getTime());
                }

                if (oldTransition) {
                    this.animationLoop.cancel(oldTransition.loopID);
                }
            } else {
                transitions[id][prop] = oldTransition;
            }
        }
    }

    this.transitions = transitions;
    this.layerGroups = this._groupLayers(this.stylesheet.layers);

    this.fire('change');
};

/* This should be moved elsewhere. Localizing resources doesn't belong here */
Style.prototype.setSprite = function(sprite) {
    this.sprite = new ImageSprite(sprite);
    this.sprite.on('loaded', this.fire.bind(this, 'change'));
};

Style.prototype.addClasses = function(n, options) {
    var needsUpdate = false;
    for (var i = 0, c; c = n[i]; i++) {
        if (!this.classes[c]) needsUpdate = true; // prevent unnecessary recalculation

        //console.log("Adding class: "+ c);
        this.classes[c] = true;
    }
    if (needsUpdate) {
        this.cascade(options);
    }
};

// Modify classes
Style.prototype.addClass = function(n, options) {
    if (this.classes[n]) return; // prevent unnecessary recalculation
    this.classes[n] = true;
    this.cascade(options);
};

Style.prototype.removeClass = function(n, options) {
    if (!this.classes[n]) return; // prevent unnecessary recalculation
    delete this.classes[n];
    this.cascade(options);
};

Style.prototype.removeClasses = function(n, options) {
    var needsUpdate = false;
    for (var i = 0, c; c = n[i]; i++) {
        if (this.classes[c]) needsUpdate = true; // // prevent unnecessary recalculation

        //console.log("Removing class: "+ c);
        delete this.classes[c];
    }
    if (needsUpdate) {
        this.cascade(options);
    }
};

Style.prototype.hasClass = function(n) {
    return !!this.classes[n];
};

Style.prototype.setClassList = function(l, options) {
    this.classes = {};
    for (var i = 0; i < l.length; i++) {
        this.classes[l[i]] = true;
    }
    this.cascade(options);
};

Style.prototype.getClassList = function() {
    return Object.keys(this.classes);
};

Style.prototype.getLayer = function(id) {
    return this.layermap[id];
};

},{"../util/evented.js":81,"../util/util.js":86,"./calculatedstyle.js":49,"./imagesprite.js":50,"./styleconstant.js":53,"./styledeclaration.js":54,"./styletransition.js":55}],53:[function(require,module,exports){
'use strict';

var util = require('../util/util.js');

module.exports.resolve = function (properties, constants) {
    if (!constants)
        return properties;

    var result = {}, i;

    function resolve(value) {
        return typeof value === 'string' && value[0] === '@' ? constants[value] : value;
    }

    for (var key in properties) {
        var value = resolve(properties[key]);

        if (Array.isArray(value)) {
            value = value.slice();

            for (i = 0; i < value.length; i++) {
                if (value[i] in constants) {
                    value[i] = resolve(value[i]);
                }
            }
        }

        if (value.stops) {
            value = util.extend({}, value);
            value.stops = value.stops.slice();

            for (i = 0; i < value.stops.length; i++) {
                if (value.stops[i][1] in constants) {
                    value.stops[i] = [
                                value.stops[i][0],
                        resolve(value.stops[i][1])
                    ];
                }
            }
        }

        result[key] = value;
    }

    return result;
};

},{"../util/util.js":86}],54:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    reference = require('mapbox-gl-style-spec/reference/v4'),
    parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = StyleDeclaration;

/*
 * A parsed representation of a property:value pair
 */
function StyleDeclaration(renderType, prop, value) {
    var className = 'class_' + renderType;
    var propReference = reference[className] && reference[className][prop];
    if (!propReference) return;

    this.value = this.parseValue(value, propReference.type, propReference.values);
    this.prop = prop;
    this.type = propReference.type;

    // immuatable representation of value. used for comparison
    this.json = JSON.stringify(value);

}

StyleDeclaration.prototype.calculate = function(z) {
    return typeof this.value === 'function' ? this.value(z) : this.value;
};

StyleDeclaration.prototype.parseValue = function(value, type, values) {
    if (type === 'color') {
        return parseColor(value);
    } else if (type === 'number') {
        return parseNumber(value);
    } else if (type === 'boolean') {
        return Boolean(value);
    } else if (type === 'image') {
        return String(value);
    } else if (type === 'string') {
        return String(value);
    } else if (type === 'array') {
        return parseNumberArray(value);
    } else if (type === 'enum' && Array.isArray(values)) {
        return values.indexOf(value) >= 0 ? value : undefined;
    } else {
        console.warn(type + ' is not a supported property type');
    }
};

function parseNumber(num) {
    if (num.stops) num = stopsFn(num);
    var value = +num;
    return !isNaN(value) ? value : num;
}

function parseNumberArray(array) {
    var widths = array.map(parseNumber);

    return function(z) {
        var result = [];
        for (var i = 0; i < widths.length; i++) {
            result.push(typeof widths[i] === 'function' ? widths[i](z) : widths[i]);
        }
        return result;
    };
}

var colorCache = {};

function parseColor(value) {
    if (value.stops) {
        for (var i = 0; i < value.stops.length; i++) {
            // store the parsed color as the 3rd element in the array
            value.stops[i][2] = parseCSSColor(value.stops[i][1]);
        }
        return stopsFn(value, true);
    }

    if (colorCache[value]) {
        return colorCache[value];
    }
    var color = prepareColor(parseCSSColor(value));
    colorCache[value] = color;
    return color;
}

function stopsFn(params, color) {
    var stops = params.stops;
    var base = params.base || reference.function.base.default;

    return function(z) {

        // find the two stops which the current z is between
        var low = null;
        var high = null;
        for (var i = 0; i < stops.length; i++) {
            var stop = stops[i];
            if (stop[0] <= z) low = stop;
            if (stop[0] > z) {
                high = stop;
                break;
            }
        }

        if (low && high) {
            var zoomDiff = high[0] - low[0];
            var zoomProgress = z - low[0];
            var t = 0;
            if (base == 1) {
                t = zoomProgress / zoomDiff;
            } else {
                t = (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);
            }
            if (color) return prepareColor(interpColor(low[2], high[2], t));
            else return util.interp(low[1], high[1], t);

        } else if (low) {
            if (color) return prepareColor(low[2]);
            else return low[1];

        } else if (high) {
            if (color) return prepareColor(high[2]);
            else return high[1];

        } else {
            if (color) return [0, 0, 0, 1];
            else return 1;
        }
    };
}

function prepareColor(c) {
    return [c[0] / 255, c[1] / 255, c[2] / 255, c[3] / 1];
}

function interpColor(from, to, t) {
    return [
        util.interp(from[0], to[0], t),
        util.interp(from[1], to[1], t),
        util.interp(from[2], to[2], t),
        util.interp(from[3], to[3], t)
    ];
}

},{"../util/util.js":86,"csscolorparser":90,"mapbox-gl-style-spec/reference/v4":94}],55:[function(require,module,exports){
'use strict';

var util = require('../util/util.js');

module.exports = StyleTransition;

/*
 * Represents a transition between two declarations
 */
function StyleTransition(declaration, oldTransition, value) {

    this.declaration = declaration;
    this.startTime = this.endTime = (new Date()).getTime();

    var type = declaration.type;
    if (type === 'number') {
        this.interp = util.interp;
    } else if (type === 'color') {
        this.interp = interpColor;
    } else if (type === 'array') {
        this.interp = interpNumberArray;
    }

    this.oldTransition = oldTransition;
    this.duration = value.duration || 0;
    this.delay = value.delay || 0;

    if (!this.instant()) {
        this.endTime = this.startTime + this.duration + this.delay;
        this.ease = util.easeCubicInOut;
    }

    if (oldTransition && oldTransition.endTime <= this.startTime) {
        // Old transition is done running, so we can
        // delete its reference to its old transition.

        delete oldTransition.oldTransition;
    }
}

StyleTransition.prototype.instant = function() {
    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
};

/*
 * Return the value of the transitioning property at zoom level `z` and optional time `t`
 */
StyleTransition.prototype.at = function(z, t) {

    var value = this.declaration.calculate(z);

    if (this.instant()) return value;

    t = t || Date.now();

    if (t < this.endTime) {
        var oldValue = this.oldTransition.at(z, this.startTime);
        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
        value = this.interp(oldValue, value, eased);
    }

    return value;

};

function interpNumberArray(from, to, t) {
    return from.map(function(d, i) {
        return util.interp(d, to[i], t);
    });
}

function interpColor(from, to, t) {
    return [
        util.interp(from[0], to[0], t),
        util.interp(from[1], to[1], t),
        util.interp(from[2], to[2], t),
        util.interp(from[3], to[3], t)
    ];
}

},{"../util/util.js":86}],56:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = Anchor;

function Anchor(x, y, angle, scale, segment) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.scale = scale;

    if (segment !== undefined) {
        this.segment = segment;
    }
}

Anchor.prototype = Object.create(Point.prototype);

Anchor.prototype.clone = function() {
    return new Anchor(this.x, this.y, this.angle, this.scale, this.segment);
};

},{"point-geometry":97}],57:[function(require,module,exports){
'use strict';

module.exports = BinPack;
function BinPack(width, height) {
    this.width = width;
    this.height = height;
    this.free = [{ x: 0, y: 0, w: width, h: height }];
}

BinPack.prototype.release = function(rect) {
    // Simple algorithm to recursively merge the newly released cell with its
    // neighbor. This doesn't merge more than two cells at a time, and fails
    // for complicated merges.
    for (var i = 0; i < this.free.length; i++) {
        var free = this.free[i];
        if (free.y == rect.y && free.h == rect.h && free.x + free.w == rect.x) {
            free.w += rect.w;
        }
        else if (free.x == rect.x && free.w == rect.w && free.y + free.h == rect.y) {
            free.h += rect.h;
        }
        else if (rect.y == free.y && rect.h == free.h && rect.x + rect.w == free.x) {
            free.x = rect.x;
            free.w += rect.w;
        }
        else if (rect.x == free.x && rect.w == free.w && rect.y + rect.h == free.y) {
            free.y = rect.y;
            free.h += rect.h;
        } else {
            continue;
        }

        this.free.splice(i, 1);
        this.release(free);
        return;

    }
    this.free.push(rect);
};

BinPack.prototype.allocate = function(width, height) {
    // Find the smallest free rect angle
    var rect = { x: Infinity, y: Infinity, w: Infinity, h: Infinity };
    var smallest = -1;
    for (var i = 0; i < this.free.length; i++) {
        var ref = this.free[i];
        if (width <= ref.w && height <= ref.h && ref.y <= rect.y && ref.x <= rect.x) {
            rect = ref;
            smallest = i;
        }
    }

    if (smallest < 0) {
        // There's no space left for this char.
        return { x: -1, y: -1 };
    } else {
        this.free.splice(smallest, 1);

        // Shorter/Longer Axis Split Rule (SAS)
        // http://clb.demon.fi/files/RectangleBinPack.pdf p. 15
        // Ignore the dimension of R and just split long the shorter dimension
        // See Also: http://www.cs.princeton.edu/~chazelle/pubs/blbinpacking.pdf
        if (rect.w < rect.h) {
            // split horizontally
            // +--+---+
            // |__|___|  <-- b1
            // +------+  <-- b2
            if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: height });
            if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: rect.w, h: rect.h - height });
        } else {
            // split vertically
            // +--+---+
            // |__|   | <-- b1
            // +--|---+ <-- b2
            if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: rect.h });
            if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: width, h: rect.h - height });
        }

        return { x: rect.x, y: rect.y, w: width, h: height };
    }
};

},{}],58:[function(require,module,exports){
'use strict';

var rbush = require('rbush'),
    rotationRange = require('./rotationrange.js'),
    Point = require('point-geometry');

module.exports = Collision;

function Collision(zoom, tileExtent, tileSize, placementDepth) {
    this.hTree = rbush(); // tree for horizontal labels
    this.cTree = rbush(); // tree for glyphs from curved labels

    // tile pixels per screen pixels at the tile's zoom level
    this.tilePixelRatio = tileExtent / tileSize;

    this.zoom = zoom;

    // Calculate the maximum scale we can go down in our fake-3d rtree so that
    // placement still makes sense. This is calculated so that the minimum
    // placement zoom can be at most 25.5 (we use an unsigned integer x10 to
    // store the minimum zoom).
    //
    // We don't want to place labels all the way to 25.5. This lets too many
    // glyphs be placed, slowing down collision checking. Only place labels if
    // they will show up within the intended zoom range of the tile.
    placementDepth = Math.min(3, placementDepth || 1, 25.5 - this.zoom);
    this.maxPlacementScale = Math.exp(Math.LN2 * placementDepth);

    var m = 4096;
    var edge = m * this.tilePixelRatio * 2;

    var fullRange = [Math.PI * 2, 0];

    this.left = {
        anchor: new Point(0, 0),
        box: { x1: -edge, y1: -edge, x2: 0, y2: edge },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

    this.top = {
        anchor: new Point(0, 0),
        box: { x1: -edge, y1: -edge, x2: edge, y2: 0 },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

    this.bottom = {
        anchor: new Point(m, m),
        box: { x1: -edge, y1: 0, x2: edge, y2: edge },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

    this.right = {
        anchor: new Point(m, m),
        box: { x1: 0, y1: -edge, x2: edge, y2: edge },
        placementRange: fullRange,
        placementScale: 0.5,
        maxScale: Infinity,
        padding: 0
    };

}

Collision.prototype.getPlacementScale = function(glyphs, minPlacementScale, avoidEdges) {

    var left = this.left;
    var right = this.right;
    var top = this.top;
    var bottom = this.bottom;

    for (var k = 0; k < glyphs.length; k++) {

        var glyph = glyphs[k];
        var box = glyph.box;
        var bbox = glyph.hBox || box;
        var anchor = glyph.anchor;
        var pad = glyph.padding;

        var minScale = Math.max(minPlacementScale, glyph.minScale);
        var maxScale = glyph.maxScale || Infinity;

        if (minScale >= maxScale) continue;

        // Compute the scaled bounding box of the unrotated glyph
        var searchBox = this.getBox(anchor, bbox, minScale, maxScale);

        var blocking = this.hTree.search(searchBox).concat(this.cTree.search(searchBox));

        if (avoidEdges) {
            if (searchBox[0] < 0) blocking.push(left);
            if (searchBox[1] < 0) blocking.push(top);
            if (searchBox[2] >= 4096) blocking.push(right);
            if (searchBox[3] >= 4096) blocking.push(bottom);
        }

        if (blocking.length) {

            var na = anchor; // new anchor
            var nb = box; // new box

            for (var l = 0; l < blocking.length; l++) {
                var oa = blocking[l].anchor; // old anchor
                var ob = blocking[l].box; // old box

                // If anchors are identical, we're going to skip the label.
                // NOTE: this isn't right because there can be glyphs with
                // the same anchor but differing box offsets.
                if (na.equals(oa)) {
                    return null;
                }

                // todo: unhardcode the 8 = tileExtent/tileSize
                var padding = Math.max(pad, blocking[l].padding) * 8;

                // Original algorithm:
                var s1 = (ob.x1 - nb.x2 - padding) / (na.x - oa.x); // scale at which new box is to the left of old box
                var s2 = (ob.x2 - nb.x1 + padding) / (na.x - oa.x); // scale at which new box is to the right of old box
                var s3 = (ob.y1 - nb.y2 - padding) / (na.y - oa.y); // scale at which new box is to the top of old box
                var s4 = (ob.y2 - nb.y1 + padding) / (na.y - oa.y); // scale at which new box is to the bottom of old box

                if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
                if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

                var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));

                // Only update label's min scale if the glyph was restricted by a collision
                if (collisionFreeScale > minPlacementScale &&
                    collisionFreeScale > minScale &&
                    collisionFreeScale < maxScale &&
                    collisionFreeScale < blocking[l].maxScale) {
                    minPlacementScale = collisionFreeScale;
                }

                if (minPlacementScale > this.maxPlacementScale) {
                    return null;
                }
            }

        }
    }

    return minPlacementScale;
};

Collision.prototype.getPlacementRange = function(glyphs, placementScale, horizontal) {

    var placementRange = [2*Math.PI, 0];

    for (var k = 0; k < glyphs.length; k++) {
        var glyph = glyphs[k];
        var bbox = glyph.hBox || glyph.box;
        var anchor = glyph.anchor;

        var minPlacedX = anchor.x + bbox.x1 / placementScale;
        var minPlacedY = anchor.y + bbox.y1 / placementScale;
        var maxPlacedX = anchor.x + bbox.x2 / placementScale;
        var maxPlacedY = anchor.y + bbox.y2 / placementScale;

        var searchBox = [minPlacedX, minPlacedY, maxPlacedX, maxPlacedY];

        var blocking = this.hTree.search(searchBox);

        if (horizontal) {
            blocking = blocking.concat(this.cTree.search(searchBox));
        }

        for (var l = 0; l < blocking.length; l++) {
            var b = blocking[l];
            var bbox2 = b.hBox || b.box;

            var x1, x2, y1, y2, intersectX, intersectY;

            // Adjust and compare bboxes to see if the glyphs might intersect
            if (placementScale > b.placementScale) {
                x1 = b.anchor.x + bbox2.x1 / placementScale;
                y1 = b.anchor.y + bbox2.y1 / placementScale;
                x2 = b.anchor.x + bbox2.x2 / placementScale;
                y2 = b.anchor.y + bbox2.y2 / placementScale;
                intersectX = x1 < maxPlacedX && x2 > minPlacedX;
                intersectY = y1 < maxPlacedY && y2 > minPlacedY;
            } else {
                x1 = anchor.x + bbox.x1 / b.placementScale;
                y1 = anchor.y + bbox.y1 / b.placementScale;
                x2 = anchor.x + bbox.x2 / b.placementScale;
                y2 = anchor.y + bbox.y2 / b.placementScale;
                intersectX = x1 < b[2] && x2 > b[0];
                intersectY = y1 < b[3] && y2 > b[1];
            }

            // If they can't intersect, skip more expensive rotation calculation
            if (!(intersectX && intersectY)) continue;

            var scale = Math.max(placementScale, b.placementScale);
            var range = rotationRange.rotationRange(glyph, b, scale);

            placementRange[0] = Math.min(placementRange[0], range[0]);
            placementRange[1] = Math.max(placementRange[1], range[1]);
        }
    }

    return placementRange;

};

// Insert glyph placements into rtree.
Collision.prototype.insert = function(glyphs, anchor, placementScale, placementRange, horizontal) {

    var allBounds = [];

    for (var k = 0; k < glyphs.length; k++) {

        var glyph = glyphs[k];
        var bbox = glyph.hBox || glyph.box;

        var minScale = Math.max(placementScale, glyph.minScale);
        var maxScale = glyph.maxScale || Infinity;

        var bounds = this.getBox(anchor, bbox, minScale, maxScale);

        bounds.anchor = anchor;
        bounds.box = glyph.box;
        if (glyph.hBox) bounds.hBox = bbox;
        bounds.placementRange = placementRange;
        bounds.placementScale = minScale;
        bounds.maxScale = maxScale;
        bounds.padding = glyph.padding;

        allBounds.push(bounds);
    }

    (horizontal ? this.hTree : this.cTree).load(allBounds);
};

Collision.prototype.getBox = function(anchor, bbox, minScale, maxScale) {
    return [
        anchor.x + Math.min(bbox.x1 / minScale, bbox.x1 / maxScale),
        anchor.y + Math.min(bbox.y1 / minScale, bbox.y1 / maxScale),
        anchor.x + Math.max(bbox.x2 / minScale, bbox.x2 / maxScale),
        anchor.y + Math.max(bbox.y2 / minScale, bbox.y2 / maxScale)];
};

},{"./rotationrange.js":64,"point-geometry":97,"rbush":99}],59:[function(require,module,exports){
'use strict';

var BinPack = require('./binpack.js');

module.exports = GlyphAtlas;
function GlyphAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new BinPack(width, height);
    this.index = {};
    this.ids = {};
    this.data = new Uint8Array(width * height);
}

GlyphAtlas.prototype = {
    get debug() {
        return 'canvas' in this;
    },
    set debug(value) {
        if (value && !this.canvas) {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            document.body.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
        } else if (!value && this.canvas) {
            this.canvas.parentNode.removeChild(this.canvas);
            delete this.ctx;
            delete this.canvas;
        }
    }
};

GlyphAtlas.prototype.getGlyphs = function() {
    var glyphs = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!glyphs[name]) glyphs[name] = [];
        glyphs[name].push(id);
    }

    return glyphs;
};

GlyphAtlas.prototype.getRects = function() {
    var rects = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!rects[name]) rects[name] = {};
        rects[name][id] = this.index[key];
    }

    return rects;
};

GlyphAtlas.prototype.removeGlyphs = function(id) {
    for (var key in this.ids) {

        var ids = this.ids[key];

        var pos = ids.indexOf(id);
        if (pos >= 0) ids.splice(pos, 1);
        this.ids[key] = ids;

        if (!ids.length) {
            var rect = this.index[key];

            var target = this.data;
            for (var y = 0; y < rect.h; y++) {
                var y1 = this.width * (rect.y + y) + rect.x;
                for (var x = 0; x < rect.w; x++) {
                    target[y1 + x] = 0;
                }
            }

            this.dirty = true;

            this.bin.release(rect);

            delete this.index[key];
            delete this.ids[key];
        }
    }


    this.updateTexture(this.gl);
};

GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
    if (!glyph) {
        // console.warn('missing glyph', code, String.fromCharCode(code));
        return null;
    }
    var key = name + "#" + glyph.id;

    // The glyph is already in this texture.
    if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
            this.ids[key].push(id);
        }
        return this.index[key];
    }

    // The glyph bitmap has zero width.
    if (!glyph.bitmap) {
        return null;
    }

    var buffered_width = glyph.width + buffer * 2;
    var buffered_height = glyph.height + buffer * 2;

    // Add a 1px border around every image.
    var pack_width = buffered_width;
    var pack_height = buffered_height;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    pack_width += (4 - pack_width % 4);
    pack_height += (4 - pack_height % 4);

    var rect = this.bin.allocate(pack_width, pack_height);
    if (rect.x < 0) {
        console.warn('glyph bitmap overflow');
        return { glyph: glyph, rect: null };
    }

    // Add left and top glyph offsets to rect.
    rect.l = glyph.left;
    rect.t = glyph.top;

    this.index[key] = rect;
    this.ids[key] = [id];

    var target = this.data;
    var source = glyph.bitmap;
    for (var y = 0; y < buffered_height; y++) {
        var y1 = this.width * (rect.y + y) + rect.x;
        var y2 = buffered_width * y;
        for (var x = 0; x < buffered_width; x++) {
            target[y1 + x] = source[y2 + x];
        }
    }

    this.dirty = true;

    return rect;
};

GlyphAtlas.prototype.bind = function(gl) {
    this.gl = gl;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

GlyphAtlas.prototype.updateTexture = function(gl) {
    this.bind(gl);
    if (this.dirty) {

        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);

        // DEBUG
        if (this.ctx) {
            var data = this.ctx.getImageData(0, 0, this.width, this.height);
            for (var i = 0, j = 0; i < this.data.length; i++, j += 4) {
                data.data[j] = this.data[i];
                data.data[j+1] = this.data[i];
                data.data[j+2] = this.data[i];
                data.data[j+3] = 255;
            }
            this.ctx.putImageData(data, 0, 0);

            this.ctx.strokeStyle = 'red';
            for (var k = 0; k < this.bin.free.length; k++) {
                var free = this.bin.free[k];
                this.ctx.strokeRect(free.x, free.y, free.w, free.h);
            }
        }
        // END DEBUG

        this.dirty = false;
    }
};

},{"./binpack.js":57}],60:[function(require,module,exports){
'use strict';

var getArrayBuffer = require('../util/ajax.js').getArrayBuffer;
var Glyphs = require('../util/glyphs.js');
var Protobuf = require('pbf');

module.exports = GlyphSource;

function GlyphSource(url, glyphAtlas) {
    this.url = url;
    this.glyphAtlas = glyphAtlas;
    this.stacks = {};
    this.loading = {};
}

GlyphSource.prototype.getRects = function(fontstack, glyphIDs, tileID, callback) {

    if (this.stacks[fontstack] === undefined) this.stacks[fontstack] = {};

    var rects = {};
    var glyphs = {};
    var result = { rects: rects, glyphs: glyphs };

    var stack = this.stacks[fontstack];
    var glyphAtlas = this.glyphAtlas;

    var missing = {};
    var remaining = 0;

    for (var i = 0; i < glyphIDs.length; i++) {
        var glyphID = glyphIDs[i];
        var range = Math.floor(glyphID / 256);

        if (stack[range]) {
            var glyph = stack[range].glyphs[glyphID];
            var buffer = 3;
            rects[glyphID] = glyphAtlas.addGlyph(tileID, fontstack, glyph, buffer);
            if (glyph) glyphs[glyphID] = simpleGlyph(glyph);
        } else {
            if (missing[range] === undefined) {
                missing[range] = [];
                remaining++;
            }
            missing[range].push(glyphID);
        }
    }

    if (!remaining) callback(undefined, result);

    var glyphSource = this;
    for (var r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
    }

    function onRangeLoaded(err, range, data) {
        // TODO not be silent about errors
        if (!err) {
            var stack = glyphSource.stacks[fontstack][range] = data.stacks[fontstack];
            for (var i = 0; i < missing[range].length; i++) {
                var glyphID = missing[range][i];
                var glyph = stack.glyphs[glyphID];
                var buffer = 3;
                rects[glyphID] = glyphAtlas.addGlyph(tileID, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = simpleGlyph(glyph);
            }
        }
        remaining--;
        if (!remaining) callback(undefined, result);
    }
};

function simpleGlyph(glyph) {
    return {
        advance: glyph.advance,
        left: glyph.left,
        top: glyph.top
    };
}

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {

    if (range * 256 >= 65280) return callback('gyphs > 65280 not supported');

    if (this.loading[fontstack] === undefined) this.loading[fontstack] = {};
    var loading = this.loading[fontstack];

    if (loading[range]) {
        loading[range].push(callback);
    } else {
        loading[range] = [callback];

        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);

        getArrayBuffer(url, function(err, data) {
            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
            for (var i = 0; i < loading[range].length; i++) {
                loading[range][i](err, range, glyphs);
            }
            delete loading[range];
        });
    }
};

function glyphUrl(fontstack, range, url, subdomains) {
    subdomains = subdomains || 'abc';

    return url
        .replace('{s}', subdomains[fontstack.length % subdomains.length])
        .replace('{fontstack}', fontstack)
        .replace('{range}', range);
}

},{"../util/ajax.js":75,"../util/glyphs.js":82,"pbf":95}],61:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    Anchor = require('../symbol/anchor.js');

module.exports = interpolate;

var minScale = 0.5;
var minScaleArrays = {
    1: [minScale],
    2: [minScale, 2],
    4: [minScale, 4, 2, 4],
    8: [minScale, 8, 4, 8, 2, 8, 4, 8]
};


function interpolate(vertices, spacing, minScale, maxScale, tilePixelRatio, start) {

    if (minScale === undefined) minScale = 0;

    maxScale = Math.round(Math.max(Math.min(8, maxScale / 2), 1));
    spacing *= tilePixelRatio / maxScale;
    var minScales = minScaleArrays[maxScale];
    var len = minScales.length;

    var distance = 0,
        markedDistance = 0,
        added = start || 0;

    var points = [];

    for (var i = 0; i < vertices.length - 1; i++) {

        var a = vertices[i],
            b = vertices[i + 1];

        var segmentDist = a.dist(b),
            angle = b.angleTo(a);

        while (markedDistance + spacing < distance + segmentDist) {
            markedDistance += spacing;

            var t = (markedDistance - distance) / segmentDist,
                x = util.interp(a.x, b.x, t),
                y = util.interp(a.y, b.y, t),
                s = minScales[added % len];

            if (x >= 0 && x < 4096 && y >= 0 && y < 4096) {
                points.push(new Anchor(x, y, angle, s, i));
            }

            added++;
        }

        distance += segmentDist;
    }

    return points;
}

},{"../symbol/anchor.js":56,"../util/util.js":86}],62:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = {
    getIcon: getIcon,
    getGlyphs: getGlyphs
};

var minScale = 0.5; // underscale by 1 zoom level

function getIcon(anchor, image, boxScale, line, props) {

    var x = image.width / 2 / image.pixelRatio;
    var y = image.height / 2 / image.pixelRatio;

    var dx = props['icon-offset'][0];
    var dy = props['icon-offset'][1];
    var x1 = (dx - x);
    var x2 = (dx + x);
    var y1 = (dy - y);
    var y2 = (dy + y);

    var tl = new Point(x1, y1);
    var tr = new Point(x2, y1);
    var br = new Point(x2, y2);
    var bl = new Point(x1, y2);

    var angle = props['icon-rotate'] * Math.PI / 180;
    if (anchor.segment !== undefined && props['icon-rotation-alignment'] !== 'viewport') {
        var next = line[anchor.segment];
        angle += -Math.atan2(next.x - anchor.x, next.y - anchor.y) + Math.PI / 2;
    }

    if (angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle),
            matrix = [cos, -sin, sin, cos];

        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);

        x1 = Math.min(tl.x, tr.x, bl.x, br.x);
        x2 = Math.max(tl.x, tr.x, bl.x, br.x);
        y1 = Math.min(tl.y, tr.y, bl.y, br.y);
        y2 = Math.max(tl.y, tr.y, bl.y, br.y);
    }
    var box = {
        x1: x1 * boxScale,
        x2: x2 * boxScale,
        y1: y1 * boxScale,
        y2: y2 * boxScale
    };

    var iconBox = {
        box: box,
        anchor: anchor,
        minScale: minScale,
        maxScale: Infinity,
        padding: props['icon-padding']
    };

    var icon = {
        tl: tl,
        tr: tr,
        br: br,
        bl: bl,
        tex: image,
        angle: 0,
        anchor: anchor,
        minScale: minScale,
        maxScale: Infinity
    };

    return {
        shapes: [icon],
        boxes: [iconBox],
        minScale: anchor.scale
    };
}

function getGlyphs(anchor, origin, shaping, faces, boxScale, horizontal, line, props) {

    var maxAngleDelta = props['text-max-angle'] * Math.PI / 180;
    var rotate = props['text-rotate'] * Math.PI / 180;
    var padding = props['text-padding'];
    var alongLine = props['text-rotation-alignment'] !== 'viewport';
    var keepUpright = props['text-keep-upright'];

    var glyphs = [],
        boxes = [];

    var buffer = 3;

    for (var k = 0; k < shaping.length; k++) {
        var shape = shaping[k];
        var fontstack = faces[shape.fontstack];
        var glyph = fontstack.glyphs[shape.glyph];
        var rect = fontstack.rects[shape.glyph];

        if (!glyph) continue;

        if (!(rect && rect.w > 0 && rect.h > 0)) continue;

        var x = (origin.x + shape.x + glyph.left - buffer + rect.w / 2) * boxScale;

        var glyphInstances;
        if (anchor.segment !== undefined && alongLine) {
            glyphInstances = [];
            getSegmentGlyphs(glyphInstances, anchor, x, line, anchor.segment, 1, maxAngleDelta);
            if (keepUpright) getSegmentGlyphs(glyphInstances, anchor, x, line, anchor.segment, -1, maxAngleDelta);

        } else {
            glyphInstances = [{
                anchor: anchor,
                offset: 0,
                angle: 0,
                maxScale: Infinity,
                minScale: minScale
            }];
        }

        var x1 = origin.x + shape.x + glyph.left - buffer,
            y1 = origin.y + shape.y - glyph.top - buffer,
            x2 = x1 + rect.w,
            y2 = y1 + rect.h,

            otl = new Point(x1, y1),
            otr = new Point(x2, y1),
            obl = new Point(x1, y2),
            obr = new Point(x2, y2);

        var obox = {
                x1: boxScale * x1,
                y1: boxScale * y1,
                x2: boxScale * x2,
                y2: boxScale * y2
            };

        for (var i = 0; i < glyphInstances.length; i++) {

            var instance = glyphInstances[i],

                tl = otl,
                tr = otr,
                bl = obl,
                br = obr,
                box = obox,

                // Clamp to -90/+90 degrees
                angle = instance.angle + rotate;

            if (angle) {
                // Compute the transformation matrix.
                var sin = Math.sin(angle),
                    cos = Math.cos(angle),
                    matrix = [cos, -sin, sin, cos];

                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
            }

            // Prevent label from extending past the end of the line
            var glyphMinScale = Math.max(instance.minScale, anchor.scale);

            // Remember the glyph for later insertion.
            glyphs.push({
                tl: tl,
                tr: tr,
                bl: bl,
                br: br,
                tex: rect,
                angle: (anchor.angle + rotate + instance.offset + 2 * Math.PI) % (2 * Math.PI),
                anchor: instance.anchor,
                minScale: glyphMinScale,
                maxScale: instance.maxScale
            });

            if (!instance.offset) { // not a flipped glyph
                if (angle) {
                    // Calculate the rotated glyph's bounding box offsets from the anchor point.
                    box = {
                        x1: boxScale * Math.min(tl.x, tr.x, bl.x, br.x),
                        y1: boxScale * Math.min(tl.y, tr.y, bl.y, br.y),
                        x2: boxScale * Math.max(tl.x, tr.x, bl.x, br.x),
                        y2: boxScale * Math.max(tl.y, tr.y, bl.y, br.y)
                    };
                }
                boxes.push({
                    box: box,
                    anchor: instance.anchor,
                    minScale: glyphMinScale,
                    maxScale: instance.maxScale,
                    padding: padding
                });
            }
        }
    }

    // TODO avoid creating the boxes in the first place?
    if (horizontal) boxes = [getMergedBoxes(boxes, anchor)];

    var minPlacementScale = anchor.scale;
    var minGlyphScale = Infinity;
    for (var m = 0; m < boxes.length; m++) {
        minGlyphScale = Math.min(minGlyphScale, boxes[m].minScale);
    }
    minGlyphScale = Math.max(minPlacementScale, minScale);

    return {
        boxes: boxes,
        shapes: glyphs,
        minScale: minGlyphScale
    };
}

function getSegmentGlyphs(glyphs, anchor, offset, line, segment, direction, maxAngleDelta) {
    var upsideDown = direction < 0;

    if (offset < 0)  direction *= -1;

    if (direction > 0) segment++;

    var newAnchor = anchor;
    var end = line[segment];
    var prevscale = Infinity;
    var prevAngle;

    offset = Math.abs(offset);

    var placementScale = anchor.scale;

    segment_loop:
    while (true) {
        var dist = newAnchor.dist(end);
        var scale = offset/dist;
        var angle = -Math.atan2(end.x - newAnchor.x, end.y - newAnchor.y) + direction * Math.PI / 2;
        if (upsideDown) angle += Math.PI;

        // Don't place around sharp corners
        var angleDiff = (angle - prevAngle) % (2 * Math.PI);
        if (prevAngle && Math.abs(angleDiff) > maxAngleDelta) {
            anchor.scale = prevscale;
            break;
        }

        glyphs.push({
            anchor: newAnchor,
            offset: upsideDown ? Math.PI : 0,
            minScale: scale,
            maxScale: prevscale,
            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
        });

        if (scale <= placementScale) break;

        newAnchor = end;

        // skip duplicate nodes
        while (newAnchor.equals(end)) {
            segment += direction;
            end = line[segment];

            if (!end) {
                anchor.scale = scale;
                break segment_loop;
            }
        }

        var unit = end.sub(newAnchor)._unit();
        newAnchor = newAnchor.sub(unit._mult(dist));

        prevscale = scale;
        prevAngle = angle;
    }
}

function getMergedBoxes(glyphs, anchor) {
      // Collision checks between rotating and fixed labels are relatively expensive,
      // so we use one box per label, not per glyph for horizontal labels.

    var mergedglyphs = {
        box: { x1: Infinity, y1: Infinity, x2: -Infinity, y2: -Infinity },
        anchor: anchor,
        minScale: 0,
        padding: -Infinity
    };

    var box = mergedglyphs.box;

    for (var m = 0; m < glyphs.length; m++) {
        var gbox = glyphs[m].box;
        box.x1 = Math.min(box.x1, gbox.x1);
        box.y1 = Math.min(box.y1, gbox.y1);
        box.x2 = Math.max(box.x2, gbox.x2);
        box.y2 = Math.max(box.y2, gbox.y2);
        mergedglyphs.minScale = Math.max(mergedglyphs.minScale, glyphs[m].minScale);
        mergedglyphs.padding = Math.max(mergedglyphs.padding, glyphs[m].padding);
    }
    // for all horizontal labels, calculate bbox covering all rotated positions
    var x12 = box.x1 * box.x1,
        y12 = box.y1 * box.y1,
        x22 = box.x2 * box.x2,
        y22 = box.y2 * box.y2,
        diag = Math.sqrt(Math.max(x12 + y12, x12 + y22, x22 + y12, x22 + y22));

    mergedglyphs.hBox = {
        x1: -diag,
        y1: -diag,
        x2: diag,
        y2: diag
    };

    return mergedglyphs;
}

},{"point-geometry":97}],63:[function(require,module,exports){
'use strict';

var resolveTokens = require('../util/token.js');

module.exports = resolveText;

// For an array of features determine what glyph ranges need to be loaded
// and apply any text preprocessing. The remaining users of text should
// use the `textFeatures` key returned by this function rather than accessing
// feature text directly.
function resolveText(features, info, glyphs) {
    var textFeatures = [];
    var codepoints = [];

    for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, info['text-field']);
        var hastext = false;
        if (!text) continue;
        text = text.toString();

        var transform = info['text-transform'];
        if (transform === 'uppercase') {
            text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
            text = text.toLocaleLowerCase();
        }

        for (var j = 0, jl = text.length; j < jl; j++) {
            if (text.charCodeAt(j) <= 65533) {
                codepoints.push(text.charCodeAt(j));
                hastext = true;
            }
        }
        // Track indexes of features with text.
        if (hastext) {
            textFeatures[i] = text;
        }
    }

    // get a list of unique codepoints we are missing
    codepoints = uniq(codepoints, glyphs);

    return {
        textFeatures: textFeatures,
        codepoints: codepoints
    };
}

function uniq(ids, alreadyHave) {
    var u = [];
    var last;
    ids.sort(sortNumbers);
    for (var i = 0; i < ids.length; i++) {
        if (ids[i] !== last) {
            last = ids[i];
            if (!alreadyHave[last]) u.push(ids[i]);
        }
    }
    return u;
}

function sortNumbers(a, b) {
    return a - b;
}


},{"../util/token.js":84}],64:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    Point = require('point-geometry');

module.exports = {
    rotationRange: rotationRange,
    mergeCollisions: mergeCollisions,

    rotatingFixedCollisions: rotatingFixedCollisions,
    rotatingRotatingCollisions: rotatingRotatingCollisions,

    cornerBoxCollisions: cornerBoxCollisions,
    circleEdgeCollisions: circleEdgeCollisions,

    getCorners: getCorners,
};

/*
 * Calculate the range a box conflicts with a second box
 */
function rotationRange(inserting, blocker, scale) {

    var collisions, box;

    var a = inserting;
    var b = blocker;

    // Instead of scaling the boxes, we move the anchors
    var relativeAnchor = new Point(
        (b.anchor.x - a.anchor.x) * scale,
        (b.anchor.y - a.anchor.y) * scale);

    // Generate a list of collision interval
    if (a.hBox && b.hBox) {
        collisions = rotatingRotatingCollisions(a.box, b.box, relativeAnchor);

    } else if (a.hBox) {
        box = {
            x1: b.box.x1 + relativeAnchor.x,
            y1: b.box.y1 + relativeAnchor.y,
            x2: b.box.x2 + relativeAnchor.x,
            y2: b.box.y2 + relativeAnchor.y
        };
        collisions = rotatingFixedCollisions(a.box, box);


    } else if (b.hBox) {
        box = {
            x1: a.box.x1 - relativeAnchor.x,
            y1: a.box.y1 - relativeAnchor.y,
            x2: a.box.x2 - relativeAnchor.x,
            y2: a.box.y2 - relativeAnchor.y
        };
        collisions = rotatingFixedCollisions(b.box, box);

    } else {
        collisions = [];
    }

    // Find and return the continous are around 0 where there are no collisions
    return mergeCollisions(collisions, blocker.placementRange);
}

/*
 * Combine an array of collision ranges to form a continuous
 * range that includes 0. Collisions within the ignoreRange are ignored
 */
function mergeCollisions(collisions, ignoreRange) {

    // find continuous interval including 0 that doesn't have any collisions
    var min = 2 * Math.PI;
    var max = 0;

    for (var i = 0; i < collisions.length; i++) {
        var collision = collisions[i];

        var entryOutside = ignoreRange[0] <= collision[0] && collision[0] <= ignoreRange[1];
        var exitOutside = ignoreRange[0] <= collision[1] && collision[1] <= ignoreRange[1];

        if (entryOutside && exitOutside) {
            // no collision, since blocker is out of range
        } else if (entryOutside) {
            min = Math.min(min, ignoreRange[1]);
            max = Math.max(max, collision[1]);
        } else if (exitOutside) {
            min = Math.min(min, collision[0]);
            max = Math.max(max, ignoreRange[0]);
        } else {
            min = Math.min(min, collision[0]);
            max = Math.max(max, collision[1]);
        }
    }

    return [min, max];
}

/*
 *  Calculate collision ranges for two rotating boxes.
 */

var horizontal = new Point(1, 0);

function rotatingRotatingCollisions(a, b, anchorToAnchor) {
    var d = anchorToAnchor.mag();

    var angleBetweenAnchors = anchorToAnchor.angleWith(horizontal);

    var c = [],
        collisions = [],
        k;

    // Calculate angles at which collisions may occur
    // top/bottom
    c[0] = Math.asin((a.y2 - b.y1) / d);
    c[1] = Math.asin((a.y2 - b.y1) / d) + Math.PI;
    c[2] = 2 * Math.PI - Math.asin((-a.y1 + b.y2) / d);
    c[3] = Math.PI - Math.asin((-a.y1 + b.y2) / d);

    // left/right
    c[4] = 2 * Math.PI - Math.acos((a.x2 - b.x1) / d);
    c[5] = Math.acos((a.x2 - b.x1) / d);
    c[6] = Math.PI - Math.acos((-a.x1 + b.x2) / d);
    c[7] = Math.PI + Math.acos((-a.x1 + b.x2) / d);

    var rl = a.x2 - b.x1;
    var lr = -a.x1 + b.x2;
    var tb = a.y2 - b.y1;
    var bt = -a.y1 + b.y2;

    // Calculate the distance squared of the diagonal which will be used
    // to check if the boxes are close enough for collisions to occur at each angle
    // todo, triple check these
    var e = [];
    // top/bottom
    e[0] = rl * rl + tb * tb;
    e[1] = lr * lr + tb * tb;
    e[2] = rl * rl + bt * bt;
    e[3] = lr * lr + bt * bt;
    // left/right
    e[4] = rl * rl + tb * tb;
    e[5] = rl * rl + bt * bt;
    e[6] = lr * lr + bt * bt;
    e[7] = lr * lr + tb * tb;


    c = c.filter(function(x, i) {
        // Check if they are close enough to collide
        return !isNaN(x) && d * d <= e[i];
    }).map(function(x) {
        // So far, angles have been calulated as relative to the vector between anchors.
        // Convert the angles to angles from north.
        return (x + angleBetweenAnchors + 2 * Math.PI) % (2 * Math.PI);
    });

    // Group the collision angles by two
    // each group represents a range where the two boxes collide
    c.sort();
    for (k = 0; k < c.length; k+=2) {
        collisions.push([c[k], c[k+1]]);
    }

    return collisions;

}

/*
 *  Calculate collision ranges for a rotating box and a fixed box;
 */
function rotatingFixedCollisions(rotating, fixed) {

    var cornersR = getCorners(rotating);
    var cornersF = getCorners(fixed);

    // A collision occurs when, and only at least one corner from one of the boxes
    // is within the other box. Calculate these ranges for each corner.

    var collisions = [];

    for (var i = 0; i < 4; i++ ) {
        cornerBoxCollisions(collisions, cornersR[i], cornersF);
        cornerBoxCollisions(collisions, cornersF[i], cornersR, true);
    }

    return collisions;
}


/*
 *  Calculate the ranges for which the corner,
 *  rotatated around the anchor, is within the box;
 */
function cornerBoxCollisions(collisions, corner, boxCorners, flip) {
    var radius = corner.mag(),
        angles = [];

    // Calculate the points at which the corners intersect with the edges
    for (var i = 0, j = 3; i < 4; j = i++) {
        circleEdgeCollisions(angles, corner, radius, boxCorners[j], boxCorners[i]);
    }

    if (angles.length % 2 !== 0) {
        // TODO fix
        // This could get hit when a point intersects very close to a corner
        // and floating point issues cause only one of the entry or exit to be counted
        throw('expecting an even number of intersections');
    }

    angles.sort();

    // Group by pairs, where each represents a range where a collision occurs
    for (var k = 0; k < angles.length; k+=2) {
        collisions[k/2] = flip ?
            [2 * Math.PI - angles[k+1], 2 * Math.PI - angles[k]] : // reflect an angle around 0 degrees
            [angles[k], angles[k+1]];
    }

    return collisions;
}

/*
 * Return the intersection points of a circle and a line segment;
 */
function circleEdgeCollisions(angles, corner, radius, p1, p2) {

    var edgeX = p2.x - p1.x;
    var edgeY = p2.y - p1.y;

    var a = edgeX * edgeX + edgeY * edgeY;
    var b = (edgeX * p1.x + edgeY * p1.y) * 2;
    var c = p1.x * p1.x + p1.y * p1.y - radius * radius;

    var discriminant = b*b - 4*a*c;

    // a collision exists only if line intersects circle at two points
    if (discriminant > 0) {
        var x1 = (-b - Math.sqrt(discriminant)) / (2 * a);
        var x2 = (-b + Math.sqrt(discriminant)) / (2 * a);

        // only add points if within line segment
        // hack to handle floating point representations of 0 and 1
        if (0 < x1 && x1 < 1) {
            angles.push(getAngle(p1, p2, x1, corner));
        }

        if (0 < x2 && x2 < 1) {
            angles.push(getAngle(p1, p2, x2, corner));
        }
    }

    return angles;
}

function getAngle(p1, p2, d, corner) {
    return (-corner.angleWithSep(
        util.interp(p1.x, p2.x, d),
        util.interp(p1.y, p2.y, d)) + 2 * Math.PI) % (2 * Math.PI);
}

function getCorners(a) {
    return [
        new Point(a.x1, a.y1),
        new Point(a.x1, a.y2),
        new Point(a.x2, a.y2),
        new Point(a.x2, a.y1)
    ];
}

},{"../util/util.js":86,"point-geometry":97}],65:[function(require,module,exports){
'use strict';

module.exports = {
    shape: shape
};

function shape(text, name, stacks, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {
    var glyphs = stacks[name].glyphs;
    var glyph;

    var shaping = [];

    var x = translate[0];
    var y = translate[1];
    var id;

    for (var i = 0; i < text.length; i++) {
        id = text.charCodeAt(i);
        glyph = glyphs[id];

        if (id === 0 || !glyph) continue;

        shaping.push({
            fontstack: name,
            glyph: id,
            x: x,
            y: y
        });

        x += glyph.advance + spacing;
    }

    if (!shaping.length) return false;

    shaping = linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify);

    return shaping;
}

var breakable = { 32: true }; // Currently only breaks at regular spaces

function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify) {
    var lastSafeBreak = null;

    var lengthBeforeCurrentLine = 0;
    var lineStartIndex = 0;
    var line = 0;

    var maxLineLength = 0;

    if (maxWidth) {
        for (var i = 0; i < shaping.length; i++) {
            var shape = shaping[i];

            shape.x -= lengthBeforeCurrentLine;
            shape.y += lineHeight * line;

            if (shape.x > maxWidth && lastSafeBreak !== null) {

                var lineLength = shaping[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);

                for (var k = lastSafeBreak + 1; k <= i; k++) {
                    shaping[k].y += lineHeight;
                    shaping[k].x -= lineLength;
                }

                if (justify) {
                    justifyLine(shaping, glyphs, lineStartIndex, lastSafeBreak - 1, justify);
                }

                lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
            }

            if (breakable[shape.glyph]) {
                lastSafeBreak = i;
            }
        }
    }

    maxLineLength = maxLineLength || shaping[shaping.length - 1].x;

    justifyLine(shaping, glyphs, lineStartIndex, shaping.length - 1, justify);
    align(shaping, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line);
    return shaping;
}

function justifyLine(shaping, glyphs, start, end, justify) {
    var lastAdvance = glyphs[shaping[end].glyph].advance;
    var lineIndent = (shaping[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
        shaping[j].x -= lineIndent;
    }

}

function align(shaping, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line) {
    var shiftX = (justify - horizontalAlign) * maxLineLength;
    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight;

    for (var j = 0; j < shaping.length; j++) {
        shaping[j].x += shiftX;
        shaping[j].y += shiftY;
    }
}

},{}],66:[function(require,module,exports){
'use strict';

var Control = require('./control.js'),
    DOM = require('../../util/dom.js'),
    util = require('../../util/util.js');

module.exports = Attribution;

function Attribution() {}

Attribution.prototype = util.inherit(Control, {
    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-attrib',
            container = this._container = DOM.create('div', className, map.container);

        this._update();
        map.on('source.add', this._update.bind(this));
        map.on('moveend', this._updateEditLink.bind(this));

        return container;
    },

    _update: function() {
        var attributions = [];
        for (var id in this._map.sources) {
            var source = this._map.sources[id];
            if (source.tileJSON && source.tileJSON.attribution) {
                attributions.push(source.tileJSON.attribution);
            }
        }
        this._container.innerHTML = attributions.join(' | ');
        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
        this._updateEditLink();
    },

    _updateEditLink: function() {
        if (this._editLink) {
            var center = this._map.getCenter();
            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
    }
});

},{"../../util/dom.js":80,"../../util/util.js":86,"./control.js":67}],67:[function(require,module,exports){
'use strict';

module.exports = Control;

function Control() {}

Control.prototype = {
	addTo: function(map) {
		this._map = map;
		this._container = this.onAdd(map);
		return this;
	},

	remove: function () {
		this._container.parentNode.removeChild(this._container);
		if (this.onRemove) this.onRemove(this._map);
		this._map = null;
		return this;
	}
};

},{}],68:[function(require,module,exports){
'use strict';

var Control = require('./control.js'),
    DOM = require('../../util/dom.js'),
    util = require('../../util/util.js');

module.exports = Navigation;

function Navigation() {}

Navigation.prototype = util.inherit(Control, {
    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-nav';

        var container = this._container = DOM.create('div', className, map.container);

        this._zoomInButton = this._createButton(className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-compass', map.resetNorth.bind(map));

        var compassCanvas = this._compassCanvas = DOM.create('canvas', className + '-compass-canvas', this._compass);
        compassCanvas.style.cssText = 'width:26px; height:26px;';
        compassCanvas.width = 26 * 2;
        compassCanvas.height = 26 * 2;

        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);

        this._compassCtx = compassCanvas.getContext('2d');

        map.on('rotate', this._drawNorth.bind(this));
        this._drawNorth();

        return container;
    },

    _onCompassDown: function(e) {
        DOM.disableDrag();

        document.addEventListener('mousemove', this._onCompassMove);
        document.addEventListener('mouseup', this._onCompassUp);
        this._prevX = e.screenX;

        e.stopPropagation();
    },

    _onCompassMove: function(e) {
        var x = e.screenX,
            d = x < 2 ? -5 : // left edge of the screen, continue rotating
                x > window.screen.width - 2 ? 5 : // right edge
                (x - this._prevX) / 4;

        this._map.setBearing(this._map.getBearing() - d);
        this._prevX = e.screenX;

        e.preventDefault();
    },

    _onCompassUp: function() {
        document.removeEventListener('mousemove', this._onCompassMove);
        document.removeEventListener('mouseup', this._onCompassUp);
        DOM.enableDrag();
    },

    _createButton: function(className, fn) {
        var a = DOM.create('a', className, this._container);
        a.href = '#';
        a.addEventListener('click', function(e) {
            fn();
            e.preventDefault();
            e.stopPropagation();
        });
        a.addEventListener('dblclick', function(e) {
            e.preventDefault();
            e.stopPropagation();
        });
        return a;
    },

    _drawNorth: function() {
        var rad = 20,
            width = 8,
            center = 26,
            angle = this._map.transform.angle + (Math.PI / 2),
            ctx = this._compassCtx;

        this._compassCanvas.width = this._compassCanvas.width;

        ctx.translate(center, center);
        ctx.rotate(angle);

        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.lineTo(0, -width);
        ctx.lineTo(-rad, 0);
        ctx.lineTo(0, width);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = '#bbb';
        ctx.moveTo(0, 0);
        ctx.lineTo(0, width);
        ctx.lineTo(rad, 0);
        ctx.lineTo(0, -width);
        ctx.fill();

        ctx.beginPath();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.moveTo(0, -width);
        ctx.lineTo(0, width);
        ctx.stroke();
    }
});

},{"../../util/dom.js":80,"../../util/util.js":86,"./control.js":67}],69:[function(require,module,exports){
'use strict';

var util = require('../util/util.js'),
    browser = require('../util/browser.js'),
    LatLng = require('../geo/latlng.js'),
    LatLngBounds = require('../geo/latlngbounds.js'),
    Point = require('point-geometry');

util.extend(exports, {
    isEasing: function () {
        return !!this._stopFn;
    },

    stop: function () {
        if (this._stopFn) {
            this._stopFn();
            delete this._stopFn;
        }
        return this;
    },

    panBy: function(offset, options) {
        this.panTo(this.transform.center, util.extend({offset: Point.convert(offset).mult(-1)}, options));
        return this;
    },

    panTo: function(latlng, options) {
        this.stop();

        latlng = LatLng.convert(latlng);

        options = util.extend({
            duration: 500,
            easing: util.ease,
            offset: [0, 0]
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset).rotate(-tr.angle),
            from = tr.point,
            to = tr.project(latlng).sub(offset);

        if (!options.noMoveStart) {
            this.fire('movestart');
        }

        this._stopFn = browser.timed(function(t) {
            tr.center = tr.unproject(from.add(to.sub(from).mult(options.easing(t))));
            this._move();
            if (t === 1) this.fire('moveend');

        }, options.animate === false ? 0 : options.duration, this);

        return this;
    },

    // Zooms to a certain zoom level with easing.
    zoomTo: function(zoom, options) {
        this.stop();

        options = util.extend({
            duration: 500
        }, options);

        var tr = this.transform,
            around = tr.center,
            easing = this._updateEasing(options.duration, zoom, options.easing),
            startZoom = tr.zoom;

        if (options.around) {
            around = LatLng.convert(options.around);
        } else if (options.offset) {
            around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
        }

        if (options.animate === false) options.duration = 0;

        if (!this.zooming) {
            this.zooming = true;
            this.fire('movestart');
        }

        this._stopFn = browser.timed(function(t) {
            tr.setZoomAround(util.interp(startZoom, zoom, easing(t)), around);

            this.style.animationLoop.set(300); // text fading
            this._move(true);

            if (t === 1) {
                this.ease = null;
                if (options.duration >= 200) {
                    this.fire('moveend');
                    this.zooming = false;
                }
            }

        }, options.duration, this);

        if (options.duration < 200) {
            clearTimeout(this._onZoomEnd);
            this._onZoomEnd = setTimeout(function() {
                this.zooming = false;
                this._rerender();
                this.fire('moveend');
            }.bind(this), 200);
        }

        return this;
    },

    zoomIn: function(options) {
        this.zoomTo(this.getZoom() + 1, options);
    },

    zoomOut: function(options) {
        this.zoomTo(this.getZoom() - 1, options);
    },

    rotateTo: function(bearing, options) {
        this.stop();

        options = util.extend({
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            start = this.getBearing(),
            around = tr.center;

        if (options.around) {
            around = LatLng.convert(options.around);
        } else if (options.offset) {
            around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
        }

        this.rotating = true;
        this.fire('movestart');

        this._stopFn = browser.timed(function(t) {
            if (t === 1) { this.rotating = false; }
            tr.setBearingAround(util.interp(start, bearing, options.easing(t)), around);
            this._move(false, true).fire('moveend');
        }, options.animate === false ? 0 : options.duration, this);

        return this;
    },

    resetNorth: function(options) {
        return this.rotateTo(0, util.extend({duration: 1000}, options));
    },

    fitBounds: function(bounds, options) {

        options = util.extend({
            padding: 0,
            offset: [0, 0],
            maxZoom: Infinity
        }, options);

        bounds = LatLngBounds.convert(bounds);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            nw = tr.project(bounds.getNorthWest()),
            se = tr.project(bounds.getSouthEast()),
            size = se.sub(nw),
            center = tr.unproject(nw.add(se).div(2)),

            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y,

            zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);

        return options.linear ?
            this.easeTo(center, zoom, 0, options) :
            this.flyTo(center, zoom, 0, options);
    },

    easeTo: function(latlng, zoom, bearing, options) {

        options = util.extend({
            offset: [0, 0],
            duration: 500,
            easing: util.ease
        }, options);

        latlng = LatLng.convert(latlng);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            startZoom = this.getZoom(),
            startBearing = this.getBearing();

        zoom = zoom === undefined ? startZoom : zoom;
        bearing = bearing === undefined ? startBearing : bearing;

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = tr.project(latlng).sub(offset.div(scale)),
            around = tr.pointLocation(tr.centerPoint.add(to.sub(from).div(1 - 1 / scale)));

        if (zoom !== startZoom) this.zooming = true;
        if (startBearing !== bearing) this.rotating = true;

        this.fire('movestart');

        this._stopFn = browser.timed(function (t) {
            var k = options.easing(t);

            if (zoom !== startZoom) {
                tr.setZoomAround(startZoom + k * (zoom - startZoom), around);
            }
            if (bearing !== startBearing) {
                tr.bearing = util.interp(startBearing, bearing, k);
            }

            this.style.animationLoop.set(300); // text fading
            this._move(zoom !== startZoom, bearing !== startBearing);

            if (t === 1) {
                this.zooming = false;
                this.rotating = false;
                this.fire('moveend');
            }

        }, options.animate === false ? 0 : options.duration, this);

        return this;
    },

    flyTo: function(latlng, zoom, bearing, options) {

        options = util.extend({
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: util.ease
        }, options);

        latlng = LatLng.convert(latlng);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            startZoom = this.getZoom(),
            startBearing = this.getBearing();

        zoom = zoom === undefined ? startZoom : zoom;
        bearing = bearing === undefined ? startBearing : bearing;

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = tr.project(latlng).sub(offset.div(scale));

        if (options.animate === false) {
            return this.setView(latlng, zoom, bearing);
        }

        var startWorldSize = tr.worldSize,
            rho = options.curve,
            V = options.speed,

            w0 = Math.max(tr.width, tr.height),
            w1 = w0 / scale,
            u1 = to.sub(from).mag(),
            rho2 = rho * rho;

        function r(i) {
            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
        }

        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
        function tanh(n) { return sinh(n) / cosh(n); }

        var r0 = r(0),
            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
            S = (r(1) - r0) / rho;

        if (Math.abs(u1) < 0.000001) {
            if (Math.abs(w0 - w1) < 0.000001) return this;

            var k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;

            u = function() { return 0; };
            w = function(s) { return Math.exp(k * rho * s); };
        }

        var duration = 1000 * S / V;

        this.zooming = true;
        if (startBearing != bearing) this.rotating = true;

        this.fire('movestart');

        this._stopFn = browser.timed(function (t) {
            var k = options.easing(t),
                s = k * S,
                us = u(s);

            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

            if (bearing !== startBearing) {
                tr.bearing = util.interp(startBearing, bearing, k);
            }

            this.style.animationLoop.set(300); // text fading

            this._move(true, bearing !== startBearing);

            if (t === 1) {
                this.zooming = false;
                this.rotating = false;
                this.fire('moveend');
            }
        }, duration, this);

        return this;
    },

    _updateEasing: function(duration, zoom, bezier) {
        var easing;

        if (this.ease) {
            var ease = this.ease,
                t = (Date.now() - ease.start) / ease.duration,
                speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                y = Math.sqrt(0.27 * 0.27 - x * x);

            easing = util.bezier(x, y, 0.25, 1);
        } else {
            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
        }

        // store information on current easing
        this.ease = {
            start: (new Date()).getTime(),
            to: Math.pow(2, zoom),
            duration: duration,
            easing: easing
        };

        return easing;
    }
});

},{"../geo/latlng.js":17,"../geo/latlngbounds.js":18,"../util/browser.js":76,"../util/util.js":86,"point-geometry":97}],70:[function(require,module,exports){
'use strict';

var Interaction = require('./interaction.js');
var Point = require('point-geometry');
var util = require('../util/util.js');

module.exports = Handlers;

function Handlers(map) {

    var rotateEnd;

    var inertiaLinearity = 0.2,
        inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1);

    this.interaction = new Interaction(map.container)
        .on('click', function(e) {
            map.fire('click', e);
        })
        .on('hover', function(e) {
            map.fire('hover', e);
        })
        .on('down', function () {
            map.fire('movestart');
        })
        .on('resize', function() {
            map.stop();
            map.resize();
            map.update();
        })
        .on('pan', function(e) {
            map.stop();
            map.transform.panBy(e.offset);
            map._move();
        })
        .on('panend', function(e) {
            if (!e.inertia) map.fire('moveend');
            else {
                // convert velocity to px/s & adjust for increased initial animation speed when easing out
                var velocity = e.inertia.mult(1000 * inertiaLinearity),
                    speed = velocity.mag();

                var maxSpeed = 4000; // px/s

                if (speed >= maxSpeed) {
                    speed = maxSpeed;
                    velocity._unit()._mult(maxSpeed);
                }

                var deceleration = 8000, // px/s^2
                    duration = speed / (deceleration * inertiaLinearity),
                    offset = velocity.mult(-duration / 2).round();

                map.panBy(offset, {
                    duration: duration * 1000,
                    easing: inertiaEasing,
                    noMoveStart: true
                });
            }
        })
        .on('zoom', function(e) {
            // Scale by sigmoid of scroll wheel delta.
            var scale = 2 / (1 + Math.exp(-Math.abs(e.delta / 100)));
            if (e.delta < 0 && scale !== 0) scale = 1 / scale;

            var fromScale = map.ease && isFinite(e.delta) ? map.ease.to : map.transform.scale,
                duration = !isFinite(e.delta) ? 800 : e.source == 'trackpad' ? 0 : 300;

            map.zoomTo(map.transform.scaleZoom(fromScale * scale), {
                duration: duration,
                around: map.unproject(e.point)
            });
        })
        .on('rotate', function(e) {
            var center = map.transform.centerPoint, // Center of rotation
                startToCenter = e.start.sub(center),
                startToCenterDist = startToCenter.mag();

            // If the first click was too close to the center, move the center of rotation by 200 pixels
            // in the direction of the click.
            if (startToCenterDist < 200) {
                center = e.start.add(new Point(-200, 0)._rotate(startToCenter.angle()));
            }

            var bearingDiff = e.prev.sub(center).angleWith(e.current.sub(center)) / Math.PI * 180;
            map.transform.bearing = map.getBearing() - bearingDiff;

            map._move(false, true);

            window.clearTimeout(rotateEnd);
            rotateEnd = window.setTimeout(function() {
                map.rotating = false;
                map._rerender();
            }, 200);
        });
}

},{"../util/util.js":86,"./interaction.js":72,"point-geometry":97}],71:[function(require,module,exports){
'use strict';

module.exports = Hash;

var util = require('../util/util.js');

function Hash(map) {
    this.map = map;
    window.addEventListener('hashchange', this.onhash.bind(this), false);
    map.on('move', util.debounce(this.updateHash.bind(this), 100));
}

Hash.prototype = {
    onhash: function() {
        var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
            this.map.setView([+loc[1], +loc[2]], +loc[0], +(loc[3] || 0));
            return true;
        }
        return false;
    },

    updateHash: function() {
        var center = this.map.getCenter(),
            zoom = this.map.getZoom(),
            bearing = this.map.getBearing(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

            hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

        window.history.replaceState('', '', hash);
    }
};

},{"../util/util.js":86}],72:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented.js'),
    browser = require('../util/browser.js'),
    Point = require('point-geometry');

module.exports = Interaction;

function Interaction(el) {
    var interaction = this;
    if (!el) return;

    var rotating = false,
        panned = false,
        firstPos = null,
        pos = null,
        inertia = null,
        now;

    function mousePos(e) {
        var rect = el.getBoundingClientRect();
        return new Point(
            e.clientX - rect.left - el.clientLeft,
            e.clientY - rect.top - el.clientTop);
    }

    el.addEventListener('contextmenu', function(ev) {
        rotating = true;
        firstPos = pos = mousePos(ev);
        ev.preventDefault();
    }, false);
    el.addEventListener('mousedown', onmousedown, false);
    document.addEventListener('mouseup', onmouseup, false);
    document.addEventListener('mousemove', onmousemove, false);
    el.addEventListener('click', onclick, false);
    scrollwheel(zoom);
    el.addEventListener('dblclick', ondoubleclick, false);
    window.addEventListener('resize', resize, false);

    function zoom(type, delta, point) {
        interaction.fire('zoom', {
            source: type,
            delta: delta,
            point: point
        });
        inertia = null;
        now = null;
    }

    function click(point) {
        interaction.fire('click', {point: point});
    }

    function hover(point) {
        interaction.fire('hover', {point: point});
    }

    function pan(point) {
        if (pos) {
            var offset = pos.sub(point);
            interaction.fire('pan', {offset: offset});

            // add an averaged version of this movement to the inertia vector
            if (inertia) {
                var duration = Date.now() - now;
                // sometimes it's 0 after some erratic paning
                if (duration) {
                    var time = duration + now;
                    inertia.push([time, point]);
                    while (inertia.length > 2 && time - inertia[0][0] > 100) inertia.shift();
                }

            } else {
                inertia = [];
            }
            now = Date.now();
            pos = point;
        }
    }

    function resize() {
        interaction.fire('resize');
    }

    function rotate(point) {
        if (pos) {
            interaction.fire('rotate', {
                start: firstPos,
                prev: pos,
                current: point
            });
            pos = point;
        }
    }

    function onmousedown(ev) {
        firstPos = pos = mousePos(ev);
        interaction.fire('down');
    }

    function onmouseup() {
        panned = pos && firstPos && (pos.x != firstPos.x || pos.y != firstPos.y);

        rotating = false;
        pos = null;

        if (inertia && inertia.length >= 2 && now > Date.now() - 100) {
            var last = inertia[inertia.length - 1],
                first = inertia[0],
                velocity = last[1].sub(first[1]).div(last[0] - first[0]);
            interaction.fire('panend',  {inertia: velocity});

        } else interaction.fire('panend');

        inertia = null;
        now = null;
    }

    function onmousemove(ev) {
        var point = mousePos(ev);

        if (rotating) { rotate(point); }
        else if (pos) pan(point);
        else {
            var target = ev.toElement;
            while (target && target != el && target.parentNode) target = target.parentNode;
            if (target == el) {
                hover(point);
            }
        }
    }

    function onclick(ev) {
        if (!panned) click(mousePos(ev));
    }

    function ondoubleclick(ev) {
        zoom('wheel', Infinity * (ev.shiftKey ? -1 : 1), mousePos(ev));
        ev.preventDefault();
    }

    function scrollwheel(callback) {
        var firefox = /Firefox/i.test(navigator.userAgent);
        var safari = /Safari/i.test(navigator.userAgent) && !/Chrom(ium|e)/i.test(navigator.userAgent);
        var time = window.performance || Date;

        el.addEventListener('wheel', wheel, false);
        el.addEventListener('mousewheel', mousewheel, false);

        var lastEvent = 0;

        var type = null;
        var typeTimeout = null;
        var initialValue = null;

        function scroll(value, ev) {
            var stamp = time.now();
            var timeDelta = stamp - lastEvent;
            lastEvent = stamp;

            var point = mousePos(ev);

            if (value !== 0 && (value % 4.000244140625) === 0) {
                // This one is definitely a mouse wheel event.
                type = 'wheel';
            } else if (value !== 0 && Math.abs(value) < 4) {
                // This one is definitely a trackpad event because it is so small.
                type = 'trackpad';
            } else if (timeDelta > 400) {
                // This is likely a new scroll action.
                type = null;
                initialValue = value;
                // Start a timeout in case this was a singular event, and dely it
                // by up to 40ms.
                typeTimeout = setTimeout(function() {
                    type = 'wheel';
                    callback(type, -initialValue, point);
                }, 40);
            } else if (type === null) {
                // This is a repeating event, but we don't know the type of event
                // just yet. If the delta per time is small, we assume it's a
                // fast trackpad; otherwise we switch into wheel mode.
                type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

                // Make sure our delayed event isn't fired again, because we
                // accumulate the previous event (which was less than 40ms ago) into
                // this event.
                if (typeTimeout) {
                    clearTimeout(typeTimeout);
                    typeTimeout = null;
                    value += initialValue;
                }
            }

            // Only fire the callback if we actually know what type of scrolling
            // device the user uses.
            if (type !== null) {
                callback(type, -value, point);
            }
        }

        function wheel(e) {
            var deltaY = e.deltaY;
            // Firefox doubles the values on retina screens...
            if (firefox && e.deltaMode == window.WheelEvent.DOM_DELTA_PIXEL) deltaY /= browser.devicePixelRatio;
            if (e.deltaMode == window.WheelEvent.DOM_DELTA_LINE) deltaY *= 40;
            scroll(deltaY, e);
            e.preventDefault();
        }

        function mousewheel(e) {
            var deltaY = -e.wheelDeltaY;
            if (safari) deltaY = deltaY / 3;
            scroll(deltaY, e);
            e.preventDefault();
        }
    }
}

Interaction.prototype = Object.create(Evented);

},{"../util/browser.js":76,"../util/evented.js":81,"point-geometry":97}],73:[function(require,module,exports){
'use strict';

var Dispatcher = require('../util/dispatcher.js'),
    Canvas = require('../util/canvas.js'),
    util = require('../util/util.js'),
    browser = require('../util/browser.js'),
    ajax = require('../util/ajax.js'),
    Evented = require('../util/evented.js'),

    Style = require('../style/style.js'),
    AnimationLoop = require('../style/animationloop.js'),
    GLPainter = require('../render/painter.js'),

    Transform = require('../geo/transform.js'),
    Hash = require('./hash.js'),
    Handlers = require('./handlers.js'),
    Source = require('../source/source.js'),
    Easings = require('./easings.js'),
    LatLng = require('../geo/latlng.js'),
    LatLngBounds = require('../geo/latlngbounds.js'),
    Point = require('point-geometry'),
    GlyphSource = require('../symbol/glyphsource.js'),
    Attribution = require('./control/attribution.js');

// allow redefining Map here (jshint thinks it's global)
// jshint -W079

var Map = module.exports = function(options) {

    options = this.options = util.inherit(this.options, options);

    this.animationLoop = new AnimationLoop();
    this.transform = new Transform(options.minZoom, options.maxZoom);
    this.hash = options.hash && new Hash(this);

    if (options.maxBounds) {
        var b = LatLngBounds.convert(options.maxBounds);
        this.transform.latRange = [b.getSouth(), b.getNorth()];
        this.transform.lngRange = [b.getWest(), b.getEast()];
    }

    this._onStyleChange = this._onStyleChange.bind(this);
    this._updateBuckets = this._updateBuckets.bind(this);
    this.render = this.render.bind(this);

    this._setupContainer();
    this._setupPainter();

    this.handlers = options.interactive && new Handlers(this);
    this.dispatcher = new Dispatcher(Math.max(options.numWorkers, 1), this);

     // don't set position from options if set through hash
    if (!this.hash || !this.hash.onhash()) {
        this.setView(options.center, options.zoom, options.bearing);
    }

    this.sources = {};
    this.stacks = {};

    this.resize();

    if (typeof options.style === 'object') {
        this.setStyle(options.style);

    } else if (typeof options.style === 'string') {
        ajax.getJSON(options.style, function (err, data) {
            if (err) throw err;
            this.setStyle(data);
        }.bind(this));
    }

    if (options.attributionControl) this.addControl(new Attribution());
};

util.extend(Map.prototype, Evented);
util.extend(Map.prototype, Easings);
util.extend(Map.prototype, {

    options: {
        center: [0, 0],
        zoom: 0,
        bearing: 0,

        minZoom: 0,
        maxZoom: 20,
        numWorkers: browser.hardwareConcurrency - 1,

        interactive: true,
        hash: false,

        attributionControl: true
    },

    addSource: function(id, source) {
        this.sources[id] = source;
        source.id = id;
        if (source.onAdd) {
            source.onAdd(this);
        }
        if (source.enabled) source.fire('source.add', {source: source});
        return this;
    },

    removeSource: function(id) {
        var source = this.sources[id];
        if (source.onRemove) {
            source.onRemove(this);
        }
        delete this.sources[id];
        return this.fire('source.remove', {source: source});
    },

    addControl: function(control) {
        control.addTo(this);
        return this;
    },

    // Set the map's center, zoom, and bearing
    setView: function(center, zoom, bearing) {
        this.stop();

        var tr = this.transform,
            zoomChanged = tr.zoom !== +zoom,
            bearingChanged = tr.bearing !== +bearing;

        tr.center = LatLng.convert(center);
        tr.zoom = +zoom;
        tr.bearing = +bearing;

        return this
            .fire('movestart')
            ._move(zoomChanged, bearingChanged)
            .fire('moveend');
    },

    setCenter: function(center) {
        this.setView(center, this.getZoom(), this.getBearing());
    },

    setZoom: function(zoom) {
        this.setView(this.getCenter(), zoom, this.getBearing());
    },

    setBearing: function(bearing) {
        this.setView(this.getCenter(), this.getZoom(), bearing);
    },

    getCenter: function() { return this.transform.center; },
    getZoom: function() { return this.transform.zoom; },
    getBearing: function() { return this.transform.bearing; },

    // Detect the map's new width and height and resize it.
    resize: function() {
        var width = 0, height = 0;

        if (this.container) {
            width = this.container.offsetWidth || 400;
            height = this.container.offsetHeight || 300;
        }

        this.canvas.resize(width, height);

        this.transform.width = width;
        this.transform.height = height;
        this.transform._constrain();

        if (this.style && this.style.sprite) {
            this.style.sprite.resize(this.painter.gl);
        }

        this.painter.resize(width, height);

        return this
            .fire('movestart')
            ._move()
            .fire('resize')
            .fire('moveend');
    },

    getBounds: function() {
        return new LatLngBounds(
            this.transform.pointLocation(new Point(0, 0)),
            this.transform.pointLocation(this.transform.size));
    },

    project: function(latlng) {
        return this.transform.locationPoint(LatLng.convert(latlng));
    },
    unproject: function(point) {
        return this.transform.pointLocation(Point.convert(point));
    },

    featuresAt: function(point, params, callback) {
        var features = [];
        var error = null;
        var map = this;

        point = Point.convert(point);

        util.asyncEach(Object.keys(this.sources), function(id, callback) {
            var source = map.sources[id];
            source.featuresAt(point, params, function(err, result) {
                if (result) features = features.concat(result);
                if (err) error = err;
                callback();
            });
        }, function() {
            callback(error, features);
        });
        return this;
    },

    setStyle: function(style) {
        if (this.style) {
            this.style.off('change', this._onStyleChange);
        }

        if (style instanceof Style) {
            this.style = style;
        } else {
            this.style = new Style(style, this.animationLoop);
        }

        var sources = this.style.stylesheet.sources;
        for (var id in sources) {
            this.addSource(id, Source.create(sources[id]));
        }

        this.glyphSource = new GlyphSource(this.style.stylesheet.glyphs, this.painter.glyphAtlas);

        this.style.on('change', this._onStyleChange);

        this._styleDirty = true;
        this._tilesDirty = true;

        this._updateBuckets();
        this._updateGlyphs();

        this.fire('style.change');

        return this;
    },

    _move: function (zoom, rotate) {

        this.update(zoom).fire('move');

        if (zoom) this.fire('zoom');
        if (rotate) this.fire('rotate');

        return this;
    },

    // map setup code

    _setupContainer: function() {
        var id = this.options.container;
        var container = this.container = typeof id === 'string' ? document.getElementById(id) : id;
        if (container) container.classList.add('mapboxgl-map');
        this.canvas = new Canvas(this, container);
    },

    _setupPainter: function() {
        var gl = this.canvas.getWebGLContext();

        if (!gl) {
            alert('Failed to initialize WebGL');
            return;
        }

        this.painter = new GLPainter(gl, this.transform);
    },

    _contextLost: function(event) {
        event.preventDefault();
        if (this._frameId) {
            browser.cancelFrame(this._frameId);
        }
    },

    _contextRestored: function() {
        this._setupPainter();
        this.resize();
        this.update();
    },

    // Callbacks from web workers

    'debug message': function(data) {
        console.log.apply(console, data);
    },

    'alert message': function(data) {
        alert.apply(window, data);
    },

    'get sprite json': function(params, callback) {
        var sprite = this.style.sprite;
        if (sprite.loaded()) {
            callback(null, { sprite: sprite.data, retina: sprite.retina });
        } else {
            sprite.on('loaded', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            });
        }
    },

    'get glyphs': function(params, callback) {
        this.glyphSource.getRects(params.fontstack, params.codepoints, params.id, callback);
    },

    // Rendering

    update: function(updateStyle) {

        if (!this.style) return this;

        this._styleDirty = this._styleDirty || updateStyle;
        this._tilesDirty = true;

        this._rerender();

        return this;
    },

    // Call when a (re-)render of the map is required, e.g. when the user panned or zoomed,f or new data is available.
    render: function() {
        if (this._styleDirty) {
            this._styleDirty = false;
            this._updateStyle();
        }

        if (this._tilesDirty) {
            for (var id in this.sources) {
                this.sources[id].update();
            }
            this._tilesDirty = false;
        }

        this._renderGroups(this.style.layerGroups);
        this.fire('render');

        this._frameId = null;

        if (!this.animationLoop.stopped()) {
            this._styleDirty = true;
        }

        if (this._repaint || !this.animationLoop.stopped()) {
            this._rerender();
        }

        return this;
    },

    _renderGroups: function(groups) {

        var i, len, group, source;

        // Render the groups
        for (i = 0, len = groups.length; i < len; i++) {
            group = groups[i];
            source = this.sources[group.source];

            if (source) {
                this.painter.clearStencil();
                source.render(group);

            } else if (group.source === undefined) {
                this.painter.draw(undefined, this.style, group, { background: true });
            }
        }
    },

    _rerender: function() {
        if (!this._frameId) {
            this._frameId = browser.frame(this.render);
        }
    },

    _onStyleChange: function () {
        this.update(true);
    },

    _updateStyle: function() {
        if (!this.style) return;
        this.style.recalculate(this.transform.zoom);
    },

    _updateGlyphs: function() {
        this.dispatcher.broadcast('set glyphs', this.style.stylesheet.glyphs);
    },

    _updateBuckets: function() {
        // Transfer a stripped down version of the style to the workers. They only
        // need the bucket information to know what features to extract from the tile.
        this.dispatcher.broadcast('set buckets', this.style.orderedBuckets);

        // clears all tiles to recalculate geometries (for changes to linecaps, linejoins, ...)
        for (var s in this.sources) {
            this.sources[s].load();
        }

        this.update();
    }
});

util.extendAll(Map.prototype, {

    // debug code
    _debug: false,
    get debug() { return this._debug; },
    set debug(value) { this._debug = value; this._rerender(); },

    // continuous repaint
    _repaint: false,
    get repaint() { return this._repaint; },
    set repaint(value) { this._repaint = value; this._rerender(); },

    // polygon antialiasing
    _antialiasing: true,
    get antialiasing() { return this._antialiasing; },
    set antialiasing(value) { this._antialiasing = value; this._rerender(); },

    // show vertices
    _vertices: false,
    get vertices() { return this._vertices; },
    set vertices(value) { this._vertices = value; this._rerender(); },

    // show vertices
    _loadNewTiles: true,
    get loadNewTiles() { return this._loadNewTiles; },
    set loadNewTiles(value) { this._loadNewTiles = value; this.update(); }
});

},{"../geo/latlng.js":17,"../geo/latlngbounds.js":18,"../geo/transform.js":19,"../render/painter.js":32,"../source/source.js":39,"../style/animationloop.js":47,"../style/style.js":52,"../symbol/glyphsource.js":60,"../util/ajax.js":75,"../util/browser.js":76,"../util/canvas.js":77,"../util/dispatcher.js":78,"../util/evented.js":81,"../util/util.js":86,"./control/attribution.js":66,"./easings.js":69,"./handlers.js":70,"./hash.js":71,"point-geometry":97}],74:[function(require,module,exports){
'use strict';

module.exports = Actor;

function Actor(target, parent) {
    this.target = target;
    this.parent = parent;
    this.callbacks = {};
    this.callbackID = 0;
    this.receive = this.receive.bind(this);
    this.target.addEventListener('message', this.receive, false);
}

Actor.prototype.receive = function(message) {
    var data = message.data,
        callback;

    if (data.type == '<response>') {
        callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        callback(data.error || null, data.data);
    } else if (typeof data.id !== 'undefined') {
        var id = data.id;
        this.parent[data.type](data.data, function response(err, data, buffers) {
            // console.warn('trying to clone', data, buffers, message.target);
            message.target.postMessage({
                type: '<response>',
                id: String(id),
                error: err ? String(err) : null,
                data: data
            }, buffers);
        });
    } else {
        this.parent[data.type](data.data);
    }
};

Actor.prototype.send = function(type, data, callback, buffers) {
    var id = null;
    if (callback) this.callbacks[id = this.callbackID++] = callback;
    this.target.postMessage({ type: type, id: String(id), data: data }, buffers);
};

},{}],75:[function(require,module,exports){
'use strict';

exports.getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            var data;
            try { data = JSON.parse(xhr.response); }
            catch (err) { return callback(err); }
            callback(null, data);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getArrayBuffer = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            callback(null, xhr.response);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getImage = function(url, callback) {
    var img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = function() {
        callback(null, img);
    };
    img.src = url;
    img.getData = function() { return getImageData(this); };
    return img;
};

function getImageData(img) {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    context.drawImage(img, 0, 0);
    return context.getImageData(0, 0, img.width, img.height).data;
}

},{}],76:[function(require,module,exports){
'use strict';

var frameName = (function() {
    if (window.requestAnimationFrame) return 'requestAnimationFrame';
    if (window.mozRequestAnimationFrame) return 'mozRequestAnimationFrame';
    if (window.webkitRequestAnimationFrame) return 'webkitRequestAnimationFrame';
    if (window.msRequestAnimationFrame) return 'msRequestAnimationFrame';
})();

exports.frame = function(fn) {
    return window[frameName](fn);
};

exports.cancelFrame = function(id) {
    (window.cancelRequestAnimationFrame ||
        window.mozCancelRequestAnimationFrame ||
        window.webkitCancelRequestAnimationFrame ||
        window.msCancelRequestAnimationFrame)(id);
};

exports.timed = function (fn, dur, ctx) {
    if (!dur) { return fn.call(ctx, 1); }

    var abort = false,
        start = window.performance ? window.performance.now() : Date.now();

    function tick(now) {
        if (abort) return;
        if (!window.performance) now = Date.now();

        if (now > start + dur) {
            fn.call(ctx, 1);
        } else {
            fn.call(ctx, (now - start) / dur);
            exports.frame(tick);
        }
    }

    exports.frame(tick);

    return function() { abort = true; };
};

exports.supported = function() {
    var supports = [

        function() { return typeof window !== 'undefined'; },

        function() { return typeof document !== 'undefined'; },

        function () {
            return !!(Array.prototype &&
                Array.prototype.every &&
                Array.prototype.filter &&
                Array.prototype.forEach &&
                Array.prototype.indexOf &&
                Array.prototype.lastIndexOf &&
                Array.prototype.map &&
                Array.prototype.some &&
                Array.prototype.reduce &&
                Array.prototype.reduceRight &&
                Array.isArray);
        },

        function() {
            return !!(Function.prototype && Function.prototype.bind),
                !!(Object.keys &&
                    Object.create &&
                    Object.getPrototypeOf &&
                    Object.getOwnPropertyNames &&
                    Object.isSealed &&
                    Object.isFrozen &&
                    Object.isExtensible &&
                    Object.getOwnPropertyDescriptor &&
                    Object.defineProperty &&
                    Object.defineProperties &&
                    Object.seal &&
                    Object.freeze &&
                    Object.preventExtensions);
        },

        function() {
            return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
        },

        function() {
            var canvas = document.createElement('canvas');
            if ('supportsContext' in canvas) {
                return canvas.supportsContext('webgl') || canvas.supportsContext('experimental-webgl');
            }
            return !!window.WebGLRenderingContext &&
                (!!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl'));
        },

        function() { return 'Worker' in window; }
    ];

    for (var i = 0; i < supports.length; i++) {
        if (!supports[i]()) return false;
    }
    return true;
};

exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

Object.defineProperty(exports, 'devicePixelRatio', {
    get: function() { return window.devicePixelRatio; }
});

},{}],77:[function(require,module,exports){
'use strict';

module.exports = Canvas;

function Canvas(parent, container) {
    this.canvas = document.createElement('canvas');
    this.canvas.style.position = 'absolute';
    this.canvas.classList.add('mapboxgl-canvas');
    this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
    this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
    container.appendChild(this.canvas);
}

Canvas.prototype.resize = function(width, height) {
    var pixelRatio = window.devicePixelRatio || 1;

    // Request the required canvas size taking the pixelratio into account.
    this.canvas.width = pixelRatio * width;
    this.canvas.height = pixelRatio * height;

    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
};

Canvas.prototype.getWebGLContext = function() {
    return this.canvas.getContext("experimental-webgl", {
        antialias: false,
        alpha: true,
        stencil: true,
        depth: false
    });
};

},{}],78:[function(require,module,exports){
'use strict';

var Actor = require('../actor.js');

var scripts = document.getElementsByTagName("script");
var workerFile = scripts[scripts.length - 1].getAttribute('src');
var absolute = workerFile.indexOf('http') !== -1;


// Manages the WebWorkers
module.exports = Dispatcher;
function Dispatcher(length, parent) {
    this.actors = [];
    this.currentActor = 0;

    var url, blob, i;

    for (i = 0; i < length; i++) {
        // due to cross domain issues we can't load it directly with the url,
        // so create a blob and object url and load that
        if (absolute) {
            blob = new Blob(['importScripts("' + workerFile + '");'], {type : 'application/javascript'});
            url = window.URL.createObjectURL(blob);
        } else {
            url = workerFile;
        }

        var worker = new Worker(url);
        var actor = new Actor(worker, parent);
        actor.name = "Worker " + i;
        this.actors.push(actor);
    }
}

Dispatcher.prototype.broadcast = function(type, data) {
    for (var i = 0; i < this.actors.length; i++) {
        this.actors[i].send(type, data);
    }
};

Dispatcher.prototype.send = function(type, data, callback, targetID, buffers) {
    if (typeof targetID !== 'number' || isNaN(targetID)) {
        // Use round robin to send requests to web workers.
        targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
    }

    this.actors[targetID].send(type, data, callback, buffers);
    return targetID;
};


},{"../actor.js":74}],79:[function(require,module,exports){
'use strict';

module.exports = {
    HTTP_URL: 'http://a.tiles.mapbox.com/v4',
    HTTPS_URL: 'https://a.tiles.mapbox.com/v4',
    FORCE_HTTPS: false,
    REQUIRE_ACCESS_TOKEN: true
};

},{}],80:[function(require,module,exports){
'use strict';

exports.create = function (tagName, className, container) {
    var el = document.createElement(tagName);
    if (className) el.className = className;
    if (container) container.appendChild(el);
    return el;
};

function preventDefault(e) {
    e.preventDefault();
}

var docEl = typeof document !== 'undefined' ? document.documentElement : {},
    selectProp =
        'userSelect' in docEl ? 'userSelect' :
        'MozUserSelect' in docEl ? 'MozUserSelect' :
        'WebkitUserSelect' in docEl ? 'WebkitUserSelect' : null,
    userSelect;

exports.disableDrag = function () {
    window.addEventListener('dragstart', preventDefault);

    if ('onselectstart' in document) window.addEventListener('selectstart', preventDefault);
    else if (selectProp) {
        userSelect = docEl.style[selectProp];
        docEl.style[selectProp] = 'none';
    }
};
exports.enableDrag = function () {
    window.removeEventListener('dragstart', preventDefault);

    if ('onselectstart' in document) window.removeEventListener('selectstart', preventDefault);
    else if (selectProp) docEl.style[selectProp] = userSelect;
};

},{}],81:[function(require,module,exports){
'use strict';

var util = require('./util.js');

module.exports = {
    on: function(type, fn) {
        this._events = this._events || {};
        this._events[type] = this._events[type] || [];
        this._events[type].push(fn);

        return this;
    },

    off: function(type, fn) {
        if (!type) {
            // clear all listeners if no arguments specified
            delete this._events;
            return this;
        }

        if (!this.listens(type)) return this;

        if (fn) {
            var idx = this._events[type].indexOf(fn);
            if (idx >= 0) {
                this._events[type].splice(idx, 1);
            }
            if (!this._events[type].length) {
                delete this._events[type];
            }
        } else {
            delete this._events[type];
        }

        return this;
    },

    fire: function(type, data) {
        if (!this.listens(type)) return this;

        data = util.extend({}, data);
        util.extend(data, {type: type, target: this});

        // make sure adding/removing listeners inside other listeners won't cause infinite loop
        var listeners = this._events[type].slice();

        for (var i = 0; i < listeners.length; i++) {
            listeners[i].call(this, data);
        }

        return this;
    },

    listens: function(type) {
        return !!(this._events && this._events[type]);
    }
};

},{"./util.js":86}],82:[function(require,module,exports){
'use strict';

module.exports = Glyphs;
function Glyphs(buffer, end) {
    // Public
    this.stacks = {};
    // Private
    this._buffer = buffer;

    var val, tag;
    if (typeof end === 'undefined') end = buffer.length;
    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;
        if (tag == 1) {
            var fontstack = this.readFontstack();
            this.stacks[fontstack.name] = fontstack;
        } else {
            // console.warn('skipping tile tag ' + tag);
            buffer.skip(val);
        }
    }
}

Glyphs.prototype.readFontstack = function() {
    var buffer = this._buffer;
    var fontstack = { glyphs: {} };

    var bytes = buffer.readVarint();
    var val, tag;
    var end = buffer.pos + bytes;
    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag == 1) {
            fontstack.name = buffer.readString();
        } else if (tag == 2) {
            var range = buffer.readString();
            fontstack.range = range;
        } else if (tag == 3) {
            var glyph = this.readGlyph();
            fontstack.glyphs[glyph.id] = glyph;
        } else {
            buffer.skip(val);
        }
    }

    return fontstack;
};

Glyphs.prototype.readGlyph = function() {
    var buffer = this._buffer;
    var glyph = {};

    var bytes = buffer.readVarint();
    var val, tag;
    var end = buffer.pos + bytes;
    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag == 1) {
            glyph.id = buffer.readVarint();
        } else if (tag == 2) {
            glyph.bitmap = buffer.readBuffer();
        } else if (tag == 3) {
            glyph.width = buffer.readVarint();
        } else if (tag == 4) {
            glyph.height = buffer.readVarint();
        } else if (tag == 5) {
            glyph.left = buffer.readSVarint();
        } else if (tag == 6) {
            glyph.top = buffer.readSVarint();
        } else if (tag == 7) {
            glyph.advance = buffer.readVarint();
        } else {
            buffer.skip(val);
        }
    }

    return glyph;
};

},{}],83:[function(require,module,exports){
'use strict';

/*
 * A [most-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
 * with hash lookup made possible by keeping a list of keys in parallel to
 * an array of dictionary of values
 */
module.exports = MRUCache;
function MRUCache(length, onRemove) {
    this.max = length;
    this.onRemove = onRemove;
    this.reset();
}

/*
 * Clears the cache
 */
MRUCache.prototype.reset = function() {
    this.list = {};
    this.order = [];

    return this;
};

/*
 * Add a key, value combination to the cache, trimming its size if this pushes
 * it over max length.
 */
MRUCache.prototype.add = function(key, data) {
    this.list[key] = data;
    this.order.push(key);

    if (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
        if (removedData) this.onRemove(removedData);
    }

    return this;
};

/*
 * Determine whether the value attached to `key` is present
 */
MRUCache.prototype.has = function(key) {
    return key in this.list;
};

/*
 * List all keys in the cache
 */
MRUCache.prototype.keys = function() {
    return this.order;
};

/*
 * Get the value attached to a specific key. If the key is not found,
 * returns `null`
 */
MRUCache.prototype.get = function(key) {
    if (!this.has(key)) { return null; }

    var data = this.list[key];

    delete this.list[key];
    this.order.splice(this.order.indexOf(key), 1);

    return data;
};

},{}],84:[function(require,module,exports){
'use strict';

module.exports = resolveTokens;

var tokenPattern = /{([\w-]+)}/;

function resolveTokens(properties, expression) {
    var match;
    var value;
    var text = expression;
    while ((match = text.match(tokenPattern))) {
        value = typeof properties[match[1]] === 'undefined' ? '' : properties[match[1]];
        text = text.replace(match[0], value);
    }
    return text;
}

},{}],85:[function(require,module,exports){
'use strict';

var config = require('./config');

module.exports = function(path, accessToken) {
    accessToken = accessToken || config.ACCESS_TOKEN;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
            'See https://www.mapbox.com/developers/api/#access-tokens');
    }

    var url = ((typeof document !== 'undefined' && 'https:' === document.location.protocol) ||
        config.FORCE_HTTPS) ? config.HTTPS_URL : config.HTTP_URL;
    url += path;
    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
    }

    return url;
};

module.exports.tileJSON = function(mapID, accessToken) {
    var url = module.exports('/' + mapID + '.json', accessToken);

    // TileJSON requests need a secure flag appended to their URLs so
    // that the server knows to send SSL-ified resource references.
    if (url.indexOf('https') === 0)
        url += '&secure';

    console.log("Hello: " + url, mapID);
    return url;
};

},{"./config":79}],86:[function(require,module,exports){
'use strict';

var UnitBezier = require('unitbezier');

exports.easeCubicInOut = function (t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t,
        t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
};

exports.bezier = function(p1x, p1y, p2x, p2y) {
    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
    return function(t) {
        return bezier.solve(t);
    };
};

exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

exports.interp = function (a, b, t) {
    return (a * (1 - t)) + (b * t);
};

exports.premultiply = function (c) {
    c[0] *= c[3];
    c[1] *= c[3];
    c[2] *= c[3];
    return c;
};

exports.asyncEach = function (array, fn, callback) {
    var remaining = array.length;
    if (remaining === 0) return callback();
    function check() { if (--remaining === 0) callback(); }
    for (var i = 0; i < array.length; i++) fn(array[i], check);
};

exports.keysDifference = function (obj, other) {
    var difference = [];
    for (var i in obj) {
        if (!(i in other)) {
            difference.push(i);
        }
    }
    return difference;
};

exports.extend = function (dest, src) {
    for (var i in src) {
        dest[i] = src[i];
    }
    return dest;
};

exports.extendAll = function (dest, src) {
    for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
    }
    return dest;
};

exports.inherit = function (parent, props) {
    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
        proto = Object.create(parentProto);
    exports.extendAll(proto, props);
    return proto;
};

var id = 1;

exports.uniqueId = function () {
    return id++;
};

exports.throttle = function (fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
        // reset lock and call if queued
        lock = false;
        if (args) {
            wrapperFn.apply(context, args);
            args = false;
        }
    };

    wrapperFn = function () {
        if (lock) {
            // called too soon, queue to call later
            args = arguments;

        } else {
            // call and lock until later
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
        }
    };

    return wrapperFn;
};

exports.debounce = function(fn, time) {
    var timer, args;

    return function() {
        args = arguments;
        clearTimeout(timer);

        timer = setTimeout(function() {
            fn.apply(null, args);
        }, time);
    };
};

},{"unitbezier":100}],87:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":88,"ieee754":89}],88:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],89:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],90:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],91:[function(require,module,exports){
var geojsonArea = require('geojson-area');

module.exports = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], !outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}

},{"geojson-area":92}],92:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    if (_.type === 'Polygon') return polygonArea(_.coordinates);
    else if (_.type === 'MultiPolygon') {
        var area = 0;
        for (var i = 0; i < _.coordinates.length; i++) {
            area += polygonArea(_.coordinates[i]);
        }
        return area;
    } else {
        return null;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var area = 0;

    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

},{"wgs84":93}],93:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],94:[function(require,module,exports){
module.exports={
  "$version": 4,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [
        4
      ],
      "doc": "Stylesheet version number. Must be 4."
    },
    "constants": {
      "type": "constants",
      "doc": "An object of constants to be referenced in layers."
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications for layers to pull from."
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "An array of layers. The order of layers coincides with the order they will be drawn."
    },
    "sprite": {
      "type": "sprite",
      "doc": "Sprite definition."
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}."
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties."
    }
  },
  "sprite": [{
    "type": "string",
    "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended."
  }],
  "constants": {
    "*": {
      "type": "*",
      "doc": "A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol."
    }
  },
  "sources": {
    "*": {
      "type": "source"
    }
  },
  "source": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster",
        "geojson",
        "video"
      ],
      "doc": "The data type of the source."
    },
    "url": {
      "required": true,
      "type": "string",
      "doc": "A URL, or URL template to retrive the source data."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "doc": "The minimum visual size (in px) to display tiles for this layer. Only configurable for raster layers."
    },
    "minZoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available."
    },
    "maxZoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available. Data from tiles at the maxZoom are used when displaying the map at higher zoom levels."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name."
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `source`, `source_layer`, `filter`, and `render` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "min-zoom": {
      "type": "number",
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "max-zoom": {
      "type": "number",
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "render": {
      "type": "render",
      "doc": "Symbolizer type that should be used to visualize this layer. If unspecified or null, this layer is not treated as a symbolizer and only exists to have properties inherited to other layers using ref."
    },
    "filter": {
      "type": "filter",
      "doc": "Array or object of filters or expressions."
    },
    "layers": {
      "type": "array",
      "value": "layer",
      "doc": "If `type` is `raster`, the child layers are composited together onto the previous level layer level."
    },
    "style": {
      "type": "class",
      "doc": "Default style properties for this layer."
    },
    "style.*": {
      "type": "class",
      "doc": "Override style properties for this layer. The class name is the part after the first dot."
    }
  },
  "render": [
    "render_fill",
    "render_line",
    "render_symbol",
    "render_raster",
    "render_background"
  ],
  "render_background": {
  },
  "render_fill": {
  },
  "render_line": {
    "line-cap": {
      "type": "enum",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles."
    },
    "line-round-limit": {
      "type": "number",
      "default": 1,
      "doc": "Used to automatically convert round joins to miter joins for shallow angles."
    }
  },
  "render_symbol": {
    "symbol-placement": {
        "type": "enum",
        "values": [
            "point",
            "line"
        ],
        "default": "point",
        "doc": "Placement of a label relative to its geometry. `Line` can only be used on LineStrings and Polygons."
    },
    "symbol-min-distance": {
      "type": "number",
      "default": 250,
      "doc": "Minimum distance between two symbol anchors (px)"
    },
    "symbol-avoid-edges": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the symbols will not cross tile edges. Symbols that cross tile edges may cause collisions in some cases. This property should be set to true if the layer does not have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the icon will be visible even if it collides with other icons and text."
    },
    "icon-ignore-placement": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the icon won't affect placement of other icons and text."
    },
    "icon-optional": {
        "type": "boolean",
        "default": false,
        "doc": "If true, text can be shown without its corresponding icon."
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated"
    },
    "icon-max-size": {
      "type": "number",
      "default": 1,
      "doc": "The maximum amount to scale the icon by."
    },
    "icon-image": {
      "type": "string",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from."
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "doc": "Rotates the icon clockwise by the specified number of degrees."
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "doc": "Padding value around icon bounding box to avoid icon collisions (px)."
    },
    "icon-keep-upright": {
        "type": "boolean",
        "default": false,
        "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down"
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "doc": "Icon's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "text-rotation-alignment": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon or text when map is rotated"
    },
    "text-field": {
      "type": "string",
      "default": "",
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "string",
      "doc": "Font stack to use for displaying text."
    },
    "text-max-size": {
      "type": "number",
      "default": 16,
      "doc": "The maximum size text will be displayed."
    },
    "text-max-width": {
      "type": "number",
      "default": 15,
      "doc": "The maximum line width for text wrapping (em)."
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "doc": "Text leading value for multi-line text."
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "doc": "Text kerning value (em)."
    },
    "text-justify": {
      "type": "enum",
      "values": [
        "center",
        "left",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options."
    },
    "text-horizontal-align": {
      "type": "enum",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Horizontal alignment of the text relative to the anchor."
    },
    "text-vertical-align": {
      "type": "enum",
      "values": [
        "top",
        "center",
        "bottom"
      ],
      "default": "center",
      "doc": "Vertical alignment of the text relative to the anchor."
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "doc": "The maximum angle change, in degrees, allowed between adjacent characters."
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "doc": "Rotates the text clockwise by the specified number of degrees."
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "doc": "Padding value around text bounding box to avoid label collisions (px)."
    },
    "text-keep-upright": {
        "type": "boolean",
        "default": true,
        "doc": "If true, the direction of the text may be flipped to prevent it from being rendered upside-down"
    },
    "text-transform": {
      "type": "enum",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property."
    },
    "text-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other icons and labels."
    },
    "text-ignore-placement": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the text won't affect placement of other icons and labels."
    },
    "text-optional": {
        "type": "boolean",
        "default": false,
        "doc": "If true, icons can be shown without their corresponding text."
    }
  },
  "render_raster": {
    "raster-size": {
      "type": "number",
      "function": true,
      "default": 256,
      "doc": "The texture image size (in pixels) vector layers will be rasterized at. Will automatically by scaled to match the visual tile size."
    },
    "raster-blur": {
      "type": "number",
      "function": true,
      "default": 0,
      "doc": "Blur radius to apply to the raster texture before display."
    }
  },
  "filter": [
    {
      "type": "filter_expression",
      "doc": "Various filter expressions. Unless overridden by parent, these are interpreted as `AND`."
    },
    {
      "type": "array",
      "value": "filter_expression",
      "doc": "Various filter expressions. Unless overridden by parent, these are interpreted as `OR`."
    }
  ],
  "filter_expression": {
    "&": {
      "type": "filter",
      "doc": "AND operator."
    },
    "|": {
      "type": "filter",
      "doc": "OR operator."
    },
    "^": {
      "type": "filter",
      "doc": "XOR operator."
    },
    "!": {
      "type": "filter",
      "doc": "NOR operator."
    },
    "$type": {
      "type": "enum",
      "values": [
        "Point",
        "LineString",
        "Polygon"
      ],
      "doc": "Geometry type that features must match."
    },
    "*": [
      {
        "type": "filter_comparison",
        "doc": "Arbitarily named feature member. A comparison object defining a filter expression."
      },
      {
        "type": "filter_value",
        "doc": "Arbitarily named feature member. A filter_value implies the equality (string/number/boolean) or set membership operator (array)."
      }
    ]
  },
  "filter_comparison": {
    "==": {
      "type": "filter_value",
      "doc": "Equality operator."
    },
    "!=": {
      "type": "filter_value",
      "doc": "Inequality operator."
    },
    ">": {
      "type": "filter_value",
      "doc": "Greater than operator."
    },
    ">=": {
      "type": "filter_value",
      "doc": "Greater or equal than operator."
    },
    "<": {
      "type": "filter_value",
      "doc": "Less than operator."
    },
    "<=": {
      "type": "filter_value",
      "doc": "Less than or equal operator."
    },
    "in": {
      "type": "array",
      "value": "filter_primitive",
      "doc": "Set member operator."
    },
    "!in": {
      "type": "array",
      "value": "filter_primitive",
      "doc": "Not in set operator."
    }
  },
  "filter_value": [
    {
      "type": "filter_primitive"
    },
    {
      "type": "array",
      "value": "filter_primitive"
    }
  ],
  "filter_primitive": [
    {
      "type": "string"
    },
    {
      "type": "number"
    },
    {
      "type": "boolean"
    }
  ],
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    }
  },
  "function_stop": {
    "type": "array",
    "value": ["number", "color"],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "class": [
    "class_fill",
    "class_line",
    "class_symbol",
    "class_raster",
    "class_background"
  ],
  "class_fill": {
    "fill-antialias": {
      "type": "boolean",
      "default": true,
      "function": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": true,
      "default": 1,
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": true,
      "transition": true
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "The geometry's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    },
    "fill-image": {
      "type": "string",
      "doc": "Name of image in sprite to use for drawing image fills."
    }
  },
  "class_line": {
    "line-opacity": {
      "type": "number",
      "function": true,
      "default": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "The geometry's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true,
      "doc": "Line width (in px)"
    },
    "line-offset": {
      "type": "number",
      "default": 0,
      "doc": "Line casing where `line-offset` indicates total width. @TODO rename?",
      "function": true,
      "transition": true
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Line blur, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        1,
        -1
      ],
      "function": true,
      "transition": true
    },
    "line-image": {
      "type": "string",
      "doc": "Name of image in sprite to use for drawing image lines."
    }
  },
  "class_symbol": {
    "icon-opacity": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true,
      "doc": "The amount to scale the icon by. 1 is original size, 3 triples the size."
    },
    "icon-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons."
    },
    "icon-halo-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons."
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "How far away the halo is from the icon outline, in pixels."
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Fade out the halo towards the outside, in pixels."
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "An icon's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "icon-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    },
    "text-opacity": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "function": true,
      "transition": true,
      "doc": "Font size in pixels. If unspecified, the text will be as big as allowed by the layer definition."
    },
    "text-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "text-halo-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        0
      ],
      "function": true,
      "transition": true
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "How far away the halo is from the font outline, in pixels. Max text halo width is 1/4 of the font-size (px)."
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Fade out the halo towards the outside, in pixels."
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "doc": "A label's offset, in pixels. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "text-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map"
    }
  },
  "class_raster": {
    "raster-opacity": {
      "type": "number",
      "default": 1,
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Rotates hues around the color wheel by the specified number of degrees."
    },
    "raster-brightness": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true
    },
    "raster-fade": {
      "type": "number",
      "default": 0,
      "function": true,
      "transition": true,
      "doc": "Duration of the fade when a new tile is added. @TODO rename?"
    }
  },
  "class_background": {
    "background-color": {
      "type": "color",
      "default": [
        0,
        0,
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "background-image": {
      "type": "string"
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "doc": "Time in milliseconds that it takes for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "doc": "Time in milliseconds before a transition begins."
    }
  }
}

},{}],95:[function(require,module,exports){
(function (Buffer){
'use strict';

var ieee754 = require('ieee754');

module.exports = Protobuf;
function Protobuf(buf) {
    this.buf = buf;
    this.pos = 0;
}

Protobuf.prototype = {
    get length() { return this.buf.length; }
};

Protobuf.Varint = 0;
Protobuf.Int64 = 1;
Protobuf.Message = 2;
Protobuf.String = 2;
Protobuf.Packed = 2;
Protobuf.Int32 = 5;

Protobuf.prototype.destroy = function() {
    this.buf = null;
};

// === READING =================================================================

Protobuf.prototype.readUInt32 = function() {
    var val = this.buf.readUInt32LE(this.pos);
    this.pos += 4;
    return val;
};

Protobuf.prototype.readUInt64 = function() {
    var val = this.buf.readUInt64LE(this.pos);
    this.pos += 8;
    return val;
};

Protobuf.prototype.readDouble = function() {
    var val = ieee754.read(this.buf, this.pos, true, 52, 8);
    this.pos += 8;
    return val;
};

Protobuf.prototype.readVarint = function() {
    // TODO: bounds checking
    var pos = this.pos;
    if (this.buf[pos] <= 0x7f) {
        this.pos++;
        return this.buf[pos];
    } else if (this.buf[pos + 1] <= 0x7f) {
        this.pos += 2;
        return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] << 7);
    } else if (this.buf[pos + 2] <= 0x7f) {
        this.pos += 3;
        return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2]) << 14;
    } else if (this.buf[pos + 3] <= 0x7f) {
        this.pos += 4;
        return (this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2] & 0x7f) << 14 | (this.buf[pos + 3]) << 21;
    } else if (this.buf[pos + 4] <= 0x7f) {
        this.pos += 5;
        return ((this.buf[pos] & 0x7f) | (this.buf[pos + 1] & 0x7f) << 7 | (this.buf[pos + 2] & 0x7f) << 14 | (this.buf[pos + 3]) << 21) + (this.buf[pos + 4] * 268435456);
    } else {
        this.skip(Protobuf.Varint);
        return 0;
        // throw new Error("TODO: Handle 6+ byte varints");
    }
};

Protobuf.prototype.readSVarint = function() {
    var num = this.readVarint();
    if (num > 2147483647) throw new Error('TODO: Handle numbers >= 2^30');
    // zigzag encoding
    return ((num >> 1) ^ -(num & 1));
};

Protobuf.prototype.readString = function() {
    var bytes = this.readVarint();
    // TODO: bounds checking
    var chr = String.fromCharCode;
    var b = this.buf;
    var p = this.pos;
    var end = this.pos + bytes;
    var str = '';
    while (p < end) {
        if (b[p] <= 0x7F) str += chr(b[p++]);
        else if (b[p] <= 0xBF) throw new Error('Invalid UTF-8 codepoint: ' + b[p]);
        else if (b[p] <= 0xDF) str += chr((b[p++] & 0x1F) << 6 | (b[p++] & 0x3F));
        else if (b[p] <= 0xEF) str += chr((b[p++] & 0x1F) << 12 | (b[p++] & 0x3F) << 6 | (b[p++] & 0x3F));
        else if (b[p] <= 0xF7) p += 4; // We can't handle these codepoints in JS, so skip.
        else if (b[p] <= 0xFB) p += 5;
        else if (b[p] <= 0xFD) p += 6;
        else throw new Error('Invalid UTF-8 codepoint: ' + b[p]);
    }
    this.pos += bytes;
    return str;
};

Protobuf.prototype.readBuffer = function() {
    var bytes = this.readVarint();
    var buffer = this.buf.subarray(this.pos, this.pos + bytes);
    this.pos += bytes;
    return buffer;
};

Protobuf.prototype.readPacked = function(type) {
    // TODO: bounds checking
    var bytes = this.readVarint();
    var end = this.pos + bytes;
    var array = [];
    while (this.pos < end) {
        array.push(this['read' + type]());
    }
    return array;
};

Protobuf.prototype.skip = function(val) {
    // TODO: bounds checking
    var type = val & 0x7;
    switch (type) {
        /* varint */ case Protobuf.Varint: while (this.buf[this.pos++] > 0x7f); break;
        /* 64 bit */ case Protobuf.Int64: this.pos += 8; break;
        /* length */ case Protobuf.Message: var bytes = this.readVarint(); this.pos += bytes; break;
        /* 32 bit */ case Protobuf.Int32: this.pos += 4; break;
        default: throw new Error('Unimplemented type: ' + type);
    }
};

// === WRITING =================================================================

Protobuf.prototype.writeTag = function(tag, type) {
    this.writeVarint((tag << 3) | type);
};

Protobuf.prototype.realloc = function(min) {
    var length = this.buf.length;
    while (length < this.pos + min) length *= 2;
    if (length != this.buf.length) {
        var buf = new Buffer(length);
        this.buf.copy(buf);
        this.buf = buf;
    }
};

Protobuf.prototype.finish = function() {
    return this.buf.slice(0, this.pos);
};

Protobuf.prototype.writePacked = function(type, tag, items) {
    if (!items.length) return;

    var message = new Protobuf();
    for (var i = 0; i < items.length; i++) {
        message['write' + type](items[i]);
    }
    var data = message.finish();

    this.writeTag(tag, Protobuf.Packed);
    this.writeBuffer(data);
};

Protobuf.prototype.writeUInt32 = function(val) {
    this.realloc(4);
    this.buf.writeUInt32LE(val, this.pos);
    this.pos += 4;
};

Protobuf.prototype.writeTaggedUInt32 = function(tag, val) {
    this.writeTag(tag, Protobuf.Int32);
    this.writeUInt32(val);
};

Protobuf.prototype.writeVarint = function(val) {
    val = Number(val);
    if (isNaN(val)) {
        val = 0;
    }

    if (val <= 0x7f) {
        this.realloc(1);
        this.buf[this.pos++] = val;
    } else if (val <= 0x3fff) {
        this.realloc(2);
        this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
        this.buf[this.pos++] = 0x00 | ((val >>> 7) & 0x7f);
    } else if (val <= 0x1ffffff) {
        this.realloc(3);
        this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
        this.buf[this.pos++] = 0x80 | ((val >>> 7) & 0x7f);
        this.buf[this.pos++] = 0x00 | ((val >>> 14) & 0x7f);
    } else if (val <= 0xfffffff) {
        this.realloc(4);
        this.buf[this.pos++] = 0x80 | ((val >>> 0) & 0x7f);
        this.buf[this.pos++] = 0x80 | ((val >>> 7) & 0x7f);
        this.buf[this.pos++] = 0x80 | ((val >>> 14) & 0x7f);
        this.buf[this.pos++] = 0x00 | ((val >>> 21) & 0x7f);
    } else {
        while (val > 0) {
            var b = val & 0x7f;
            val = Math.floor(val / 128);
            if (val > 0) b |= 0x80
            this.realloc(1);
            this.buf[this.pos++] = b;
        }
    }
};

Protobuf.prototype.writeTaggedVarint = function(tag, val) {
    this.writeTag(tag, Protobuf.Varint);
    this.writeVarint(val);
};

Protobuf.prototype.writeSVarint = function(val) {
    if (val >= 0) {
        this.writeVarint(val * 2);
    } else {
        this.writeVarint(val * -2 - 1);
    }
};

Protobuf.prototype.writeTaggedSVarint = function(tag, val) {
    this.writeTag(tag, Protobuf.Varint);
    this.writeSVarint(val);
};

Protobuf.prototype.writeBoolean = function(val) {
    this.writeVarint(Boolean(val));
};

Protobuf.prototype.writeTaggedBoolean = function(tag, val) {
    this.writeTaggedVarint(tag, Boolean(val));
};

Protobuf.prototype.writeString = function(str) {
    str = String(str);
    var bytes = Buffer.byteLength(str);
    this.writeVarint(bytes);
    this.realloc(bytes);
    this.buf.write(str, this.pos);
    this.pos += bytes;
};

Protobuf.prototype.writeTaggedString = function(tag, str) {
    this.writeTag(tag, Protobuf.String);
    this.writeString(str);
};

Protobuf.prototype.writeFloat = function(val) {
    this.realloc(4);
    this.buf.writeFloatLE(val, this.pos);
    this.pos += 4;
};

Protobuf.prototype.writeTaggedFloat = function(tag, val) {
    this.writeTag(tag, Protobuf.Int32);
    this.writeFloat(val);
};

Protobuf.prototype.writeDouble = function(val) {
    this.realloc(8);
    this.buf.writeDoubleLE(val, this.pos);
    this.pos += 8;
};

Protobuf.prototype.writeTaggedDouble = function(tag, val) {
    this.writeTag(tag, Protobuf.Int64);
    this.writeDouble(val);
};

Protobuf.prototype.writeBuffer = function(buffer) {
    var bytes = buffer.length;
    this.writeVarint(bytes);
    this.realloc(bytes);
    buffer.copy(this.buf, this.pos);
    this.pos += bytes;
};

Protobuf.prototype.writeTaggedBuffer = function(tag, buffer) {
    this.writeTag(tag, Protobuf.String);
    this.writeBuffer(buffer);
};

Protobuf.prototype.writeMessage = function(tag, protobuf) {
    var buffer = protobuf.finish();
    this.writeTag(tag, Protobuf.Message);
    this.writeBuffer(buffer);
};

}).call(this,require("buffer").Buffer)
},{"buffer":87,"ieee754":96}],96:[function(require,module,exports){
module.exports=require(89)
},{}],97:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],98:[function(require,module,exports){
(function() {
  var slice = [].slice;

  function queue(parallelism) {
    var q,
        tasks = [],
        started = 0, // number of tasks that have been started (and perhaps finished)
        active = 0, // number of tasks currently being executed (started but not finished)
        remaining = 0, // number of tasks not yet finished
        popping, // inside a synchronous task callback?
        error = null,
        await = noop,
        all;

    if (!parallelism) parallelism = Infinity;

    function pop() {
      while (popping = started < tasks.length && active < parallelism) {
        var i = started++,
            t = tasks[i],
            a = slice.call(t, 1);
        a.push(callback(i));
        ++active;
        t[0].apply(null, a);
      }
    }

    function callback(i) {
      return function(e, r) {
        --active;
        if (error != null) return;
        if (e != null) {
          error = e; // ignore new tasks and squelch active callbacks
          started = remaining = NaN; // stop queued tasks from starting
          notify();
        } else {
          tasks[i] = r;
          if (--remaining) popping || pop();
          else notify();
        }
      };
    }

    function notify() {
      if (error != null) await(error);
      else if (all) await(error, tasks);
      else await.apply(null, [error].concat(tasks));
    }

    return q = {
      defer: function() {
        if (!error) {
          tasks.push(arguments);
          ++remaining;
          pop();
        }
        return q;
      },
      await: function(f) {
        await = f;
        all = false;
        if (!remaining) notify();
        return q;
      },
      awaitAll: function(f) {
        await = f;
        all = true;
        if (!remaining) notify();
        return q;
      }
    };
  }

  function noop() {}

  queue.version = "1.0.7";
  if (typeof define === "function" && define.amd) define(function() { return queue; });
  else if (typeof module === "object" && module.exports) module.exports = queue;
  else this.queue = queue;
})();

},{}],99:[function(require,module,exports){
/*
 (c) 2013, Vladimir Agafonkin
 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
 https://github.com/mourner/rbush
*/

(function () { 'use strict';

function rbush(maxEntries, format) {

    // jshint newcap: false, validthis: true
    if (!(this instanceof rbush)) { return new rbush(maxEntries, format); }

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [];

        if (!this._intersects(bbox, node.bbox)) { return result; }

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                childBBox = node.leaf ? this.toBBox(child) : child.bbox;

                if (this._intersects(bbox, childBBox)) {

                    if (node.leaf) {
                        result.push(child);

                    } else if (this._contains(bbox, childBBox)) {
                        this._all(child, result);

                    } else {
                        nodesToSearch.push(child);
                    }
                }
            }

            node = nodesToSearch.pop();
        }

        return result;
    },

    load: function (data) {
        if (!(data && data.length)) { return this; }

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) {
            this._insert(item, this.data.height - 1);
        }
        return this;
    },

    clear: function () {
        this.data = {
            children: [],
            leaf: true,
            bbox: this._empty(),
            height: 1
        };
        return this;
    },

    remove: function (item) {
        if (!item) { return this; }

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = node.children.indexOf(item);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && this._contains(node.bbox, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else { // nothing found
                node = null;
            }
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: function (a, b) { return a[0] - b[0]; },
    compareMinY: function (a, b) { return a[1] - b[1]; },

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) {
                result.push.apply(result, node.children);
            } else {
                nodesToSearch.push.apply(nodesToSearch, node.children);
            }
            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, level, height) {

        var N = items.length,
            M = this._maxEntries,
            node;

        if (N <= M) {
            node = {
                children: items,
                leaf: true,
                height: 1
            };
            this._calcBBox(node);
            return node;
        }

        if (!level) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));

            items.sort(this.compareMinX);
        }

        // TODO eliminate recursion?

        node = {
            children: [],
            height: height
        };

        var N1 = Math.ceil(N / M) * Math.ceil(Math.sqrt(M)),
            N2 = Math.ceil(N / M),
            compare = level % 2 === 1 ? this.compareMinX : this.compareMinY,
            i, j, slice, sliceLen, childNode;

        // split the items into M mostly square tiles
        for (i = 0; i < N; i += N1) {
            slice = items.slice(i, i + N1).sort(compare);

            for (j = 0, sliceLen = slice.length; j < sliceLen; j += N2) {
                // pack each entry recursively
                childNode = this._build(slice.slice(j, j + N2), level + 1, height - 1);
                node.children.push(childNode);
            }
        }

        this._calcBBox(node);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) { break; }

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = this._area(child.bbox);
                enlargement = this._enlargedArea(bbox, child.bbox) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode;
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var bbox = isNode ? item.bbox : this.toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        this._extend(node.bbox, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else {
              break;
            }
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var newNode = {
            children: node.children.splice(this._chooseSplitIndex(node, m, M)),
            height: node.height
        };

        if (node.leaf) {
            newNode.leaf = true;
        }

        this._calcBBox(node);
        this._calcBBox(newNode);

        if (level) {
            insertPath[level - 1].children.push(newNode);
        } else {
            this._splitRoot(node, newNode);
        }
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = {};
        this.data.children = [node, newNode];
        this.data.height = node.height + 1;
        this._calcBBox(this.data);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = this._distBBox(node, 0, i);
            bbox2 = this._distBBox(node, i, M);

            overlap = this._intersectionArea(bbox1, bbox2);
            area = this._area(bbox1) + this._area(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : this._compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : this._compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY

        if (xMargin < yMargin) {
            node.children.sort(compareMinX);
        }
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var leftBBox = this._distBBox(node, 0, m),
            rightBBox = this._distBBox(node, M - m, M),
            margin = this._margin(leftBBox) + this._margin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            this._extend(leftBBox, node.leaf ? this.toBBox(child) : child.bbox);
            margin += this._margin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            this._extend(rightBBox, node.leaf ? this.toBBox(child) : child.bbox);
            margin += this._margin(rightBBox);
        }

        return margin;
    },

    // min bounding rectangle of node children from k to p-1
    _distBBox: function (node, k, p) {
        var bbox = this._empty();

        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            this._extend(bbox, node.leaf ? this.toBBox(child) : child.bbox);
        }

        return bbox;
    },

    // calculate node's bbox from bboxes of its children
    _calcBBox: function (node) {
        node.bbox = this._distBBox(node, 0, node.children.length);
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            this._extend(path[i].bbox, bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, parent; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    parent = path[i - 1].children;
                    parent.splice(parent.indexOf(path[i]), 1);
                } else {
                    this.clear();
                }
            } else {
                this._calcBBox(path[i]);
            }
        }
    },

    _contains: function(a, b) {
        return a[0] <= b[0] &&
               a[1] <= b[1] &&
               b[2] <= a[2] &&
               b[3] <= a[3];
    },

    _intersects: function (a, b) {
        return b[0] <= a[2] &&
               b[1] <= a[3] &&
               b[2] >= a[0] &&
               b[3] >= a[1];
    },

    _extend: function (a, b) {
        a[0] = Math.min(a[0], b[0]);
        a[1] = Math.min(a[1], b[1]);
        a[2] = Math.max(a[2], b[2]);
        a[3] = Math.max(a[3], b[3]);
        return a;
    },

    _area:   function (a) { return (a[2] - a[0]) * (a[3] - a[1]); },
    _margin: function (a) { return (a[2] - a[0]) + (a[3] - a[1]); },

    _enlargedArea: function (a, b) {
        return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
               (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
    },

    _intersectionArea: function (a, b) {
        var minX = Math.max(a[0], b[0]),
            minY = Math.max(a[1], b[1]),
            maxX = Math.min(a[2], b[2]),
            maxY = Math.min(a[3], b[3]);

        return Math.max(0, maxX - minX) *
               Math.max(0, maxY - minY);
    },

    _empty: function () { return [Infinity, Infinity, -Infinity, -Infinity]; },

    _compareNodeMinX: function (a, b) { return a.bbox[0] - b.bbox[0]; },
    _compareNodeMinY: function (a, b) { return a.bbox[1] - b.bbox[1]; },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        // jshint evil: true

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
    }
};

if (typeof define === 'function' && define.amd) {
    define(function() {
        return rbush;
    });
} else if (typeof module !== 'undefined') {
    module.exports = rbush;
} else if (typeof self !== 'undefined') {
    self.rbush = rbush;
} else {
    window.rbush = rbush;
}

})();

},{}],100:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],101:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":102,"./lib/vectortilefeature.js":103,"./lib/vectortilelayer.js":104}],102:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(buffer, end) {
    console.log("Building vector tile: " + buffer);
    this.layers = {};
    this._buffer = buffer;

    end = end || buffer.length;

    while (buffer.pos < end) {
        var val = buffer.readVarint(),
            tag = val >> 3;

        if (tag == 3) {
            var layer = this.readLayer();
            if (layer.length) this.layers[layer.name] = layer;
        } else {
            buffer.skip(val);
        }
    }
}

VectorTile.prototype.readLayer = function() {
    var buffer = this._buffer,
        bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        layer = new VectorTileLayer(buffer, end);

    buffer.pos = end;

    return layer;
};

},{"./vectortilelayer":104}],103:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(buffer, end, extent, keys, values) {

    this.properties = {};

    // Public
    this.extent = extent;
    this.type = 0;

    // Private
    this._buffer = buffer;
    this._geometry = -1;

    end = end || buffer.length;

    while (buffer.pos < end) {
        var val = buffer.readVarint(),
            tag = val >> 3;

        if (tag == 1) {
            this._id = buffer.readVarint();

        } else if (tag == 2) {
            var tagEnd = buffer.pos + buffer.readVarint();

            while (buffer.pos < tagEnd) {
                var key = keys[buffer.readVarint()];
                var value = values[buffer.readVarint()];
                this.properties[key] = value;
            }

        } else if (tag == 3) {
            this.type = buffer.readVarint();

        } else if (tag == 4) {
            this._geometry = buffer.pos;
            buffer.skip(val);

        } else {
            buffer.skip(val);
        }
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var buffer = this._buffer;
    buffer.pos = this._geometry;

    var bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (buffer.pos < end) {
        if (!length) {
            var cmd_length = buffer.readVarint();
            cmd = cmd_length & 0x7;
            length = cmd_length >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += buffer.readSVarint();
            y += buffer.readSVarint();

            if (cmd === 1) {
                // moveTo
                if (line) {
                    lines.push(line);
                }
                line = [];
            }

            line.push(new Point(x, y));
        } else if (cmd === 7) {
            // closePolygon
            line.push(line[0].clone());
        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var buffer = this._buffer;
    buffer.pos = this._geometry;

    var bytes = buffer.readVarint(),
        end = buffer.pos + bytes,

        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (buffer.pos < end) {
        if (!length) {
            var cmd_length = buffer.readVarint();
            cmd = cmd_length & 0x7;
            length = cmd_length >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += buffer.readSVarint();
            y += buffer.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

},{"point-geometry":97}],104:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;
function VectorTileLayer(buffer, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._buffer = buffer;
    this._keys = [];
    this._values = [];
    this._features = [];

    var val, tag;

    end = end || buffer.length;

    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag === 15) {
            this.version = buffer.readVarint();
        } else if (tag === 1) {
            this.name = buffer.readString();
        } else if (tag === 5) {
            this.extent = buffer.readVarint();
        } else if (tag === 2) {
            this.length++;
            this._features.push(buffer.pos);
            buffer.skip(val);

        } else if (tag === 3) {
            this._keys.push(buffer.readString());
        } else if (tag === 4) {
            this._values.push(this.readFeatureValue());
        } else {
            buffer.skip(val);
        }
    }
}

VectorTileLayer.prototype.readFeatureValue = function() {
    var buffer = this._buffer,
        value = null,
        bytes = buffer.readVarint(),
        end = buffer.pos + bytes,
        val, tag;

    while (buffer.pos < end) {
        val = buffer.readVarint();
        tag = val >> 3;

        if (tag == 1) {
            value = buffer.readString();
        } else if (tag == 2) {
            throw new Error('read float');
        } else if (tag == 3) {
            value = buffer.readDouble();
        } else if (tag == 4) {
            value = buffer.readVarint();
        } else if (tag == 5) {
            throw new Error('read uint');
        } else if (tag == 6) {
            value = buffer.readSVarint();
        } else if (tag == 7) {
            value = Boolean(buffer.readVarint());
        } else {
            buffer.skip(val);
        }
    }

    return value;
};

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._buffer.pos = this._features[i];
    var end = this._buffer.readVarint() + this._buffer.pos;

    return new VectorTileFeature(this._buffer, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":103}]},{},[22])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvYnVmZmVyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9idWZmZXJzZXQuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2ZpbGxlbGVtZW50c2J1ZmZlci5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZmlsbHZlcnRleGJ1ZmZlci5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZ2x5cGh2ZXJ0ZXhidWZmZXIuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2ljb252ZXJ0ZXhidWZmZXIuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2xpbmVlbGVtZW50YnVmZmVyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9saW5ldmVydGV4YnVmZmVyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9vdXRsaW5lZWxlbWVudHNidWZmZXIuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2RhdGEvY3JlYXRlYnVja2V0LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9kYXRhL2VsZW1lbnRncm91cHMuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2RhdGEvZmVhdHVyZXRyZWUuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2RhdGEvZmlsbGJ1Y2tldC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvZGF0YS9saW5lYnVja2V0LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9kYXRhL3Jhc3RlcmJ1Y2tldC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvZGF0YS9zeW1ib2xidWNrZXQuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2dlby9sYXRsbmcuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2dlby9sYXRsbmdib3VuZHMuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2dlby90cmFuc2Zvcm0uanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2xpYi9kZWJ1Z3RleHQuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL2xpYi9nbG1hdHJpeC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvbWFwYm94LWdsLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd2JhY2tncm91bmQuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3ZGVidWcuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3ZmlsbC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdsaW5lLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd3Jhc3Rlci5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdzeW1ib2wuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3dmVydGljZXMuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9mcmFtZWhpc3RvcnkuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9nbHV0aWwuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9wYWludGVyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvcHJlcmVuZGVyZWQuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3JlbmRlci9zaGFkZXJzLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbnNvdXJjZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc291cmNlL2dlb2pzb250aWxlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbndyYXBwZXIuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3NvdXJjZS9yYXN0ZXJ0aWxlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2Uvc291cmNlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdGlsZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc291cmNlL3RpbGVjb29yZC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc291cmNlL3RpbGVnZW9qc29uLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdmVjdG9ydGlsZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc291cmNlL3ZpZGVvc291cmNlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2Uvd29ya2VyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zb3VyY2Uvd29ya2VydGlsZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3R5bGUvYW5pbWF0aW9ubG9vcC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3R5bGUvYnVja2V0ZmlsdGVyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zdHlsZS9jYWxjdWxhdGVkc3R5bGUuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3N0eWxlL2ltYWdlc3ByaXRlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zdHlsZS9yZW5kZXJwcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3R5bGUvc3R5bGVjb25zdGFudC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3R5bGUvc3R5bGVkZWNsYXJhdGlvbi5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3R5bGUvc3R5bGV0cmFuc2l0aW9uLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvYW5jaG9yLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvYmlucGFjay5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2NvbGxpc2lvbi5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2dseXBoYXRsYXMuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9nbHlwaHNvdXJjZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2ludGVycG9sYXRlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvcGxhY2VtZW50LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvcmVzb2x2ZXRleHQuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9yb3RhdGlvbnJhbmdlLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvc2hhcGluZy5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9hdHRyaWJ1dGlvbi5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9jb250cm9sLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91aS9jb250cm9sL25hdmlnYXRpb24uanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3VpL2Vhc2luZ3MuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3VpL2hhbmRsZXJzLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91aS9oYXNoLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91aS9pbnRlcmFjdGlvbi5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvdWkvbWFwLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91dGlsL2FjdG9yLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91dGlsL2Jyb3dzZXIvYWpheC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3V0aWwvYnJvd3Nlci9jYW52YXMuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3V0aWwvYnJvd3Nlci9kaXNwYXRjaGVyLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91dGlsL2NvbmZpZy5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvdXRpbC9kb20uanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3V0aWwvZXZlbnRlZC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvanMvdXRpbC9nbHlwaHMuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3V0aWwvbXJ1Y2FjaGUuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3V0aWwvdG9rZW4uanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL2pzL3V0aWwvdXJsLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9qcy91dGlsL3V0aWwuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvY3NzY29sb3JwYXJzZXIvY3NzY29sb3JwYXJzZXIuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9pbmRleC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL25vZGVfbW9kdWxlcy9nZW9qc29uLWFyZWEvaW5kZXguanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9ub2RlX21vZHVsZXMvZ2VvanNvbi1hcmVhL25vZGVfbW9kdWxlcy93Z3M4NC9pbmRleC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92NC5qc29uIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvcGJmL2luZGV4LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvcG9pbnQtZ2VvbWV0cnkvaW5kZXguanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9xdWV1ZS1hc3luYy9xdWV1ZS5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3JidXNoL3JidXNoLmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvdW5pdGJlemllci9pbmRleC5qcyIsIi9Vc2Vycy9raXJpbC9ub2RlanMvTllDLUdyb3d0aC9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwiL1VzZXJzL2tpcmlsL25vZGVqcy9OWUMtR3Jvd3RoL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGUuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMiLCIvVXNlcnMva2lyaWwvbm9kZWpzL05ZQy1Hcm93dGgvbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBhIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCBhIHNpbmdsZSBhcnJheWJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcblxuZnVuY3Rpb24gQnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5kZWZhdWx0TGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmRlZmF1bHRMZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0dXBWaWV3cygpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2Ugb25seSByZWNyZWF0ZSBidWZmZXJzIGFmdGVyIHJlY2VpdmluZyB0aGVtIGZyb20gd29ya2VycyBmb3IgYmluZGluZyB0byBnbCxcbiAgICAgICAgLy8gc28gd2Ugb25seSBuZWVkIHRoZXNlIDIgcHJvcGVydGllc1xuICAgICAgICB0aGlzLmFycmF5ID0gYnVmZmVyLmFycmF5O1xuICAgICAgICB0aGlzLnBvcyA9IGJ1ZmZlci5wb3M7XG4gICAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlID0ge1xuICAgIHBvczogMCxcbiAgICBpdGVtU2l6ZTogNCwgLy8gYnl0ZXMgaW4gb25lIGl0ZW1cbiAgICBkZWZhdWx0TGVuZ3RoOiA4MTkyLCAvLyBpbml0aWFsIGJ1ZmZlciBzaXplXG4gICAgYXJyYXlUeXBlOiAnQVJSQVlfQlVGRkVSJywgLy8gZ2wgYnVmZmVyIHR5cGVcblxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zIC8gdGhpcy5pdGVtU2l6ZTtcbiAgICB9LFxuXG4gICAgc2V0dXBWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNldCB1cCB2aWV3cyBmb3IgZWFjaCB0eXBlIHRvIGFkZCBkYXRhIG9mIGRpZmZlcmVudCB0eXBlcyB0byB0aGUgc2FtZSBidWZmZXJcbiAgICAgICAgdGhpcy51Ynl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5KTtcbiAgICAgICAgdGhpcy5ieXRlcyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5hcnJheSk7XG4gICAgICAgIHRoaXMudXNob3J0cyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5KTtcbiAgICAgICAgdGhpcy5zaG9ydHMgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5KTtcbiAgICB9LFxuXG4gICAgLy8gYmluZHMgdGhlIGJ1ZmZlciB0byBhIHdlYmdsIGNvbnRleHRcbiAgICBiaW5kOiBmdW5jdGlvbihnbCkge1xuICAgICAgICB2YXIgdHlwZSA9IGdsW3RoaXMuYXJyYXlUeXBlXTtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIodHlwZSwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBuZXcgRGF0YVZpZXcodGhpcy5hcnJheSwgMCwgdGhpcy5wb3MpLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgICAgIC8vIGR1bXAgYXJyYXkgYnVmZmVyIG9uY2UgaXQncyBib3VuZCB0byBnbFxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbihnbCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlciBzaXplIGJ5IDUwJSBpZiBhIG5ldyBpdGVtIGRvZXNuJ3QgZml0XG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy5wb3MgKyB0aGlzLml0ZW1TaXplKSB7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHRoaXMucG9zICsgdGhpcy5pdGVtU2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsZW5ndGggYnkgNTAlIGJ1dCBrZWVwIGl0IGV2ZW5cbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgucm91bmQodGhpcy5sZW5ndGggKiAxLjUgLyAyKSAqIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFycmF5IGJ1ZmZlcnMgY2FuJ3QgYmUgcmVzaXplZCwgc28gd2UgY3JlYXRlIGEgbmV3IG9uZSBhbmQgcmVzZXQgYWxsIGJ5dGVzIHRoZXJlXG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEFycmF5QnVmZmVyKHRoaXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHVieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICAgICAgdWJ5dGVzLnNldCh0aGlzLnVieXRlcyk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0dXBWaWV3cygpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExpbmVWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2xpbmV2ZXJ0ZXhidWZmZXIuanMnKTtcbnZhciBMaW5lRWxlbWVudEJ1ZmZlciA9IHJlcXVpcmUoJy4vbGluZWVsZW1lbnRidWZmZXIuanMnKTtcbnZhciBGaWxsVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi9maWxsdmVydGV4YnVmZmVyLmpzJyk7XG52YXIgRmlsbEVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL2ZpbGxlbGVtZW50c2J1ZmZlci5qcycpO1xudmFyIE91dGxpbmVFbGVtZW50QnVmZmVyID0gcmVxdWlyZSgnLi9vdXRsaW5lZWxlbWVudHNidWZmZXIuanMnKTtcbnZhciBHbHlwaFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vZ2x5cGh2ZXJ0ZXhidWZmZXIuanMnKTtcbnZhciBJY29uVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi9pY29udmVydGV4YnVmZmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYnVmZmVyc2V0KSB7XG4gICAgYnVmZmVyc2V0ID0gYnVmZmVyc2V0IHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGdseXBoVmVydGV4OiBuZXcgR2x5cGhWZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0LmdseXBoVmVydGV4KSxcbiAgICAgICAgaWNvblZlcnRleDogbmV3IEljb25WZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0Lmljb25WZXJ0ZXgpLFxuICAgICAgICBmaWxsVmVydGV4OiBuZXcgRmlsbFZlcnRleEJ1ZmZlcihidWZmZXJzZXQuZmlsbFZlcnRleCksXG4gICAgICAgIGZpbGxFbGVtZW50OiBuZXcgRmlsbEVsZW1lbnRCdWZmZXIoYnVmZmVyc2V0LmZpbGxFbGVtZW50KSxcbiAgICAgICAgb3V0bGluZUVsZW1lbnQ6IG5ldyBPdXRsaW5lRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQub3V0bGluZUVsZW1lbnQpLFxuICAgICAgICBsaW5lVmVydGV4OiBuZXcgTGluZVZlcnRleEJ1ZmZlcihidWZmZXJzZXQubGluZVZlcnRleCksXG4gICAgICAgIGxpbmVFbGVtZW50OiBuZXcgTGluZUVsZW1lbnRCdWZmZXIoYnVmZmVyc2V0LmxpbmVFbGVtZW50KVxuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsRWxlbWVudHNCdWZmZXI7XG5cbmZ1bmN0aW9uIEZpbGxFbGVtZW50c0J1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5GaWxsRWxlbWVudHNCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcblxuRmlsbEVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZS5pdGVtU2l6ZSA9IDY7IC8vIGJ5dGVzIHBlciB0cmlhbmdsZSAoMyAqIHVuc2lnbmVkIHNob3J0ID09IDYgYnl0ZXMpXG5GaWxsRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFycmF5VHlwZSA9ICdFTEVNRU5UX0FSUkFZX0JVRkZFUic7XG5cbkZpbGxFbGVtZW50c0J1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMudXNob3J0c1twb3MyICsgMF0gPSBhO1xuICAgIHRoaXMudXNob3J0c1twb3MyICsgMV0gPSBiO1xuICAgIHRoaXMudXNob3J0c1twb3MyICsgMl0gPSBjO1xuXG4gICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxWZXJ0ZXhCdWZmZXI7XG5cbmZ1bmN0aW9uIEZpbGxWZXJ0ZXhCdWZmZXIoYnVmZmVyKSB7XG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcbn1cblxuRmlsbFZlcnRleEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpO1xuXG5GaWxsVmVydGV4QnVmZmVyLnByb3RvdHlwZS5pdGVtU2l6ZSA9IDQ7IC8vIGJ5dGVzIHBlciB2ZXJ0ZXggKDIgKiBzaG9ydCA9PSA0IGJ5dGVzKVxuXG5GaWxsVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHBvczIgPSB0aGlzLnBvcyAvIDI7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0geDtcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSB5O1xuXG4gICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBHbHlwaFZlcnRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpO1xuXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZGVmYXVsdExlbmd0aCA9IDIwNDggKiAxNjtcbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZS5pdGVtU2l6ZSA9IDE2O1xuXG4vLyBDb252ZXJ0cyB0aGUgMC4uMnBpIHRvIGFuIGludDE2IHJhbmdlXG5HbHlwaFZlcnRleEJ1ZmZlci5hbmdsZUZhY3RvciA9IDEyOCAvIE1hdGguUEk7XG5cbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5LCBveCwgb3ksIHR4LCB0eSwgYW5nbGUsIG1pbnpvb20sIHJhbmdlLCBtYXh6b29tLCBsYWJlbG1pbnpvb20pIHtcbiAgICB2YXIgcG9zID0gdGhpcy5wb3MsXG4gICAgICAgIHBvczIgPSBwb3MgLyAyLFxuICAgICAgICBhbmdsZUZhY3RvciA9IEdseXBoVmVydGV4QnVmZmVyLmFuZ2xlRmFjdG9yO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IHg7XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0geTtcbiAgICB0aGlzLnNob3J0c1twb3MyICsgMl0gPSBNYXRoLnJvdW5kKG94ICogNjQpOyAvLyB1c2UgMS82NCBwaXhlbHMgZm9yIHBsYWNlbWVudFxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAzXSA9IE1hdGgucm91bmQob3kgKiA2NCk7XG5cbiAgICB0aGlzLnVieXRlc1twb3MgKyA4XSA9IE1hdGguZmxvb3IoKGxhYmVsbWluem9vbSB8fCAwKSAqIDEwKTtcbiAgICB0aGlzLnVieXRlc1twb3MgKyA5XSA9IE1hdGguZmxvb3IoKG1pbnpvb20gfHwgMCkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTBdID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXh6b29tIHx8IDI1LCAyNSkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTFdID0gTWF0aC5yb3VuZChhbmdsZSAqIGFuZ2xlRmFjdG9yKSAlIDI1NjtcbiAgICB0aGlzLnVieXRlc1twb3MgKyAxMl0gPSBNYXRoLm1heChNYXRoLnJvdW5kKHJhbmdlWzBdICogYW5nbGVGYWN0b3IpLCAwKSAlIDI1NjtcbiAgICB0aGlzLnVieXRlc1twb3MgKyAxM10gPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJhbmdlWzFdICogYW5nbGVGYWN0b3IpLCAyNTUpICUgMjU2O1xuXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTRdID0gTWF0aC5mbG9vcih0eCAvIDQpO1xuICAgIHRoaXMudWJ5dGVzW3BvcyArIDE1XSA9IE1hdGguZmxvb3IodHkgLyA0KTtcblxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gR2x5cGhWZXJ0ZXhCdWZmZXIoYnVmZmVyKSB7XG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcbn1cblxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcblxuR2x5cGhWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmRlZmF1bHRMZW5ndGggPSAyMDQ4ICogMjA7XG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSAyMDtcblxuLy8gQ29udmVydHMgdGhlIDAuLjJwaSB0byBhbiBpbnQxNiByYW5nZVxuR2x5cGhWZXJ0ZXhCdWZmZXIuYW5nbGVGYWN0b3IgPSAxMjggLyBNYXRoLlBJO1xuXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oeCwgeSwgb3gsIG95LCB0eCwgdHksIGFuZ2xlLCBtaW56b29tLCByYW5nZSwgbWF4em9vbSwgbGFiZWxtaW56b29tKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zLFxuICAgICAgICBwb3MyID0gcG9zIC8gMixcbiAgICAgICAgYW5nbGVGYWN0b3IgPSBHbHlwaFZlcnRleEJ1ZmZlci5hbmdsZUZhY3RvcjtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSB4O1xuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAxXSA9IHk7XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChveCAqIDY0KTsgLy8gdXNlIDEvNjQgcGl4ZWxzIGZvciBwbGFjZW1lbnRcbiAgICB0aGlzLnNob3J0c1twb3MyICsgM10gPSBNYXRoLnJvdW5kKG95ICogNjQpO1xuXG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgOF0gPSBNYXRoLmZsb29yKChsYWJlbG1pbnpvb20gfHwgMCkgKiAxMCk7XG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgOV0gPSBNYXRoLmZsb29yKChtaW56b29tIHx8IDApICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDEwXSA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4em9vbSB8fCAyNSwgMjUpICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuICAgIHRoaXMudWJ5dGVzW3BvcyArIDExXSA9IE1hdGgucm91bmQoYW5nbGUgKiBhbmdsZUZhY3RvcikgJSAyNTY7XG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTJdID0gTWF0aC5tYXgoTWF0aC5yb3VuZChyYW5nZVswXSAqIGFuZ2xlRmFjdG9yKSwgMCkgJSAyNTY7XG4gICAgdGhpcy51Ynl0ZXNbcG9zICsgMTNdID0gTWF0aC5taW4oTWF0aC5yb3VuZChyYW5nZVsxXSAqIGFuZ2xlRmFjdG9yKSwgMjU1KSAlIDI1NjtcblxuICAgIHRoaXMuc2hvcnRzW3BvczIgKyA4XSA9IHR4O1xuICAgIHRoaXMuc2hvcnRzW3BvczIgKyA5XSA9IHR5O1xuXG4gICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVFbGVtZW50QnVmZmVyO1xuXG5mdW5jdGlvbiBMaW5lRWxlbWVudEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5MaW5lRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpO1xuXG5MaW5lRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA2OyAvLyBieXRlcyBwZXIgdHJpYW5nbGUgKDMgKiB1bnNpZ25lZCBzaG9ydCA9PSA2IGJ5dGVzKVxuTGluZUVsZW1lbnRCdWZmZXIucHJvdG90eXBlLmFycmF5VHlwZSA9ICdFTEVNRU5UX0FSUkFZX0JVRkZFUic7XG5cbkxpbmVFbGVtZW50QnVmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgdmFyIHBvczIgPSB0aGlzLnBvcyAvIDI7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAxXSA9IGI7XG4gICAgdGhpcy51c2hvcnRzW3BvczIgKyAyXSA9IGM7XG5cbiAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gTGluZVZlcnRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG4vLyBzY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBzbyB0aGF0IHRoZSBub3JtYWwgbGVuZ3RoIGlzIHRoaXMgdmFsdWUuXG4vLyBjb250YWlucyB0aGUgXCJ0ZXh0dXJlXCIgbm9ybWFscyAoLTEuLjEpLiB0aGlzIGlzIGRpc3RpbmN0IGZyb20gdGhlIGV4dHJ1ZGVcbi8vIG5vcm1hbHMgZm9yIGxpbmUgam9pbnMsIGJlY2F1c2UgdGhlIHgtdmFsdWUgcmVtYWlucyAwIGZvciB0aGUgdGV4dHVyZVxuLy8gbm9ybWFsIGFycmF5LCB3aGlsZSB0aGUgZXh0cnVkZSBub3JtYWwgYWN0dWFsbHkgbW92ZXMgdGhlIHZlcnRleCB0byBjcmVhdGVcbi8vIHRoZSBhY3V0ZS9iZXZlbGxlZCBsaW5lIGpvaW4uXG5MaW5lVmVydGV4QnVmZmVyLmV4dHJ1ZGVTY2FsZSA9IDYzO1xuXG5MaW5lVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG5cbkxpbmVWZXJ0ZXhCdWZmZXIucHJvdG90eXBlLml0ZW1TaXplID0gODsgLy8gYnl0ZXMgcGVyIHZlcnRleCAoMiAqIHNob3J0ICsgMSAqIHNob3J0ICsgMiAqIGJ5dGUgPSA4IGJ5dGVzKVxuTGluZVZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZGVmYXVsdExlbmd0aCA9IDMyNzY4O1xuXG4vLyBhZGQgYSB2ZXJ0ZXggdG8gdGhpcyBidWZmZXI7XG4vLyB4LCB5IC0gdmVydGV4IHBvc2l0aW9uXG4vLyBleCwgZXkgLSBleHRydWRlIG5vcm1hbFxuLy8gdHgsIHR5IC0gdGV4dHVyZSBub3JtYWxcblxuTGluZVZlcnRleEJ1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocG9pbnQsIGV4dHJ1ZGUsIHR4LCB0eSwgbGluZXNvZmFyKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zLFxuICAgICAgICBwb3MyID0gcG9zIC8gMixcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4LFxuICAgICAgICBleHRydWRlU2NhbGUgPSBMaW5lVmVydGV4QnVmZmVyLmV4dHJ1ZGVTY2FsZTtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSAoTWF0aC5mbG9vcihwb2ludC54KSAqIDIpIHwgdHg7XG4gICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0gKE1hdGguZmxvb3IocG9pbnQueSkgKiAyKSB8IHR5O1xuICAgIHRoaXMuc2hvcnRzW3BvczIgKyAyXSA9IE1hdGgucm91bmQobGluZXNvZmFyIHx8IDApO1xuICAgIHRoaXMuYnl0ZXNbcG9zICsgNl0gPSBNYXRoLnJvdW5kKGV4dHJ1ZGVTY2FsZSAqIGV4dHJ1ZGUueCk7XG4gICAgdGhpcy5ieXRlc1twb3MgKyA3XSA9IE1hdGgucm91bmQoZXh0cnVkZVNjYWxlICogZXh0cnVkZS55KTtcblxuICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3V0bGluZUVsZW1lbnRzQnVmZmVyO1xuXG5mdW5jdGlvbiBPdXRsaW5lRWxlbWVudHNCdWZmZXIoYnVmZmVyKSB7XG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcbn1cblxuT3V0bGluZUVsZW1lbnRzQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG5cbk91dGxpbmVFbGVtZW50c0J1ZmZlci5wcm90b3R5cGUuaXRlbVNpemUgPSA0OyAvLyBieXRlcyBwZXIgbGluZSAoMiAqIHVuc2lnbmVkIHNob3J0ID09IDQgYnl0ZXMpXG5PdXRsaW5lRWxlbWVudHNCdWZmZXIucHJvdG90eXBlLmFycmF5VHlwZSA9ICdFTEVNRU5UX0FSUkFZX0JVRkZFUic7XG5cbk91dGxpbmVFbGVtZW50c0J1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMudXNob3J0c1twb3MyICsgMF0gPSBhO1xuICAgIHRoaXMudXNob3J0c1twb3MyICsgMV0gPSBiO1xuXG4gICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQnVja2V0O1xuXG52YXIgTGluZUJ1Y2tldCA9IHJlcXVpcmUoJy4vbGluZWJ1Y2tldC5qcycpO1xudmFyIEZpbGxCdWNrZXQgPSByZXF1aXJlKCcuL2ZpbGxidWNrZXQuanMnKTtcbnZhciBTeW1ib2xCdWNrZXQgPSByZXF1aXJlKCcuL3N5bWJvbGJ1Y2tldC5qcycpO1xudmFyIFJhc3RlckJ1Y2tldCA9IHJlcXVpcmUoJy4vcmFzdGVyYnVja2V0LmpzJyk7XG52YXIgUmVuZGVyUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3N0eWxlL3JlbmRlcnByb3BlcnRpZXMuanMnKTtcblxuZnVuY3Rpb24gY3JlYXRlQnVja2V0KGxheWVyLCBidWZmZXJzLCBjb2xsaXNpb24sIGluZGljZXMpIHtcblxuICAgIGlmICghUmVuZGVyUHJvcGVydGllc1tsYXllci50eXBlXSkge1xuICAgICAgICAvL2NvbnNvbGUud2FybigndW5rbm93biBidWNrZXQgdHlwZScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBuZXcgUmVuZGVyUHJvcGVydGllc1tsYXllci50eXBlXShsYXllci5yZW5kZXIpO1xuXG4gICAgdmFyIEJ1Y2tldENsYXNzID1cbiAgICAgICAgbGF5ZXIudHlwZSA9PT0gJ2xpbmUnID8gTGluZUJ1Y2tldCA6XG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdmaWxsJyA/IEZpbGxCdWNrZXQgOlxuICAgICAgICBsYXllci50eXBlID09PSAnc3ltYm9sJyA/IFN5bWJvbEJ1Y2tldCA6XG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdyYXN0ZXInID8gUmFzdGVyQnVja2V0IDogbnVsbDtcblxuICAgIHZhciBidWNrZXQgPSBuZXcgQnVja2V0Q2xhc3MoaW5mbywgYnVmZmVycywgY29sbGlzaW9uLCBpbmRpY2VzKTtcbiAgICBidWNrZXQudHlwZSA9IGxheWVyLnR5cGU7XG4gICAgYnVja2V0LmludGVyYWN0aXZlID0gbGF5ZXIuaW50ZXJhY3RpdmU7XG4gICAgYnVja2V0Lm1pblpvb20gPSBsYXllclsnbWluLXpvb20nXTtcbiAgICBidWNrZXQubWF4Wm9vbSA9IGxheWVyWydtYXgtem9vbSddO1xuXG4gICAgcmV0dXJuIGJ1Y2tldDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50R3JvdXBzO1xuXG5mdW5jdGlvbiBFbGVtZW50R3JvdXBzKHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlciwgc2Vjb25kRWxlbWVudEJ1ZmZlcikge1xuXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXI7XG4gICAgdGhpcy5lbGVtZW50QnVmZmVyID0gZWxlbWVudEJ1ZmZlcjtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRCdWZmZXIgPSBzZWNvbmRFbGVtZW50QnVmZmVyO1xuICAgIHRoaXMuZ3JvdXBzID0gW107XG59XG5cbkVsZW1lbnRHcm91cHMucHJvdG90eXBlLm1ha2VSb29tRm9yID0gZnVuY3Rpb24obnVtVmVydGljZXMpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudCB8fCB0aGlzLmN1cnJlbnQudmVydGV4TGVuZ3RoICsgbnVtVmVydGljZXMgPiA2NTUzNSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgRWxlbWVudEdyb3VwKHRoaXMudmVydGV4QnVmZmVyLmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEJ1ZmZlciAmJiB0aGlzLmVsZW1lbnRCdWZmZXIuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyICYmIHRoaXMuc2Vjb25kRWxlbWVudEJ1ZmZlci5pbmRleCk7XG4gICAgICAgIHRoaXMuZ3JvdXBzLnB1c2godGhpcy5jdXJyZW50KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBFbGVtZW50R3JvdXAodmVydGV4U3RhcnRJbmRleCwgZWxlbWVudFN0YXJ0SW5kZXgsIHNlY29uZEVsZW1lbnRTdGFydEluZGV4KSAge1xuICAgIC8vIHRoZSBvZmZzZXQgaW50byB0aGUgdmVydGV4IGJ1ZmZlciBvZiB0aGUgZmlyc3QgdmVydGV4IGluIHRoaXMgZ3JvdXBcbiAgICB0aGlzLnZlcnRleFN0YXJ0SW5kZXggPSB2ZXJ0ZXhTdGFydEluZGV4O1xuICAgIHRoaXMuZWxlbWVudFN0YXJ0SW5kZXggPSBlbGVtZW50U3RhcnRJbmRleDtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRTdGFydEluZGV4ID0gc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbGVtZW50TGVuZ3RoID0gMDtcbiAgICB0aGlzLnZlcnRleExlbmd0aCA9IDA7XG4gICAgdGhpcy5zZWNvbmRFbGVtZW50TGVuZ3RoID0gMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJidXNoID0gcmVxdWlyZSgncmJ1c2gnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmVhdHVyZVRyZWU7XG5cbmZ1bmN0aW9uIEZlYXR1cmVUcmVlKGdldEdlb21ldHJ5LCBnZXRUeXBlKSB7XG5cbiAgICB0aGlzLmdldEdlb21ldHJ5ID0gZ2V0R2VvbWV0cnk7XG4gICAgdGhpcy5nZXRUeXBlID0gZ2V0VHlwZTtcblxuICAgIHRoaXMucnRyZWUgPSByYnVzaCg5KTtcbiAgICB0aGlzLnRvQmVJbnNlcnRlZCA9IFtdO1xufVxuXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oYmJveCwgYnVja2V0X25hbWUsIGZlYXR1cmUpIHtcbiAgICBiYm94LmJ1Y2tldCA9IGJ1Y2tldF9uYW1lO1xuICAgIGJib3guZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgdGhpcy50b0JlSW5zZXJ0ZWQucHVzaChiYm94KTtcbn07XG5cbi8vIGJ1bGsgaW5zZXJ0IGludG8gdHJlZVxuRmVhdHVyZVRyZWUucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ydHJlZS5sb2FkKHRoaXMudG9CZUluc2VydGVkKTtcbiAgICB0aGlzLnRvQmVJbnNlcnRlZCA9IFtdO1xufTtcblxuLy8gRmluZHMgZmVhdHVyZXMgaW4gdGhpcyB0aWxlIGF0IGEgcGFydGljdWxhciBwb3NpdGlvbi5cbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAodGhpcy50b0JlSW5zZXJ0ZWQubGVuZ3RoKSB0aGlzLl9sb2FkKCk7XG5cbiAgICB2YXIgcmFkaXVzID0gYXJncy5wYXJhbXMgJiYgYXJncy5wYXJhbXMucmFkaXVzIHx8IDA7XG4gICAgcmFkaXVzICo9IDQwOTYgLyBhcmdzLnNjYWxlO1xuXG4gICAgdmFyIHggPSBhcmdzLngsXG4gICAgICAgIHkgPSBhcmdzLnk7XG5cbiAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLnJ0cmVlLnNlYXJjaChbIHggLSByYWRpdXMsIHkgLSByYWRpdXMsIHggKyByYWRpdXMsIHkgKyByYWRpdXMgXSk7XG5cbiAgICBpZiAoYXJncy5wYXJhbXMuYnVja2V0cykge1xuICAgICAgICB0aGlzLnF1ZXJ5QnVja2V0cyhtYXRjaGluZywgeCwgeSwgcmFkaXVzLCBhcmdzLnBhcmFtcywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVlcnlGZWF0dXJlcyhtYXRjaGluZywgeCwgeSwgcmFkaXVzLCBhcmdzLnBhcmFtcywgY2FsbGJhY2spO1xuICAgIH1cbn07XG5cbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5xdWVyeUZlYXR1cmVzID0gZnVuY3Rpb24obWF0Y2hpbmcsIHgsIHksIHJhZGl1cywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gbWF0Y2hpbmdbaV0uZmVhdHVyZTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldFR5cGUoZmVhdHVyZSk7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoZmVhdHVyZSk7XG5cblxuICAgICAgICBpZiAocGFyYW1zLmJ1Y2tldCAmJiBtYXRjaGluZ1tpXS5idWNrZXQgIT09IHBhcmFtcy5idWNrZXQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAocGFyYW1zLnR5cGUgJiYgdHlwZSAhPT0gcGFyYW1zLnR5cGUpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeUNvbnRhaW5zUG9pbnQoZ2VvbWV0cnksIHR5cGUsIG5ldyBQb2ludCh4LCB5KSwgcmFkaXVzKSkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIF9idWNrZXQ6IG1hdGNoaW5nW2ldLmJ1Y2tldCxcbiAgICAgICAgICAgICAgICBfdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5nZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgIHByb3BzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5WzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IGZlYXR1cmVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xufTtcblxuLy8gTGlzdHMgYWxsIGJ1Y2tldHMgdGhhdCBhdCB0aGUgcG9zaXRpb24uXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUucXVlcnlCdWNrZXRzID0gZnVuY3Rpb24obWF0Y2hpbmcsIHgsIHksIHJhZGl1cywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBidWNrZXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnVja2V0cy5pbmRleE9mKG1hdGNoaW5nW2ldLmJ1Y2tldCkgPj0gMCkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGZlYXR1cmUgPSBtYXRjaGluZ1tpXS5mZWF0dXJlO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0VHlwZShmZWF0dXJlKTtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeShmZWF0dXJlKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5Q29udGFpbnNQb2ludChnZW9tZXRyeSwgdHlwZSwgbmV3IFBvaW50KHgsIHkpLCByYWRpdXMpKSB7XG4gICAgICAgICAgICBidWNrZXRzLnB1c2gobWF0Y2hpbmdbaV0uYnVja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIGJ1Y2tldHMpO1xufTtcblxuXG5mdW5jdGlvbiBnZW9tZXRyeUNvbnRhaW5zUG9pbnQocmluZ3MsIHR5cGUsIHAsIHJhZGl1cykge1xuICAgIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIHJldHVybiBwb2ludENvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiBwb2x5Q29udGFpbnNQb2ludChyaW5ncywgcCkgPyB0cnVlIDogbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1MDE3MjUvMzMxMzc5LlxuZnVuY3Rpb24gZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykge1xuICAgIHZhciBsMiA9IHYuZGlzdFNxcih3KTtcbiAgICBpZiAobDIgPT09IDApIHJldHVybiBwLmRpc3RTcXIodik7XG4gICAgdmFyIHQgPSAoKHAueCAtIHYueCkgKiAody54IC0gdi54KSArIChwLnkgLSB2LnkpICogKHcueSAtIHYueSkpIC8gbDI7XG4gICAgaWYgKHQgPCAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIGlmICh0ID4gMSkgcmV0dXJuIHAuZGlzdFNxcih3KTtcbiAgICByZXR1cm4gcC5kaXN0U3FyKHcuc3ViKHYpLl9tdWx0KHQpLl9hZGQodikpO1xufVxuXG5mdW5jdGlvbiBsaW5lQ29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKSB7XG4gICAgdmFyIHIgPSByYWRpdXMgKiByYWRpdXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gRmluZCBsaW5lIHNlZ21lbnRzIHRoYXQgaGF2ZSBhIGRpc3RhbmNlIDw9IHJhZGl1c14yIHRvIHBcbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgdHJlYXQgdGhlIGxpbmUgYXMgXCJjb250YWluaW5nIHBvaW50IHBcIi5cbiAgICAgICAgICAgIHZhciB2ID0gcmluZ1tqLTFdLCB3ID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmIChkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSA8IHIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcG9pbnQgaW4gcG9seWdvbiByYXkgY2FzdGluZyBhbGdvcml0aG1cbmZ1bmN0aW9uIHBvbHlDb250YWluc1BvaW50KHJpbmdzLCBwKSB7XG4gICAgdmFyIGMgPSBmYWxzZSxcbiAgICAgICAgcmluZywgcDEsIHAyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5ncy5sZW5ndGg7IGsrKykge1xuICAgICAgICByaW5nID0gcmluZ3Nba107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmluZy5sZW5ndGggLSAxOyBpIDwgcmluZy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHAxID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmICgoKHAxLnkgPiBwLnkpICE9IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgICAgICAgICAgICAgICBjID0gIWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHBvaW50Q29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKSB7XG4gICAgdmFyIHIgPSByYWRpdXMgKiByYWRpdXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHJpbmdbal0uZGlzdFNxcihwKSA8PSByKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudGdyb3Vwcy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxCdWNrZXQ7XG5cbmZ1bmN0aW9uIEZpbGxCdWNrZXQoaW5mbywgYnVmZmVycywgcGxhY2VtZW50LCBlbGVtZW50R3JvdXBzKSB7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuZWxlbWVudEdyb3VwcyA9IGVsZW1lbnRHcm91cHMgfHwgbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5maWxsVmVydGV4LCBidWZmZXJzLmZpbGxFbGVtZW50LCBidWZmZXJzLm91dGxpbmVFbGVtZW50KTtcbn1cblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUubG9hZEdlb21ldHJ5KCkpO1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihsaW5lcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRGaWxsKGxpbmVzW2ldKTtcbiAgICB9XG59O1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5hZGRGaWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMykge1xuICAgICAgICAvL2NvbnNvbGUud2FybignYSBmaWxsIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXMgd2UncmUgZ29pbmcgdG8gcHJvZHVjZSBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHJlc2l6ZSB0aGUgYnVmZmVyIGJlZm9yZWhhbmQsIG9yIGRldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyB3b24ndCBmaXQgaW50byB0aGUgYnVmZmVyIGFueW1vcmUuXG4gICAgLy8gSW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1c2UgdGhlIHZlcnRleCBidWZmZXIgZm9yIGRyYXdpbmcgdGhlIGFudGlhbGlhc2VkXG4gICAgLy8gb3V0bGluZXMsIHdlIHNlcGFyYXRlIGFsbCBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBkZWdlbmVyYXRlIChvdXQtb2YtXG4gICAgLy8gdmlld3BsYW5lKSB2ZXJ0ZXguXG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIGdlb21ldHJ5IGJ1ZmZlciBjYW4gaG9sZCBhbGwgdGhlIHJlcXVpcmVkIHZlcnRpY2VzLlxuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5tYWtlUm9vbUZvcihsZW4gKyAxKTtcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG5cbiAgICB2YXIgZmlsbFZlcnRleCA9IHRoaXMuYnVmZmVycy5maWxsVmVydGV4O1xuICAgIHZhciBmaWxsRWxlbWVudCA9IHRoaXMuYnVmZmVycy5maWxsRWxlbWVudDtcbiAgICB2YXIgb3V0bGluZUVsZW1lbnQgPSB0aGlzLmJ1ZmZlcnMub3V0bGluZUVsZW1lbnQ7XG5cbiAgICAvLyBTdGFydCBhbGwgbGluZXMgd2l0aCBhIGRlZ2VuZXJhdGUgdmVydGV4XG4gICAgZWxlbWVudEdyb3VwLnZlcnRleExlbmd0aCsrO1xuXG4gICAgLy8gV2UncmUgZ2VuZXJhdGluZyB0cmlhbmdsZSBmYW5zLCBzbyB3ZSBhbHdheXMgc3RhcnQgd2l0aCB0aGUgZmlyc3QgY29vcmRpbmF0ZSBpbiB0aGlzIHBvbHlnb24uXG4gICAgdmFyIGZpcnN0SW5kZXggPSBmaWxsVmVydGV4LmluZGV4IC0gZWxlbWVudEdyb3VwLnZlcnRleFN0YXJ0SW5kZXgsXG4gICAgICAgIHByZXZJbmRleCwgY3VycmVudEluZGV4LCBjdXJyZW50VmVydGV4O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBmaWxsVmVydGV4LmluZGV4IC0gZWxlbWVudEdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgICAgIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICBmaWxsVmVydGV4LmFkZChjdXJyZW50VmVydGV4LngsIGN1cnJlbnRWZXJ0ZXgueSk7XG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGgrKztcblxuICAgICAgICAvLyBPbmx5IGFkZCB0cmlhbmdsZXMgdGhhdCBoYXZlIGRpc3RpbmN0IHZlcnRpY2VzLlxuICAgICAgICBpZiAoaSA+PSAyICYmIChjdXJyZW50VmVydGV4LnggIT09IHZlcnRpY2VzWzBdLnggfHwgY3VycmVudFZlcnRleC55ICE9PSB2ZXJ0aWNlc1swXS55KSkge1xuICAgICAgICAgICAgZmlsbEVsZW1lbnQuYWRkKGZpcnN0SW5kZXgsIHByZXZJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cC5lbGVtZW50TGVuZ3RoKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+PSAxKSB7XG4gICAgICAgICAgICBvdXRsaW5lRWxlbWVudC5hZGQocHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLnNlY29uZEVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB9XG59O1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5oYXNEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudGdyb3Vwcy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVCdWNrZXQ7XG5cbmZ1bmN0aW9uIExpbmVCdWNrZXQoaW5mbywgYnVmZmVycywgcGxhY2VtZW50LCBlbGVtZW50R3JvdXBzKSB7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuZWxlbWVudEdyb3VwcyA9IGVsZW1lbnRHcm91cHMgfHwgbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5saW5lVmVydGV4LCBidWZmZXJzLmxpbmVFbGVtZW50KTtcbn1cblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUubG9hZEdlb21ldHJ5KCkpO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihsaW5lcykge1xuICAgIHZhciBpbmZvID0gdGhpcy5pbmZvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lKGxpbmVzW2ldLCBpbmZvWydsaW5lLWpvaW4nXSwgaW5mb1snbGluZS1jYXAnXSxcbiAgICAgICAgICAgICAgICBpbmZvWydsaW5lLW1pdGVyLWxpbWl0J10sIGluZm9bJ2xpbmUtcm91bmQtbGltaXQnXSk7XG4gICAgfVxufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBqb2luLCBjYXAsIG1pdGVyTGltaXQsIHJvdW5kTGltaXQpIHtcbiAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAvL2NvbnNvbGUud2FybignYSBsaW5lIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gdmVydGljZXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChqb2luID09PSAnYmV2ZWwnKSBtaXRlckxpbWl0ID0gMS4wNTtcblxuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF0sXG4gICAgICAgIGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc1tsZW4gLSAxXSxcbiAgICAgICAgY2xvc2VkID0gZmlyc3RWZXJ0ZXguZXF1YWxzKGxhc3RWZXJ0ZXgpO1xuXG4gICAgdmFyIGxpbmVWZXJ0ZXggPSB0aGlzLmJ1ZmZlcnMubGluZVZlcnRleDtcbiAgICB2YXIgbGluZUVsZW1lbnQgPSB0aGlzLmJ1ZmZlcnMubGluZUVsZW1lbnQ7XG5cbiAgICAvLyB3ZSBjb3VsZCBiZSBtb3JlIHByZWNpZXMsIGJ1dCBpdCB3b3VsZCBvbmx5IHNhdmUgYSBuZWdsaWdpYmxlIGFtb3VudCBvZiBzcGFjZVxuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5tYWtlUm9vbUZvcihsZW4gKiA0KTtcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG4gICAgdmFyIHZlcnRleFN0YXJ0SW5kZXggPSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleDtcblxuICAgIGlmIChsZW4gPT0gMiAmJiBjbG9zZWQpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdhIGxpbmUgbWF5IG5vdCBoYXZlIGNvaW5jaWRlbnQgcG9pbnRzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmVnaW5DYXAgPSBjYXAsXG4gICAgICAgIGVuZENhcCA9IGNsb3NlZCA/ICdidXR0JyA6IGNhcCxcbiAgICAgICAgZmxpcCA9IDEsXG4gICAgICAgIGRpc3RhbmNlID0gMCxcbiAgICAgICAgY3VycmVudFZlcnRleCwgcHJldlZlcnRleCwgIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsICBuZXh0Tm9ybWFsO1xuXG4gICAgLy8gdGhlIGxhc3QgdGhyZWUgdmVydGljZXMgYWRkZWRcbiAgICB2YXIgZTEsIGUyLCBlMztcblxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDJdO1xuICAgICAgICBuZXh0Tm9ybWFsID0gZmlyc3RWZXJ0ZXguc3ViKGN1cnJlbnRWZXJ0ZXgpLl91bml0KCkuX3BlcnAoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgbmV4dFZlcnRleCA9IGNsb3NlZCAmJiBpID09PSBsZW4gLSAxID9cbiAgICAgICAgICAgIHZlcnRpY2VzWzFdIDogLy8gaWYgdGhlIGxpbmUgaXMgY2xvc2VkLCB3ZSB0cmVhdCB0aGUgbGFzdCB2ZXJ0ZXggbGlrZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKyAxXTsgLy8ganVzdCB0aGUgbmV4dCB2ZXJ0ZXhcblxuICAgICAgICAvLyBpZiB0d28gY29uc2VjdXRpdmUgdmVydGljZXMgZXhpc3QsIHNraXAgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIGlmIChuZXh0VmVydGV4ICYmIHZlcnRpY2VzW2ldLmVxdWFscyhuZXh0VmVydGV4KSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKG5leHROb3JtYWwpIHByZXZOb3JtYWwgPSBuZXh0Tm9ybWFsO1xuICAgICAgICBpZiAoY3VycmVudFZlcnRleCkgcHJldlZlcnRleCA9IGN1cnJlbnRWZXJ0ZXg7XG5cbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgZmFyIGFsb25nIHRoZSBsaW5lIHRoZSBjdXJyZW50VmVydGV4IGlzXG4gICAgICAgIGlmIChwcmV2VmVydGV4KSBkaXN0YW5jZSArPSBjdXJyZW50VmVydGV4LmRpc3QocHJldlZlcnRleCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBub3JtYWwgdG93YXJkcyB0aGUgbmV4dCB2ZXJ0ZXggaW4gdGhpcyBsaW5lLiBJbiBjYXNlXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgdmVydGV4LCBwcmV0ZW5kIHRoYXQgdGhlIGxpbmUgaXMgY29udGludWluZyBzdHJhaWdodCxcbiAgICAgICAgLy8gbWVhbmluZyB0aGF0IHdlIGFyZSBqdXN0IHVzaW5nIHRoZSBwcmV2aW91cyBub3JtYWwuXG4gICAgICAgIG5leHROb3JtYWwgPSBuZXh0VmVydGV4ID8gbmV4dFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpIDogcHJldk5vcm1hbDtcblxuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGEgcHJldmlvdXMgbm9ybWFsLCB0aGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgYVxuICAgICAgICAvLyBub24tY2xvc2VkIGxpbmUsIHNvIHdlJ3JlIGRvaW5nIGEgc3RyYWlnaHQgXCJqb2luXCIuXG4gICAgICAgIHByZXZOb3JtYWwgPSBwcmV2Tm9ybWFsIHx8IG5leHROb3JtYWw7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBub3JtYWwgb2YgdGhlIGpvaW4gZXh0cnVzaW9uLiBJdCBpcyB0aGUgYW5nbGUgYmlzZWN0b3JcbiAgICAgICAgLy8gb2YgdGhlIHNlZ21lbnRzIGJldHdlZW4gdGhlIHByZXZpb3VzIGxpbmUgYW5kIHRoZSBuZXh0IGxpbmUuXG4gICAgICAgIHZhciBqb2luTm9ybWFsID0gcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkuX3VuaXQoKTtcblxuICAgICAgICAvKiAgam9pbk5vcm1hbCAgICAgcHJldk5vcm1hbFxuICAgICAgICAgKiAgICAgICAgICAgICDihpYgICAgICDihpFcbiAgICAgICAgICogICAgICAgICAgICAgICAgLl9fX19fX19fLiBwcmV2VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogbmV4dE5vcm1hbCAg4oaQICB8ICBjdXJyZW50VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIG5leHRWZXJ0ZXggIVxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgbWl0ZXIgKHRoZSByYXRpbyBvZiB0aGUgbWl0ZXIgdG8gdGhlIHdpZHRoKS5cbiAgICAgICAgLy8gRmluZCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBuZXh0IGFuZCBqb2luIG5vcm1hbHNcbiAgICAgICAgLy8gdXNpbmcgZG90IHByb2R1Y3QuIFRoZSBpbnZlcnNlIG9mIHRoYXQgaXMgdGhlIG1pdGVyIGxlbmd0aC5cbiAgICAgICAgdmFyIGNvc0hhbGZBbmdsZSA9IGpvaW5Ob3JtYWwueCAqIG5leHROb3JtYWwueCArIGpvaW5Ob3JtYWwueSAqIG5leHROb3JtYWwueTtcbiAgICAgICAgdmFyIG1pdGVyTGVuZ3RoID0gMSAvIGNvc0hhbGZBbmdsZTtcblxuICAgICAgICAvLyBXaGV0aGVyIGFueSB2ZXJ0aWNlcyBoYXZlIGJlZW5cbiAgICAgICAgdmFyIHN0YXJ0T2ZMaW5lID0gZTEgPT09IHVuZGVmaW5lZCB8fCBlMiA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFRoZSBqb2luIGlmIGEgbWlkZGxlIHZlcnRleCwgb3RoZXJ3aXNlIHRoZSBjYXAuXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG4gICAgICAgIHZhciBjdXJyZW50Sm9pbiA9IG1pZGRsZVZlcnRleCA/IGpvaW4gOiBuZXh0VmVydGV4ID8gYmVnaW5DYXAgOiBlbmRDYXA7XG5cbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJyAmJiBtaXRlckxlbmd0aCA8IHJvdW5kTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ21pdGVyJyAmJiBtaXRlckxlbmd0aCA+IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2JldmVsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXh0cnVkZSBsZW5ndGggaXMgNjMgLyAyNTYgPSA0IHRpbWVzIHRoZSB3aWR0aCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gc28gaWYgbWl0ZXJMZW5ndGggPj0gNCB3ZSBuZWVkIHRvIGRyYXcgYSBkaWZmZXJlbnQgdHlwZSBvZiBiZXZlbCB3aGVyZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA+IDQpIGN1cnJlbnRKb2luID0gJ2ZsaXBiZXZlbCc7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBtaXRlckxlbmd0aCBpcyByZWFsbHkgc21hbGwgYW5kIHRoZSBsaW5lIGJldmVsIHdvdWxkbid0IGJlIHZpc2libGUsXG4gICAgICAgICAgICAvLyBqdXN0IGRyYXcgYSBtaXRlciBqb2luIHRvIHNhdmUgYSB0cmlhbmdsZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA8IG1pdGVyTGltaXQpIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1pdGVyZWQgam9pbnNcbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInKSB7XG4gICAgICAgICAgICAvLyBzY2FsZSB0aGUgdW5pdCB2ZWN0b3IgYnkgdGhlIG1pdGVyIGxlbmd0aFxuICAgICAgICAgICAgam9pbk5vcm1hbC5fbXVsdChtaXRlckxlbmd0aCk7XG4gICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xuICAgICAgICAgICAgLy8gbWl0ZXIgaXMgdG9vIGJpZywgZmxpcCB0aGUgZGlyZWN0aW9uIHRvIG1ha2UgYSBiZXZlbGVkIGpvaW5cblxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxtb3N0IHBhcmFsbGVsIGxpbmVzXG4gICAgICAgICAgICAgICAgZmxpcCA9IC1mbGlwO1xuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwgPSBuZXh0Tm9ybWFsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBiZXZlbExlbmd0aCA9IG1pdGVyTGVuZ3RoICogcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkubWFnKCkgLyBwcmV2Tm9ybWFsLnN1YihuZXh0Tm9ybWFsKS5tYWcoKTtcbiAgICAgICAgICAgICAgICBqb2luTm9ybWFsLl9wZXJwKCkuX211bHQoZmxpcCAqIGJldmVsTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmbGlwID0gLWZsaXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICAvLyBBbGwgb3RoZXIgdHlwZXMgb2Ygam9pbnNcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG9mZnNldEEsIG9mZnNldEI7XG4gICAgICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gcHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54O1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAtTWF0aC5zcXJ0KG1pdGVyTGVuZ3RoICogbWl0ZXJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxpcCAqIGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QiA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXRCID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgYnV0dCBvciBhIHNxdWFyZSBjYXAgb3IgYmV2ZWxcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KHByZXZOb3JtYWwsIG9mZnNldEEsIG9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHJvdW5kIGNhcCBvciBsaW5lam9pbiBhdCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgocHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlZ21lbnQgaW5jbHVkZSBjYXAgYXJlIGRvbmUsIHVuc2V0IHZlcnRpY2VzIHRvIGRpc2Nvbm5lY3Qgc2VnbWVudHMuXG4gICAgICAgICAgICAvLyBPciBsZWF2ZSB0aGVtIHRvIGNyZWF0ZSBhIGJldmVsLlxuICAgICAgICAgICAgaWYgKHN0YXJ0T2ZMaW5lIHx8IGN1cnJlbnRKb2luICE9PSAnYmV2ZWwnKSB7XG4gICAgICAgICAgICAgICAgZTEgPSBlMiA9IC0xO1xuICAgICAgICAgICAgICAgIGZsaXAgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIGJlZm9yZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICBpZiAoc3RhcnRPZkxpbmUgJiYgYmVnaW5DYXAgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KG5leHROb3JtYWwsIC0xLCAtMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dCBvciBzcXVhcmUgY2FwIG9yIGJldmVsXG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgobmV4dE5vcm1hbCwgLW9mZnNldEEsIC1vZmZzZXRCLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBBZGRzIHR3byB2ZXJ0aWNlcyB0byB0aGUgYnVmZmVyIHRoYXQgYXJlXG4gICAgICogbm9ybWFsIGFuZCAtbm9ybWFsIGZyb20gdGhlIGN1cnJlbnRWZXJ0ZXguXG4gICAgICpcbiAgICAgKiBlbmRCb3ggbW92ZXMgdGhlIGV4dHJ1ZGUgb25lIHVuaXQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZVxuICAgICAqIHRvIGNyZWF0ZSBzcXVhcmUgb3Igcm91bmQgY2FwLlxuICAgICAqXG4gICAgICogZW5kTGVmdCBhbmQgZW5kUmlnaHQgc2hpZnRzIHRoZSBleHRydWRlIGFsb25nIHRoZSBsaW5lXG4gICAgICogZW5kTGVmdCA9PT0gMSBtb3ZlcyB0aGUgZXh0cnVkZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gICAgICogZW5kTGVmdCA9PT0gLTEgbW92ZXMgdGhlIGV4dHJ1ZGUgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkQ3VycmVudFZlcnRleChub3JtYWwsIGVuZExlZnQsIGVuZFJpZ2h0LCByb3VuZCkge1xuXG4gICAgICAgIHZhciB0eCA9IHJvdW5kID8gMSA6IDA7XG4gICAgICAgIHZhciBleHRydWRlO1xuXG4gICAgICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdChmbGlwKTtcbiAgICAgICAgaWYgKGVuZExlZnQpIGV4dHJ1ZGUuX3N1Yihub3JtYWwucGVycCgpLl9tdWx0KGVuZExlZnQpKTtcbiAgICAgICAgZTMgPSBsaW5lVmVydGV4LmFkZChjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMCwgZGlzdGFuY2UpIC0gdmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGUxID49IDAgJiYgZTIgPj0gMCkge1xuICAgICAgICAgICAgbGluZUVsZW1lbnQuYWRkKGUxLCBlMiwgZTMpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlMSA9IGUyO1xuICAgICAgICBlMiA9IGUzO1xuXG4gICAgICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdCgtZmxpcCk7XG4gICAgICAgIGlmIChlbmRSaWdodCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kUmlnaHQpKTtcbiAgICAgICAgZTMgPSBsaW5lVmVydGV4LmFkZChjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMSwgZGlzdGFuY2UpIC0gdmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGUxID49IDAgJiYgZTIgPj0gMCkge1xuICAgICAgICAgICAgbGluZUVsZW1lbnQuYWRkKGUxLCBlMiwgZTMpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlMSA9IGUyO1xuICAgICAgICBlMiA9IGUzO1xuXG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGggKz0gMjtcbiAgICB9XG59O1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5oYXNEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlckJ1Y2tldDtcblxuZnVuY3Rpb24gUmFzdGVyQnVja2V0KGluZm8pIHtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudGdyb3Vwcy5qcycpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3IuanMnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pbnRlcnBvbGF0ZS5qcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciByZXNvbHZlVG9rZW5zID0gcmVxdWlyZSgnLi4vdXRpbC90b2tlbi5qcycpO1xudmFyIFBsYWNlbWVudCA9IHJlcXVpcmUoJy4uL3N5bWJvbC9wbGFjZW1lbnQuanMnKTtcbnZhciBTaGFwaW5nID0gcmVxdWlyZSgnLi4vc3ltYm9sL3NoYXBpbmcuanMnKTtcbnZhciByZXNvbHZlVGV4dCA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yZXNvbHZldGV4dC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbEJ1Y2tldDtcblxudmFyIGZ1bGxSYW5nZSA9IFsyICogTWF0aC5QSSAsIDBdO1xuXG5mdW5jdGlvbiBTeW1ib2xCdWNrZXQoaW5mbywgYnVmZmVycywgY29sbGlzaW9uLCBlbGVtZW50R3JvdXBzKSB7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuY29sbGlzaW9uID0gY29sbGlzaW9uO1xuXG4gICAgaWYgKGluZm9bJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgIGlmICghaW5mby5oYXNPd25Qcm9wZXJ0eSgndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnKSkge1xuICAgICAgICAgICAgaW5mb1sndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9ICdtYXAnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5mby5oYXNPd25Qcm9wZXJ0eSgnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnKSkge1xuICAgICAgICAgICAgaW5mb1snaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9ICdtYXAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mb1snc3ltYm9sLWF2b2lkLWVkZ2VzJ10gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50R3JvdXBzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEdyb3VwcyA9IGVsZW1lbnRHcm91cHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzID0ge1xuICAgICAgICAgICAgdGV4dDogbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5nbHlwaFZlcnRleCksXG4gICAgICAgICAgICBpY29uOiBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmljb25WZXJ0ZXgpXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmluZm87XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gdGhpcy50ZXh0RmVhdHVyZXM7XG5cbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41O1xuICAgIGlmIChpbmZvWyd0ZXh0LWhvcml6b250YWwtYWxpZ24nXSA9PT0gJ3JpZ2h0JykgaG9yaXpvbnRhbEFsaWduID0gMTtcbiAgICBlbHNlIGlmIChpbmZvWyd0ZXh0LWhvcml6b250YWwtYWxpZ24nXSA9PT0gJ2xlZnQnKSBob3Jpem9udGFsQWxpZ24gPSAwO1xuXG4gICAgdmFyIHZlcnRpY2FsQWxpZ24gPSAwLjU7XG4gICAgaWYgKGluZm9bJ3RleHQtdmVydGljYWwtYWxpZ24nXSA9PT0gJ2JvdHRvbScpIHZlcnRpY2FsQWxpZ24gPSAxO1xuICAgIGVsc2UgaWYgKGluZm9bJ3RleHQtdmVydGljYWwtYWxpZ24nXSA9PT0gJ3RvcCcpIHZlcnRpY2FsQWxpZ24gPSAwO1xuXG4gICAgdmFyIGp1c3RpZnkgPSAwLjU7XG4gICAgaWYgKGluZm9bJ3RleHQtanVzdGlmeSddID09PSAncmlnaHQnKSBqdXN0aWZ5ID0gMTtcbiAgICBlbHNlIGlmIChpbmZvWyd0ZXh0LWp1c3RpZnknXSA9PT0gJ2xlZnQnKSBqdXN0aWZ5ID0gMDtcblxuICAgIHZhciBvbmVFbSA9IDI0O1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gaW5mb1sndGV4dC1saW5lLWhlaWdodCddICogb25lRW07XG4gICAgdmFyIG1heFdpZHRoID0gaW5mb1snc3ltYm9sLXBsYWNlbWVudCddICE9PSAnbGluZScgJiYgaW5mb1sndGV4dC1tYXgtd2lkdGgnXSAqIG9uZUVtO1xuICAgIHZhciBzcGFjaW5nID0gaW5mb1sndGV4dC1sZXR0ZXItc3BhY2luZyddICogb25lRW07XG4gICAgdmFyIGZvbnRzdGFjayA9IGluZm9bJ3RleHQtZm9udCddO1xuICAgIHZhciB0ZXh0T2Zmc2V0ID0gW2luZm9bJ3RleHQtb2Zmc2V0J11bMF0gKiBvbmVFbSwgaW5mb1sndGV4dC1vZmZzZXQnXVsxXSAqIG9uZUVtXTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZmVhdHVyZXMubGVuZ3RoOyBrKyspIHtcblxuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2tdO1xuICAgICAgICB2YXIgdGV4dCA9IHRleHRGZWF0dXJlc1trXTtcbiAgICAgICAgdmFyIGxpbmVzID0gZmVhdHVyZS5sb2FkR2VvbWV0cnkoKTtcblxuICAgICAgICB2YXIgc2hhcGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgc2hhcGluZyA9IFNoYXBpbmcuc2hhcGUodGV4dCwgZm9udHN0YWNrLCB0aGlzLnN0YWNrcywgbWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgc3BhY2luZywgdGV4dE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3ByaXRlICYmIHRoaXMuaW5mb1snaWNvbi1pbWFnZSddKSB7XG4gICAgICAgICAgICBpbWFnZSA9IHRoaXMuc3ByaXRlW3Jlc29sdmVUb2tlbnMoZmVhdHVyZS5wcm9wZXJ0aWVzLCBpbmZvWydpY29uLWltYWdlJ10pXTtcblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gbWF0Y2ggZ2x5cGggdGV4IG9iamVjdC4gVE9ETyBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpbWFnZS53ID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgaW1hZ2UuaCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5zZGYpIHRoaXMuZWxlbWVudEdyb3Vwcy5zZGZJY29ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNoYXBpbmcgJiYgIWltYWdlKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGxpbmVzLCB0aGlzLnN0YWNrcywgc2hhcGluZywgaW1hZ2UpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGJ5U2NhbGUoYSwgYikge1xuICAgIHJldHVybiBhLnNjYWxlIC0gYi5zY2FsZTtcbn1cblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24obGluZXMsIGZhY2VzLCBzaGFwaW5nLCBpbWFnZSkge1xuICAgIHZhciBpbmZvID0gdGhpcy5pbmZvO1xuICAgIHZhciBjb2xsaXNpb24gPSB0aGlzLmNvbGxpc2lvbjtcblxuICAgIHZhciBtaW5TY2FsZSA9IDAuNTtcbiAgICB2YXIgZ2x5cGhTaXplID0gMjQ7XG5cbiAgICB2YXIgaG9yaXpvbnRhbFRleHQgPSBpbmZvWyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID09PSAndmlld3BvcnQnLFxuICAgICAgICBob3Jpem9udGFsSWNvbiA9IGluZm9bJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICd2aWV3cG9ydCcsXG4gICAgICAgIGZvbnRTY2FsZSA9IGluZm9bJ3RleHQtbWF4LXNpemUnXSAvIGdseXBoU2l6ZSxcbiAgICAgICAgdGV4dEJveFNjYWxlID0gY29sbGlzaW9uLnRpbGVQaXhlbFJhdGlvICogZm9udFNjYWxlLFxuICAgICAgICBpY29uQm94U2NhbGUgPSBjb2xsaXNpb24udGlsZVBpeGVsUmF0aW8gKiBpbmZvWydpY29uLW1heC1zaXplJ10sXG4gICAgICAgIGljb25XaXRob3V0VGV4dCA9IGluZm9bJ3RleHQtb3B0aW9uYWwnXSB8fCAhc2hhcGluZyxcbiAgICAgICAgdGV4dFdpdGhvdXRJY29uID0gaW5mb1snaWNvbi1vcHRpb25hbCddIHx8ICFpbWFnZSxcbiAgICAgICAgYXZvaWRFZGdlcyA9IGluZm9bJ3N5bWJvbC1hdm9pZC1lZGdlcyddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIHZhciBhbmNob3JzO1xuXG4gICAgICAgIGlmIChpbmZvWydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJykge1xuICAgICAgICAgICAgLy8gTGluZSBsYWJlbHNcbiAgICAgICAgICAgIGFuY2hvcnMgPSBpbnRlcnBvbGF0ZShsaW5lLCBpbmZvWydzeW1ib2wtbWluLWRpc3RhbmNlJ10sIG1pblNjYWxlLCBjb2xsaXNpb24ubWF4UGxhY2VtZW50U2NhbGUsIGNvbGxpc2lvbi50aWxlUGl4ZWxSYXRpbyk7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgYW5jaG9ycyBieSBzZWdtZW50IHNvIHRoYXQgd2UgY2FuIHN0YXJ0IHBsYWNlbWVudCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gYW5jaG9ycyB0aGF0IGNhbiBiZSBzaG93biBhdCB0aGUgbG93ZXN0IHpvb20gbGV2ZWxzLlxuICAgICAgICAgICAgYW5jaG9ycy5zb3J0KGJ5U2NhbGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQb2ludCBsYWJlbHNcbiAgICAgICAgICAgIGFuY2hvcnMgPSBbbmV3IEFuY2hvcihsaW5lWzBdLngsIGxpbmVbMF0ueSwgMCwgbWluU2NhbGUpXTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBjb3JyZWN0IGFzY2VuZGVyIGhlaWdodC5cbiAgICAgICAgdmFyIG9yaWdpbiA9IG5ldyBQb2ludCgwLCAtMTcpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBhbmNob3JzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYW5jaG9yc1tqXTtcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAhKGFuY2hvci54IDwgMCB8fCBhbmNob3IueCA+IDQwOTYgfHwgYW5jaG9yLnkgPCAwIHx8IGFuY2hvci55ID4gNDA5Nik7XG5cbiAgICAgICAgICAgIGlmIChhdm9pZEVkZ2VzICYmICFpbnNpZGUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlcyBhdCB3aGljaCB0aGUgdGV4dCBhbmQgaWNvbnMgY2FuIGJlIGZpcnN0IHNob3duIHdpdGhvdXQgb3ZlcmxhcFxuICAgICAgICAgICAgdmFyIGdseXBoO1xuICAgICAgICAgICAgdmFyIGljb247XG4gICAgICAgICAgICB2YXIgZ2x5cGhTY2FsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgaWNvblNjYWxlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHNoYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBnbHlwaCA9IFBsYWNlbWVudC5nZXRHbHlwaHMoYW5jaG9yLCBvcmlnaW4sIHNoYXBpbmcsIGZhY2VzLCB0ZXh0Qm94U2NhbGUsIGhvcml6b250YWxUZXh0LCBsaW5lLCBpbmZvKTtcbiAgICAgICAgICAgICAgICBnbHlwaFNjYWxlID0gaW5mb1sndGV4dC1hbGxvdy1vdmVybGFwJ10gPyBnbHlwaC5taW5TY2FsZVxuICAgICAgICAgICAgICAgICAgICA6IGNvbGxpc2lvbi5nZXRQbGFjZW1lbnRTY2FsZShnbHlwaC5ib3hlcywgZ2x5cGgubWluU2NhbGUsIGF2b2lkRWRnZXMpO1xuICAgICAgICAgICAgICAgIGlmICghZ2x5cGhTY2FsZSAmJiAhaWNvbldpdGhvdXRUZXh0KSBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWNvbiA9IFBsYWNlbWVudC5nZXRJY29uKGFuY2hvciwgaW1hZ2UsIGljb25Cb3hTY2FsZSwgbGluZSwgaW5mbyk7XG4gICAgICAgICAgICAgICAgaWNvblNjYWxlID0gaW5mb1snaWNvbi1hbGxvdy1vdmVybGFwJ10gPyBpY29uLm1pblNjYWxlXG4gICAgICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFNjYWxlKGljb24uYm94ZXMsIGljb24ubWluU2NhbGUsIGF2b2lkRWRnZXMpO1xuICAgICAgICAgICAgICAgIGlmICghaWNvblNjYWxlICYmICF0ZXh0V2l0aG91dEljb24pIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWljb25XaXRob3V0VGV4dCAmJiAhdGV4dFdpdGhvdXRJY29uKSB7XG4gICAgICAgICAgICAgICAgaWNvblNjYWxlID0gZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0ZXh0V2l0aG91dEljb24gJiYgZ2x5cGhTY2FsZSkge1xuICAgICAgICAgICAgICAgIGdseXBoU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaWNvbldpdGhvdXRUZXh0ICYmIGljb25TY2FsZSkge1xuICAgICAgICAgICAgICAgIGljb25TY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm90YXRpb24gcmFuZ2VzIGl0IGlzIHNhZmUgdG8gc2hvdyB0aGUgZ2x5cGhzXG4gICAgICAgICAgICB2YXIgZ2x5cGhSYW5nZSA9ICghZ2x5cGhTY2FsZSB8fCBpbmZvWyd0ZXh0LWFsbG93LW92ZXJsYXAnXSkgPyBmdWxsUmFuZ2VcbiAgICAgICAgICAgICAgICA6IGNvbGxpc2lvbi5nZXRQbGFjZW1lbnRSYW5nZShnbHlwaC5ib3hlcywgZ2x5cGhTY2FsZSwgaG9yaXpvbnRhbFRleHQpO1xuICAgICAgICAgICAgdmFyIGljb25SYW5nZSA9ICghaWNvblNjYWxlIHx8IGluZm9bJ2ljb24tYWxsb3ctb3ZlcmxhcCddKSA/IGZ1bGxSYW5nZVxuICAgICAgICAgICAgICAgIDogY29sbGlzaW9uLmdldFBsYWNlbWVudFJhbmdlKGljb24uYm94ZXMsIGljb25TY2FsZSwgaG9yaXpvbnRhbEljb24pO1xuXG4gICAgICAgICAgICB2YXIgbWF4UmFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaWNvblJhbmdlWzBdLCBnbHlwaFJhbmdlWzBdKSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChpY29uUmFuZ2VbMV0sIGdseXBoUmFuZ2VbMV0pXTtcblxuICAgICAgICAgICAgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgIXRleHRXaXRob3V0SWNvbikge1xuICAgICAgICAgICAgICAgIGljb25SYW5nZSA9IGdseXBoUmFuZ2UgPSBtYXhSYW5nZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRleHRXaXRob3V0SWNvbikge1xuICAgICAgICAgICAgICAgIGdseXBoUmFuZ2UgPSBtYXhSYW5nZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWljb25XaXRob3V0VGV4dCkge1xuICAgICAgICAgICAgICAgIGljb25SYW5nZSA9IG1heFJhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnNlcnQgZmluYWwgcGxhY2VtZW50IGludG8gY29sbGlzaW9uIHRyZWUgYW5kIGFkZCBnbHlwaHMvaWNvbnMgdG8gYnVmZmVyc1xuICAgICAgICAgICAgaWYgKGdseXBoU2NhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZm9bJ3RleHQtaWdub3JlLXBsYWNlbWVudCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5pbnNlcnQoZ2x5cGguYm94ZXMsIGFuY2hvciwgZ2x5cGhTY2FsZSwgZ2x5cGhSYW5nZSwgaG9yaXpvbnRhbFRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB0aGlzLmFkZFN5bWJvbHModGhpcy5idWZmZXJzLmdseXBoVmVydGV4LCB0aGlzLmVsZW1lbnRHcm91cHMudGV4dCwgZ2x5cGguc2hhcGVzLCBnbHlwaFNjYWxlLCBnbHlwaFJhbmdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGljb25TY2FsZSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5mb1snaWNvbi1pZ25vcmUtcGxhY2VtZW50J10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLmluc2VydChpY29uLmJveGVzLCBhbmNob3IsIGljb25TY2FsZSwgaWNvblJhbmdlLCBob3Jpem9udGFsSWNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHRoaXMuYWRkU3ltYm9scyh0aGlzLmJ1ZmZlcnMuaWNvblZlcnRleCwgdGhpcy5lbGVtZW50R3JvdXBzLmljb24sIGljb24uc2hhcGVzLCBpY29uU2NhbGUsIGljb25SYW5nZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkU3ltYm9scyA9IGZ1bmN0aW9uKGJ1ZmZlciwgZWxlbWVudEdyb3Vwcywgc3ltYm9scywgc2NhbGUsIHBsYWNlbWVudFJhbmdlKSB7XG5cbiAgICB2YXIgem9vbSA9IHRoaXMuY29sbGlzaW9uLnpvb207XG5cbiAgICBlbGVtZW50R3JvdXBzLm1ha2VSb29tRm9yKDApO1xuICAgIHZhciBlbGVtZW50R3JvdXAgPSBlbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG5cbiAgICB2YXIgcGxhY2VtZW50Wm9vbSA9IE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yICsgem9vbTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ltYm9scy5sZW5ndGg7IGsrKykge1xuXG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2tdLFxuICAgICAgICAgICAgdGwgPSBzeW1ib2wudGwsXG4gICAgICAgICAgICB0ciA9IHN5bWJvbC50cixcbiAgICAgICAgICAgIGJsID0gc3ltYm9sLmJsLFxuICAgICAgICAgICAgYnIgPSBzeW1ib2wuYnIsXG4gICAgICAgICAgICB0ZXggPSBzeW1ib2wudGV4LFxuICAgICAgICAgICAgYW5nbGUgPSBzeW1ib2wuYW5nbGUsXG4gICAgICAgICAgICBhbmNob3IgPSBzeW1ib2wuYW5jaG9yLFxuXG5cbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heCh6b29tICsgTWF0aC5sb2coc3ltYm9sLm1pblNjYWxlKSAvIE1hdGguTE4yLCBwbGFjZW1lbnRab29tKSxcbiAgICAgICAgICAgIG1heFpvb20gPSBNYXRoLm1pbih6b29tICsgTWF0aC5sb2coc3ltYm9sLm1heFNjYWxlKSAvIE1hdGguTE4yLCAyNSk7XG5cbiAgICAgICAgaWYgKG1heFpvb20gPD0gbWluWm9vbSkgY29udGludWU7XG5cbiAgICAgICAgLy8gTG93ZXIgbWluIHpvb20gc28gdGhhdCB3aGlsZSBmYWRpbmcgb3V0IHRoZSBsYWJlbCBpdCBjYW4gYmUgc2hvd24gb3V0c2lkZSBvZiBjb2xsaXNpb24tZnJlZSB6b29tIGxldmVsc1xuICAgICAgICBpZiAobWluWm9vbSA9PT0gcGxhY2VtZW50Wm9vbSkgbWluWm9vbSA9IDA7XG5cbiAgICAgICAgLy8gZmlyc3QgdHJpYW5nbGVcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIHRsLngsIHRsLnksIHRleC54LCB0ZXgueSwgYW5nbGUsIG1pblpvb20sIHBsYWNlbWVudFJhbmdlLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIHRyLngsIHRyLnksIHRleC54ICsgdGV4LncsIHRleC55LCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgYmwueCwgYmwueSwgdGV4LngsIHRleC55ICsgdGV4LmgsIGFuZ2xlLCBtaW5ab29tLCBwbGFjZW1lbnRSYW5nZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG5cbiAgICAgICAgLy8gc2Vjb25kIHRyaWFuZ2xlXG4gICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLngsIGFuY2hvci55LCB0ci54LCB0ci55LCB0ZXgueCArIHRleC53LCB0ZXgueSwgYW5nbGUsIG1pblpvb20sIHBsYWNlbWVudFJhbmdlLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgYnVmZmVyLmFkZChhbmNob3IueCwgYW5jaG9yLnksIGJsLngsIGJsLnksIHRleC54LCB0ZXgueSArIHRleC5oLCBhbmdsZSwgbWluWm9vbSwgcGxhY2VtZW50UmFuZ2UsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBidWZmZXIuYWRkKGFuY2hvci54LCBhbmNob3IueSwgYnIueCwgYnIueSwgdGV4LnggKyB0ZXgudywgdGV4LnkgKyB0ZXguaCwgYW5nbGUsIG1pblpvb20sIHBsYWNlbWVudFJhbmdlLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcblxuICAgICAgICBlbGVtZW50R3JvdXAudmVydGV4TGVuZ3RoICs9IDY7XG4gICAgfVxuXG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHRpbGUsIGFjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBmaXJzdGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgZmlyc3RlcnI7XG4gICAgdGhpcy5nZXRUZXh0RGVwZW5kZW5jaWVzKHRpbGUsIGFjdG9yLCBkb25lKTtcbiAgICB0aGlzLmdldEljb25EZXBlbmRlbmNpZXModGlsZSwgYWN0b3IsIGRvbmUpO1xuICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgfHwgZmlyc3Rkb25lKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICBmaXJzdGRvbmUgPSB0cnVlO1xuICAgICAgICBmaXJzdGVyciA9IGVycjtcbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmdldEljb25EZXBlbmRlbmNpZXMgPSBmdW5jdGlvbih0aWxlLCBhY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYnVja2V0ID0gdGhpcztcbiAgICBpZiAodGhpcy5pbmZvWydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgaWYgKFN5bWJvbEJ1Y2tldC5zcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gU3ltYm9sQnVja2V0LnNwcml0ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3Rvci5zZW5kKCdnZXQgc3ByaXRlIGpzb24nLCB7fSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgU3ltYm9sQnVja2V0LnNwcml0ZSA9IGJ1Y2tldC5zcHJpdGUgPSBkYXRhLnNwcml0ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuZ2V0VGV4dERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHRpbGUsIGFjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgdmFyIGluZm8gPSB0aGlzLmluZm87XG5cbiAgICBpZiAodGlsZS5zdGFja3MgPT09IHVuZGVmaW5lZCkgdGlsZS5zdGFja3MgPSB7fTtcbiAgICB2YXIgc3RhY2tzID0gdGhpcy5zdGFja3MgPSB0aWxlLnN0YWNrcztcbiAgICB2YXIgZm9udHN0YWNrID0gaW5mb1sndGV4dC1mb250J107XG4gICAgaWYgKHN0YWNrc1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzW2ZvbnRzdGFja10gPSB7IGdseXBoczoge30sIHJlY3RzOiB7fSB9O1xuICAgIH1cbiAgICB2YXIgc3RhY2sgPSBzdGFja3NbZm9udHN0YWNrXTtcblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRleHQoZmVhdHVyZXMsIGluZm8sIHN0YWNrLmdseXBocyk7XG4gICAgdGhpcy50ZXh0RmVhdHVyZXMgPSBkYXRhLnRleHRGZWF0dXJlcztcblxuICAgIGFjdG9yLnNlbmQoJ2dldCBnbHlwaHMnLCB7XG4gICAgICAgIGlkOiB0aWxlLmlkLFxuICAgICAgICBmb250c3RhY2s6IGZvbnRzdGFjayxcbiAgICAgICAgY29kZXBvaW50czogZGF0YS5jb2RlcG9pbnRzXG4gICAgfSwgZnVuY3Rpb24oZXJyLCBuZXdzdGFjaykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgICAgICB2YXIgbmV3Z2x5cGhzID0gbmV3c3RhY2suZ2x5cGhzO1xuICAgICAgICB2YXIgbmV3cmVjdHMgPSBuZXdzdGFjay5yZWN0cztcbiAgICAgICAgdmFyIGdseXBocyA9IHN0YWNrLmdseXBocztcbiAgICAgICAgdmFyIHJlY3RzID0gc3RhY2sucmVjdHM7XG5cbiAgICAgICAgZm9yICh2YXIgY29kZXBvaW50IGluIG5ld2dseXBocykge1xuICAgICAgICAgICAgZ2x5cGhzW2NvZGVwb2ludF0gPSBuZXdnbHlwaHNbY29kZXBvaW50XTtcbiAgICAgICAgICAgIHJlY3RzW2NvZGVwb2ludF0gPSBuZXdyZWN0c1tjb2RlcG9pbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuaGFzRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZWxlbWVudEdyb3Vwcy50ZXh0LmN1cnJlbnQgfHwgISF0aGlzLmVsZW1lbnRHcm91cHMuaWNvbi5jdXJyZW50O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMYXRMbmc7XG5cbmZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZykge1xuICAgIGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XG4gICAgfVxuICAgIHRoaXMubGF0ID0gK2xhdDtcbiAgICB0aGlzLmxuZyA9ICtsbmc7XG59XG5cblxuLy8gY29uc3RydWN0cyBMYXRMbmcgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblxuTGF0TG5nLmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhdExuZ0JvdW5kcztcblxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4vbGF0bG5nLmpzJyk7XG5cbmZ1bmN0aW9uIExhdExuZ0JvdW5kcyhzdywgbmUpIHtcbiAgICBpZiAoIXN3KSByZXR1cm47XG5cbiAgICB2YXIgbGF0bG5ncyA9IG5lID8gW3N3LCBuZV0gOiBzdztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xuICAgIH1cbn1cblxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcblxuICAgIC8vIGV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50IG9yIGJvdW5kc1xuICAgIGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgc3cgPSB0aGlzLl9zdyxcbiAgICAgICAgICAgIG5lID0gdGhpcy5fbmUsXG4gICAgICAgICAgICBzdzIsIG5lMjtcblxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XG4gICAgICAgICAgICBzdzIgPSBvYmo7XG4gICAgICAgICAgICBuZTIgPSBvYmo7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcbiAgICAgICAgICAgIHN3MiA9IG9iai5fc3c7XG4gICAgICAgICAgICBuZTIgPSBvYmouX25lO1xuXG4gICAgICAgICAgICBpZiAoIXN3MiB8fCAhbmUyKSByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKExhdExuZy5jb252ZXJ0KG9iaikgfHwgTGF0TG5nQm91bmRzLmNvbnZlcnQob2JqKSkgOiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdyAmJiAhbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcbiAgICAgICAgICAgIHRoaXMuX25lID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcbiAgICAgICAgICAgIHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XG4gICAgICAgICAgICBuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xuICAgICAgICAgICAgbmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmcoKHRoaXMuX3N3LmxhdCArIHRoaXMuX25lLmxhdCkgLyAyLCAodGhpcy5fc3cubG5nICsgdGhpcy5fbmUubG5nKSAvIDIpO1xuICAgIH0sXG5cbiAgICBnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N3OyB9LFxuICAgIGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmU7IH0sXG4gICAgZ2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpOyB9LFxuICAgIGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTsgfSxcblxuICAgIGdldFdlc3Q6ICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdy5sbmc7IH0sXG4gICAgZ2V0U291dGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N3LmxhdDsgfSxcbiAgICBnZXRFYXN0OiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmUubG5nOyB9LFxuICAgIGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZS5sYXQ7IH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgTGF0TG5nQm91bmRzIGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG5MYXRMbmdCb3VuZHMuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHJldHVybiBhO1xuICAgIHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4vbGF0bG5nLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLy8gQSBzaW5nbGUgdHJhbnNmb3JtLCBnZW5lcmFsbHkgdXNlZCBmb3IgYSBzaW5nbGUgdGlsZSB0byBiZSBzY2FsZWQsIHJvdGF0ZWQsIGFuZCB6b29tZWQuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShtaW5ab29tLCBtYXhab29tKSB7XG4gICAgdGhpcy50aWxlU2l6ZSA9IDUxMjsgLy8gY29uc3RhbnRcblxuICAgIHRoaXMuX21pblpvb20gPSBtaW5ab29tIHx8IDA7XG4gICAgdGhpcy5fbWF4Wm9vbSA9IG1heFpvb20gfHwgMjI7XG5cbiAgICB0aGlzLmxhdFJhbmdlID0gWy04NSwgODVdO1xuXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuem9vbSA9IDA7XG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgTGF0TG5nKDAsIDApO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgIGdldCBtaW5ab29tKCkgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfSxcbiAgICBzZXQgbWluWm9vbSh6b29tKSB7XG4gICAgICAgIHRoaXMuX21pblpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnpvb20gPSBNYXRoLm1heCh0aGlzLnpvb20sIHpvb20pO1xuICAgIH0sXG5cbiAgICBnZXQgbWF4Wm9vbSgpIHsgcmV0dXJuIHRoaXMuX21heFpvb207IH0sXG4gICAgc2V0IG1heFpvb20oem9vbSkge1xuICAgICAgICB0aGlzLl9tYXhab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5taW4odGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IHdvcmxkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUgKiB0aGlzLnNjYWxlO1xuICAgIH0sXG5cbiAgICBnZXQgY2VudGVyUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUuX2RpdigyKTtcbiAgICB9LFxuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBnZXQgYmVhcmluZygpIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLmFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LFxuICAgIHNldCBiZWFyaW5nKGJlYXJpbmcpIHtcbiAgICAgICAgLy8gY29uZmluZSB0aGUgYW5nbGUgdG8gd2l0aGluIFstMTgwLDE4MF1cbiAgICAgICAgYmVhcmluZyA9ICgoKChiZWFyaW5nICsgMTgwKSAlIDM2MCkgKyAzNjApICUgMzYwKSAtIDE4MDtcbiAgICAgICAgdGhpcy5hbmdsZSA9IC1iZWFyaW5nICogTWF0aC5QSSAvIDE4MDtcbiAgICB9LFxuXG4gICAgZ2V0IHpvb20oKSB7IHJldHVybiB0aGlzLl96b29tOyB9LFxuICAgIHNldCB6b29tKHpvb20pIHtcbiAgICAgICAgem9vbSA9IE1hdGgubWluKE1hdGgubWF4KHpvb20sIHRoaXMubWluWm9vbSksIHRoaXMubWF4Wm9vbSk7XG4gICAgICAgIHRoaXMuX3pvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tU2NhbGUoem9vbSk7XG4gICAgICAgIHRoaXMudGlsZVpvb20gPSBNYXRoLmZsb29yKHpvb20pO1xuICAgICAgICB0aGlzLnpvb21GcmFjdGlvbiA9IHpvb20gLSB0aGlzLnRpbGVab29tO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgem9vbVNjYWxlOiBmdW5jdGlvbih6b29tKSB7IHJldHVybiBNYXRoLnBvdygyLCB6b29tKTsgfSxcbiAgICBzY2FsZVpvb206IGZ1bmN0aW9uKHNjYWxlKSB7IHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjsgfSxcblxuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxhdGxuZywgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmxuZ1gobGF0bG5nLmxuZywgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMubGF0WShsYXRsbmcubGF0LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nKFxuICAgICAgICAgICAgdGhpcy55TGF0KHBvaW50LnksIHdvcmxkU2l6ZSksXG4gICAgICAgICAgICB0aGlzLnhMbmcocG9pbnQueCwgd29ybGRTaXplKSk7XG4gICAgfSxcblxuICAgIGdldCB4KCkgeyByZXR1cm4gdGhpcy5sbmdYKHRoaXMuY2VudGVyLmxuZyk7IH0sXG4gICAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLmxhdFkodGhpcy5jZW50ZXIubGF0KTsgfSxcblxuICAgIGdldCBwb2ludCgpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXG5cbiAgICAvLyBsYXQvbG9uIDwtPiBhYnNvbHV0ZSBwaXhlbCBjb29yZHMgY29udmVydGlvblxuICAgIGxuZ1g6IGZ1bmN0aW9uKGxvbiwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiAoMTgwICsgbG9uKSAqICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC8gMzYwO1xuICAgIH0sXG4gICAgLy8gbGF0aXR1ZGUgdG8gYWJzb2x1dGUgeSBjb29yZFxuICAgIGxhdFk6IGZ1bmN0aW9uKGxhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpO1xuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcblxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4geCAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC0gMTgwO1xuICAgIH0sXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5MiA9IDE4MCAtIHkgKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKTtcbiAgICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnBvaW50TG9jYXRpb24ocG9pbnQpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgc2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24oem9vbSwgY2VudGVyKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5sb2NhdGlvblBvaW50KGNlbnRlciksXG4gICAgICAgICAgICBwMSA9IHRoaXMuc2l6ZS5fc3ViKHApLFxuICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5wb2ludExvY2F0aW9uKHAxKTtcbiAgICAgICAgdGhpcy56b29tID0gem9vbTtcbiAgICAgICAgdGhpcy5wYW5CeShwMS5zdWIodGhpcy5sb2NhdGlvblBvaW50KGxhdGxuZykpKTtcbiAgICB9LFxuXG4gICAgc2V0QmVhcmluZ0Fyb3VuZDogZnVuY3Rpb24oYmVhcmluZywgY2VudGVyKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmxvY2F0aW9uUG9pbnQoY2VudGVyKS5zdWIodGhpcy5jZW50ZXJQb2ludCk7XG4gICAgICAgIHRoaXMucGFuQnkob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICAgICAgdGhpcy5wYW5CeShvZmZzZXQubXVsdCgtMSkpO1xuICAgIH0sXG5cbiAgICBsb2NhdGlvblBvaW50OiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnByb2plY3QobGF0bG5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyUG9pbnQuX3N1Yih0aGlzLnBvaW50Ll9zdWIocCkuX3JvdGF0ZSh0aGlzLmFuZ2xlKSk7XG4gICAgfSxcblxuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIHAyID0gdGhpcy5jZW50ZXJQb2ludC5fc3ViKHApLl9yb3RhdGUoLXRoaXMuYW5nbGUpO1xuICAgICAgICByZXR1cm4gdGhpcy51bnByb2plY3QodGhpcy5wb2ludC5zdWIocDIpKTtcbiAgICB9LFxuXG4gICAgbG9jYXRpb25Db29yZGluYXRlOiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLnpvb21TY2FsZSh0aGlzLnRpbGVab29tKSAvIHRoaXMud29ybGRTaXplO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxuZ1gobGF0bG5nLmxuZykgKiBrLFxuICAgICAgICAgICAgcm93OiB0aGlzLmxhdFkobGF0bG5nLmxhdCkgKiBrLFxuICAgICAgICAgICAgem9vbTogdGhpcy50aWxlWm9vbVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHRpbGVDZW50ZXIsIHApIHtcbiAgICAgICAgdmFyIHpvb21GYWN0b3IgPSB0aGlzLnpvb21TY2FsZSh0aGlzLnpvb21GcmFjdGlvbiksXG4gICAgICAgICAgICBrdCA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20gLSB0aWxlQ2VudGVyLnpvb20pLFxuICAgICAgICAgICAgcDIgPSB0aGlzLmNlbnRlclBvaW50Ll9zdWIocCkuX3JvdGF0ZSgtdGhpcy5hbmdsZSkuX2Rpdih0aGlzLnRpbGVTaXplICogem9vbUZhY3Rvcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogdGlsZUNlbnRlci5jb2x1bW4gKiBrdCAtIHAyLngsXG4gICAgICAgICAgICByb3c6IHRpbGVDZW50ZXIucm93ICoga3QgLSBwMi55LFxuICAgICAgICAgICAgem9vbTogdGhpcy50aWxlWm9vbVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfY29uc3RyYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNlbnRlcikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBtaW5ZLCBtYXhZLCBtaW5YLCBtYXhYLCBzeSwgc3gsIHgyLCB5MixcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLnNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICAgIG1pblkgPSB0aGlzLmxhdFkodGhpcy5sYXRSYW5nZVsxXSk7XG4gICAgICAgICAgICBtYXhZID0gdGhpcy5sYXRZKHRoaXMubGF0UmFuZ2VbMF0pO1xuICAgICAgICAgICAgc3kgPSBtYXhZIC0gbWluWSA8IHNpemUueSA/IHNpemUueSAvIChtYXhZIC0gbWluWSkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICAgIG1pblggPSB0aGlzLmxuZ1godGhpcy5sbmdSYW5nZVswXSk7XG4gICAgICAgICAgICBtYXhYID0gdGhpcy5sbmdYKHRoaXMubG5nUmFuZ2VbMV0pO1xuICAgICAgICAgICAgc3ggPSBtYXhYIC0gbWluWCA8IHNpemUueCA/IHNpemUueCAvIChtYXhYIC0gbWluWCkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaG93IG11Y2ggdGhlIG1hcCBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBzY3JlZW4gaW50byBnaXZlbiBsYXRpdHVkZS9sb25naXR1ZGUgcmFuZ2VzXG4gICAgICAgIHZhciBzID0gTWF0aC5tYXgoc3ggfHwgMCwgc3kgfHwgMCk7XG5cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHN4ID8gKG1heFggKyBtaW5YKSAvIDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgc3kgPyAobWF4WSArIG1pblkpIC8gMiA6IHRoaXMueSkpO1xuICAgICAgICAgICAgdGhpcy56b29tICs9IHRoaXMuc2NhbGVab29tKHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy55LFxuICAgICAgICAgICAgICAgIGgyID0gc2l6ZS55IC8gMjtcblxuICAgICAgICAgICAgaWYgKHkgLSBoMiA8IG1pblkpIHkyID0gbWluWSArIGgyO1xuICAgICAgICAgICAgaWYgKHkgKyBoMiA+IG1heFkpIHkyID0gbWF4WSAtIGgyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgICAgIHcyID0gc2l6ZS54IC8gMjtcblxuICAgICAgICAgICAgaWYgKHggLSB3MiA8IG1pblgpIHgyID0gbWluWCArIHcyO1xuICAgICAgICAgICAgaWYgKHggKyB3MiA+IG1heFgpIHgyID0gbWF4WCAtIHcyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuIHRoZSBtYXAgaWYgdGhlIHNjcmVlbiBnb2VzIG9mZiB0aGUgcmFuZ2VcbiAgICAgICAgaWYgKHgyICE9PSB1bmRlZmluZWQgfHwgeTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgeDIgIT09IHVuZGVmaW5lZCA/IHgyIDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHkyICE9PSB1bmRlZmluZWQgPyB5MiA6IHRoaXMueSkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8vIEZvbnQgZGF0YSBGcm9tIEhlcnNoZXkgU2ltcGxleCBGb250XG4vLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZGF0YWZvcm1hdHMvaGVyc2hleS9cbnZhciBzaW1wbGV4X2ZvbnQgPSB7XG4gICAgXCIgXCI6IFsxNiwgW11dLFxuICAgIFwiIVwiOiBbMTAsIFs1LCAyMSwgNSwgNywgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCJcXFwiXCI6IFsxNiwgWzQsIDIxLCA0LCAxNCwgLTEsIC0xLCAxMiwgMjEsIDEyLCAxNF1dLFxuICAgIFwiI1wiOiBbMjEsIFsxMSwgMjUsIDQsIC03LCAtMSwgLTEsIDE3LCAyNSwgMTAsIC03LCAtMSwgLTEsIDQsIDEyLCAxOCwgMTIsIC0xLCAtMSwgMywgNiwgMTcsIDZdXSxcbiAgICBcIiRcIjogWzIwLCBbOCwgMjUsIDgsIC00LCAtMSwgLTEsIDEyLCAyNSwgMTIsIC00LCAtMSwgLTEsIDE3LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxLCA1LCAyMCwgMywgMTgsIDMsIDE2LCA0LCAxNCwgNSwgMTMsIDcsIDEyLCAxMywgMTAsIDE1LCA5LCAxNiwgOCwgMTcsIDYsIDE3LCAzLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDMsIDNdXSxcbiAgICBcIiVcIjogWzI0LCBbMjEsIDIxLCAzLCAwLCAtMSwgLTEsIDgsIDIxLCAxMCwgMTksIDEwLCAxNywgOSwgMTUsIDcsIDE0LCA1LCAxNCwgMywgMTYsIDMsIDE4LCA0LCAyMCwgNiwgMjEsIDgsIDIxLCAxMCwgMjAsIDEzLCAxOSwgMTYsIDE5LCAxOSwgMjAsIDIxLCAyMSwgLTEsIC0xLCAxNywgNywgMTUsIDYsIDE0LCA0LCAxNCwgMiwgMTYsIDAsIDE4LCAwLCAyMCwgMSwgMjEsIDMsIDIxLCA1LCAxOSwgNywgMTcsIDddXSxcbiAgICBcIiZcIjogWzI2LCBbMjMsIDEyLCAyMywgMTMsIDIyLCAxNCwgMjEsIDE0LCAyMCwgMTMsIDE5LCAxMSwgMTcsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDcsIDAsIDUsIDEsIDQsIDIsIDMsIDQsIDMsIDYsIDQsIDgsIDUsIDksIDEyLCAxMywgMTMsIDE0LCAxNCwgMTYsIDE0LCAxOCwgMTMsIDIwLCAxMSwgMjEsIDksIDIwLCA4LCAxOCwgOCwgMTYsIDksIDEzLCAxMSwgMTAsIDE2LCAzLCAxOCwgMSwgMjAsIDAsIDIyLCAwLCAyMywgMSwgMjMsIDJdXSxcbiAgICBcIidcIjogWzEwLCBbNSwgMTksIDQsIDIwLCA1LCAyMSwgNiwgMjAsIDYsIDE4LCA1LCAxNiwgNCwgMTVdXSxcbiAgICBcIihcIjogWzE0LCBbMTEsIDI1LCA5LCAyMywgNywgMjAsIDUsIDE2LCA0LCAxMSwgNCwgNywgNSwgMiwgNywgLTIsIDksIC01LCAxMSwgLTddXSxcbiAgICBcIilcIjogWzE0LCBbMywgMjUsIDUsIDIzLCA3LCAyMCwgOSwgMTYsIDEwLCAxMSwgMTAsIDcsIDksIDIsIDcsIC0yLCA1LCAtNSwgMywgLTddXSxcbiAgICBcIipcIjogWzE2LCBbOCwgMjEsIDgsIDksIC0xLCAtMSwgMywgMTgsIDEzLCAxMiwgLTEsIC0xLCAxMywgMTgsIDMsIDEyXV0sXG4gICAgXCIrXCI6IFsyNiwgWzEzLCAxOCwgMTMsIDAsIC0xLCAtMSwgNCwgOSwgMjIsIDldXSxcbiAgICBcIixcIjogWzEwLCBbNiwgMSwgNSwgMCwgNCwgMSwgNSwgMiwgNiwgMSwgNiwgLTEsIDUsIC0zLCA0LCAtNF1dLFxuICAgIFwiLVwiOiBbMjYsIFs0LCA5LCAyMiwgOV1dLFxuICAgIFwiLlwiOiBbMTAsIFs1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCIvXCI6IFsyMiwgWzIwLCAyNSwgMiwgLTddXSxcbiAgICBcIjBcIjogWzIwLCBbOSwgMjEsIDYsIDIwLCA0LCAxNywgMywgMTIsIDMsIDksIDQsIDQsIDYsIDEsIDksIDAsIDExLCAwLCAxNCwgMSwgMTYsIDQsIDE3LCA5LCAxNywgMTIsIDE2LCAxNywgMTQsIDIwLCAxMSwgMjEsIDksIDIxXV0sXG4gICAgXCIxXCI6IFsyMCwgWzYsIDE3LCA4LCAxOCwgMTEsIDIxLCAxMSwgMF1dLFxuICAgIFwiMlwiOiBbMjAsIFs0LCAxNiwgNCwgMTcsIDUsIDE5LCA2LCAyMCwgOCwgMjEsIDEyLCAyMSwgMTQsIDIwLCAxNSwgMTksIDE2LCAxNywgMTYsIDE1LCAxNSwgMTMsIDEzLCAxMCwgMywgMCwgMTcsIDBdXSxcbiAgICBcIjNcIjogWzIwLCBbNSwgMjEsIDE2LCAyMSwgMTAsIDEzLCAxMywgMTMsIDE1LCAxMiwgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcbiAgICBcIjRcIjogWzIwLCBbMTMsIDIxLCAzLCA3LCAxOCwgNywgLTEsIC0xLCAxMywgMjEsIDEzLCAwXV0sXG4gICAgXCI1XCI6IFsyMCwgWzE1LCAyMSwgNSwgMjEsIDQsIDEyLCA1LCAxMywgOCwgMTQsIDExLCAxNCwgMTQsIDEzLCAxNiwgMTEsIDE3LCA4LCAxNywgNiwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNF1dLFxuICAgIFwiNlwiOiBbMjAsIFsxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCAxMCwgMjEsIDcsIDIwLCA1LCAxNywgNCwgMTIsIDQsIDcsIDUsIDMsIDcsIDEsIDEwLCAwLCAxMSwgMCwgMTQsIDEsIDE2LCAzLCAxNywgNiwgMTcsIDcsIDE2LCAxMCwgMTQsIDEyLCAxMSwgMTMsIDEwLCAxMywgNywgMTIsIDUsIDEwLCA0LCA3XV0sXG4gICAgXCI3XCI6IFsyMCwgWzE3LCAyMSwgNywgMCwgLTEsIC0xLCAzLCAyMSwgMTcsIDIxXV0sXG4gICAgXCI4XCI6IFsyMCwgWzgsIDIxLCA1LCAyMCwgNCwgMTgsIDQsIDE2LCA1LCAxNCwgNywgMTMsIDExLCAxMiwgMTQsIDExLCAxNiwgOSwgMTcsIDcsIDE3LCA0LCAxNiwgMiwgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA3LCA0LCA5LCA2LCAxMSwgOSwgMTIsIDEzLCAxMywgMTUsIDE0LCAxNiwgMTYsIDE2LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxXV0sXG4gICAgXCI5XCI6IFsyMCwgWzE2LCAxNCwgMTUsIDExLCAxMywgOSwgMTAsIDgsIDksIDgsIDYsIDksIDQsIDExLCAzLCAxNCwgMywgMTUsIDQsIDE4LCA2LCAyMCwgOSwgMjEsIDEwLCAyMSwgMTMsIDIwLCAxNSwgMTgsIDE2LCAxNCwgMTYsIDksIDE1LCA0LCAxMywgMSwgMTAsIDAsIDgsIDAsIDUsIDEsIDQsIDNdXSxcbiAgICBcIjpcIjogWzEwLCBbNSwgMTQsIDQsIDEzLCA1LCAxMiwgNiwgMTMsIDUsIDE0LCAtMSwgLTEsIDUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcbiAgICBcIjtcIjogWzEwLCBbNSwgMTQsIDQsIDEzLCA1LCAxMiwgNiwgMTMsIDUsIDE0LCAtMSwgLTEsIDYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcbiAgICBcIjxcIjogWzI0LCBbMjAsIDE4LCA0LCA5LCAyMCwgMF1dLFxuICAgIFwiPVwiOiBbMjYsIFs0LCAxMiwgMjIsIDEyLCAtMSwgLTEsIDQsIDYsIDIyLCA2XV0sXG4gICAgXCI+XCI6IFsyNCwgWzQsIDE4LCAyMCwgOSwgNCwgMF1dLFxuICAgIFwiP1wiOiBbMTgsIFszLCAxNiwgMywgMTcsIDQsIDE5LCA1LCAyMCwgNywgMjEsIDExLCAyMSwgMTMsIDIwLCAxNCwgMTksIDE1LCAxNywgMTUsIDE1LCAxNCwgMTMsIDEzLCAxMiwgOSwgMTAsIDksIDcsIC0xLCAtMSwgOSwgMiwgOCwgMSwgOSwgMCwgMTAsIDEsIDksIDJdXSxcbiAgICBcIkBcIjogWzI3LCBbMTgsIDEzLCAxNywgMTUsIDE1LCAxNiwgMTIsIDE2LCAxMCwgMTUsIDksIDE0LCA4LCAxMSwgOCwgOCwgOSwgNiwgMTEsIDUsIDE0LCA1LCAxNiwgNiwgMTcsIDgsIC0xLCAtMSwgMTIsIDE2LCAxMCwgMTQsIDksIDExLCA5LCA4LCAxMCwgNiwgMTEsIDUsIC0xLCAtMSwgMTgsIDE2LCAxNywgOCwgMTcsIDYsIDE5LCA1LCAyMSwgNSwgMjMsIDcsIDI0LCAxMCwgMjQsIDEyLCAyMywgMTUsIDIyLCAxNywgMjAsIDE5LCAxOCwgMjAsIDE1LCAyMSwgMTIsIDIxLCA5LCAyMCwgNywgMTksIDUsIDE3LCA0LCAxNSwgMywgMTIsIDMsIDksIDQsIDYsIDUsIDQsIDcsIDIsIDksIDEsIDEyLCAwLCAxNSwgMCwgMTgsIDEsIDIwLCAyLCAyMSwgMywgLTEsIC0xLCAxOSwgMTYsIDE4LCA4LCAxOCwgNiwgMTksIDVdXSxcbiAgICBcIkFcIjogWzE4LCBbOSwgMjEsIDEsIDAsIC0xLCAtMSwgOSwgMjEsIDE3LCAwLCAtMSwgLTEsIDQsIDcsIDE0LCA3XV0sXG4gICAgXCJCXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNSwgMTcsIDEzLCAxNiwgMTIsIDEzLCAxMSwgLTEsIC0xLCA0LCAxMSwgMTMsIDExLCAxNiwgMTAsIDE3LCA5LCAxOCwgNywgMTgsIDQsIDE3LCAyLCAxNiwgMSwgMTMsIDAsIDQsIDBdXSxcbiAgICBcIkNcIjogWzIxLCBbMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1XV0sXG4gICAgXCJEXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMSwgMjEsIDE0LCAyMCwgMTYsIDE4LCAxNywgMTYsIDE4LCAxMywgMTgsIDgsIDE3LCA1LCAxNiwgMywgMTQsIDEsIDExLCAwLCA0LCAwXV0sXG4gICAgXCJFXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxNywgMjEsIC0xLCAtMSwgNCwgMTEsIDEyLCAxMSwgLTEsIC0xLCA0LCAwLCAxNywgMF1dLFxuICAgIFwiRlwiOiBbMTgsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTcsIDIxLCAtMSwgLTEsIDQsIDExLCAxMiwgMTFdXSxcbiAgICBcIkdcIjogWzIxLCBbMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1LCAxOCwgOCwgLTEsIC0xLCAxMywgOCwgMTgsIDhdXSxcbiAgICBcIkhcIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTgsIDIxLCAxOCwgMCwgLTEsIC0xLCA0LCAxMSwgMTgsIDExXV0sXG4gICAgXCJJXCI6IFs4LCBbNCwgMjEsIDQsIDBdXSxcbiAgICBcIkpcIjogWzE2LCBbMTIsIDIxLCAxMiwgNSwgMTEsIDIsIDEwLCAxLCA4LCAwLCA2LCAwLCA0LCAxLCAzLCAyLCAyLCA1LCAyLCA3XV0sXG4gICAgXCJLXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgNCwgNywgLTEsIC0xLCA5LCAxMiwgMTgsIDBdXSxcbiAgICBcIkxcIjogWzE3LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMCwgMTYsIDBdXSxcbiAgICBcIk1cIjogWzI0LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMTIsIDAsIC0xLCAtMSwgMjAsIDIxLCAyMCwgMF1dLFxuICAgIFwiTlwiOiBbMjIsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTgsIDAsIC0xLCAtMSwgMTgsIDIxLCAxOCwgMF1dLFxuICAgIFwiT1wiOiBbMjIsIFs5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1LCAxOSwgOCwgMTksIDEzLCAxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxXV0sXG4gICAgXCJQXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNCwgMTcsIDEyLCAxNiwgMTEsIDEzLCAxMCwgNCwgMTBdXSxcbiAgICBcIlFcIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgLTEsIC0xLCAxMiwgNCwgMTgsIC0yXV0sXG4gICAgXCJSXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNSwgMTcsIDEzLCAxNiwgMTIsIDEzLCAxMSwgNCwgMTEsIC0xLCAtMSwgMTEsIDExLCAxOCwgMF1dLFxuICAgIFwiU1wiOiBbMjAsIFsxNywgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMSwgNSwgMjAsIDMsIDE4LCAzLCAxNiwgNCwgMTQsIDUsIDEzLCA3LCAxMiwgMTMsIDEwLCAxNSwgOSwgMTYsIDgsIDE3LCA2LCAxNywgMywgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCAzLCAzXV0sXG4gICAgXCJUXCI6IFsxNiwgWzgsIDIxLCA4LCAwLCAtMSwgLTEsIDEsIDIxLCAxNSwgMjFdXSxcbiAgICBcIlVcIjogWzIyLCBbNCwgMjEsIDQsIDYsIDUsIDMsIDcsIDEsIDEwLCAwLCAxMiwgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNiwgMTgsIDIxXV0sXG4gICAgXCJWXCI6IFsxOCwgWzEsIDIxLCA5LCAwLCAtMSwgLTEsIDE3LCAyMSwgOSwgMF1dLFxuICAgIFwiV1wiOiBbMjQsIFsyLCAyMSwgNywgMCwgLTEsIC0xLCAxMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCAxNywgMCwgLTEsIC0xLCAyMiwgMjEsIDE3LCAwXV0sXG4gICAgXCJYXCI6IFsyMCwgWzMsIDIxLCAxNywgMCwgLTEsIC0xLCAxNywgMjEsIDMsIDBdXSxcbiAgICBcIllcIjogWzE4LCBbMSwgMjEsIDksIDExLCA5LCAwLCAtMSwgLTEsIDE3LCAyMSwgOSwgMTFdXSxcbiAgICBcIlpcIjogWzIwLCBbMTcsIDIxLCAzLCAwLCAtMSwgLTEsIDMsIDIxLCAxNywgMjEsIC0xLCAtMSwgMywgMCwgMTcsIDBdXSxcbiAgICBcIltcIjogWzE0LCBbNCwgMjUsIDQsIC03LCAtMSwgLTEsIDUsIDI1LCA1LCAtNywgLTEsIC0xLCA0LCAyNSwgMTEsIDI1LCAtMSwgLTEsIDQsIC03LCAxMSwgLTddXSxcbiAgICBcIlxcXFxcIjogWzE0LCBbMCwgMjEsIDE0LCAtM11dLFxuICAgIFwiXVwiOiBbMTQsIFs5LCAyNSwgOSwgLTcsIC0xLCAtMSwgMTAsIDI1LCAxMCwgLTcsIC0xLCAtMSwgMywgMjUsIDEwLCAyNSwgLTEsIC0xLCAzLCAtNywgMTAsIC03XV0sXG4gICAgXCJeXCI6IFsxNiwgWzYsIDE1LCA4LCAxOCwgMTAsIDE1LCAtMSwgLTEsIDMsIDEyLCA4LCAxNywgMTMsIDEyLCAtMSwgLTEsIDgsIDE3LCA4LCAwXV0sXG4gICAgXCJfXCI6IFsxNiwgWzAsIC0yLCAxNiwgLTJdXSxcbiAgICBcImBcIjogWzEwLCBbNiwgMjEsIDUsIDIwLCA0LCAxOCwgNCwgMTYsIDUsIDE1LCA2LCAxNiwgNSwgMTddXSxcbiAgICBcImFcIjogWzE5LCBbMTUsIDE0LCAxNSwgMCwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJiXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDExLCA2LCAxMywgOCwgMTQsIDExLCAxNCwgMTMsIDEzLCAxNSwgMTEsIDE2LCA4LCAxNiwgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgOCwgMCwgNiwgMSwgNCwgM11dLFxuICAgIFwiY1wiOiBbMTgsIFsxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJkXCI6IFsxOSwgWzE1LCAyMSwgMTUsIDAsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZVwiOiBbMTgsIFszLCA4LCAxNSwgOCwgMTUsIDEwLCAxNCwgMTIsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJmXCI6IFsxMiwgWzEwLCAyMSwgOCwgMjEsIDYsIDIwLCA1LCAxNywgNSwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcbiAgICBcImdcIjogWzE5LCBbMTUsIDE0LCAxNSwgLTIsIDE0LCAtNSwgMTMsIC02LCAxMSwgLTcsIDgsIC03LCA2LCAtNiwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJoXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXG4gICAgXCJpXCI6IFs4LCBbMywgMjEsIDQsIDIwLCA1LCAyMSwgNCwgMjIsIDMsIDIxLCAtMSwgLTEsIDQsIDE0LCA0LCAwXV0sXG4gICAgXCJqXCI6IFsxMCwgWzUsIDIxLCA2LCAyMCwgNywgMjEsIDYsIDIyLCA1LCAyMSwgLTEsIC0xLCA2LCAxNCwgNiwgLTMsIDUsIC02LCAzLCAtNywgMSwgLTddXSxcbiAgICBcImtcIjogWzE3LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTQsIDE0LCA0LCA0LCAtMSwgLTEsIDgsIDgsIDE1LCAwXV0sXG4gICAgXCJsXCI6IFs4LCBbNCwgMjEsIDQsIDBdXSxcbiAgICBcIm1cIjogWzMwLCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDAsIC0xLCAtMSwgMTUsIDEwLCAxOCwgMTMsIDIwLCAxNCwgMjMsIDE0LCAyNSwgMTMsIDI2LCAxMCwgMjYsIDBdXSxcbiAgICBcIm5cIjogWzE5LCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDBdXSxcbiAgICBcIm9cIjogWzE5LCBbOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgMywgMTYsIDYsIDE2LCA4LCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNF1dLFxuICAgIFwicFwiOiBbMTksIFs0LCAxNCwgNCwgLTcsIC0xLCAtMSwgNCwgMTEsIDYsIDEzLCA4LCAxNCwgMTEsIDE0LCAxMywgMTMsIDE1LCAxMSwgMTYsIDgsIDE2LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA4LCAwLCA2LCAxLCA0LCAzXV0sXG4gICAgXCJxXCI6IFsxOSwgWzE1LCAxNCwgMTUsIC03LCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcInJcIjogWzEzLCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgOCwgNSwgMTEsIDcsIDEzLCA5LCAxNCwgMTIsIDE0XV0sXG4gICAgXCJzXCI6IFsxNywgWzE0LCAxMSwgMTMsIDEzLCAxMCwgMTQsIDcsIDE0LCA0LCAxMywgMywgMTEsIDQsIDksIDYsIDgsIDExLCA3LCAxMywgNiwgMTQsIDQsIDE0LCAzLCAxMywgMSwgMTAsIDAsIDcsIDAsIDQsIDEsIDMsIDNdXSxcbiAgICBcInRcIjogWzEyLCBbNSwgMjEsIDUsIDQsIDYsIDEsIDgsIDAsIDEwLCAwLCAtMSwgLTEsIDIsIDE0LCA5LCAxNF1dLFxuICAgIFwidVwiOiBbMTksIFs0LCAxNCwgNCwgNCwgNSwgMSwgNywgMCwgMTAsIDAsIDEyLCAxLCAxNSwgNCwgLTEsIC0xLCAxNSwgMTQsIDE1LCAwXV0sXG4gICAgXCJ2XCI6IFsxNiwgWzIsIDE0LCA4LCAwLCAtMSwgLTEsIDE0LCAxNCwgOCwgMF1dLFxuICAgIFwid1wiOiBbMjIsIFszLCAxNCwgNywgMCwgLTEsIC0xLCAxMSwgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCAxNSwgMCwgLTEsIC0xLCAxOSwgMTQsIDE1LCAwXV0sXG4gICAgXCJ4XCI6IFsxNywgWzMsIDE0LCAxNCwgMCwgLTEsIC0xLCAxNCwgMTQsIDMsIDBdXSxcbiAgICBcInlcIjogWzE2LCBbMiwgMTQsIDgsIDAsIC0xLCAtMSwgMTQsIDE0LCA4LCAwLCA2LCAtNCwgNCwgLTYsIDIsIC03LCAxLCAtN11dLFxuICAgIFwielwiOiBbMTcsIFsxNCwgMTQsIDMsIDAsIC0xLCAtMSwgMywgMTQsIDE0LCAxNCwgLTEsIC0xLCAzLCAwLCAxNCwgMF1dLFxuICAgIFwie1wiOiBbMTQsIFs5LCAyNSwgNywgMjQsIDYsIDIzLCA1LCAyMSwgNSwgMTksIDYsIDE3LCA3LCAxNiwgOCwgMTQsIDgsIDEyLCA2LCAxMCwgLTEsIC0xLCA3LCAyNCwgNiwgMjIsIDYsIDIwLCA3LCAxOCwgOCwgMTcsIDksIDE1LCA5LCAxMywgOCwgMTEsIDQsIDksIDgsIDcsIDksIDUsIDksIDMsIDgsIDEsIDcsIDAsIDYsIC0yLCA2LCAtNCwgNywgLTYsIC0xLCAtMSwgNiwgOCwgOCwgNiwgOCwgNCwgNywgMiwgNiwgMSwgNSwgLTEsIDUsIC0zLCA2LCAtNSwgNywgLTYsIDksIC03XV0sXG4gICAgXCJ8XCI6IFs4LCBbNCwgMjUsIDQsIC03XV0sXG4gICAgXCJ9XCI6IFsxNCwgWzUsIDI1LCA3LCAyNCwgOCwgMjMsIDksIDIxLCA5LCAxOSwgOCwgMTcsIDcsIDE2LCA2LCAxNCwgNiwgMTIsIDgsIDEwLCAtMSwgLTEsIDcsIDI0LCA4LCAyMiwgOCwgMjAsIDcsIDE4LCA2LCAxNywgNSwgMTUsIDUsIDEzLCA2LCAxMSwgMTAsIDksIDYsIDcsIDUsIDUsIDUsIDMsIDYsIDEsIDcsIDAsIDgsIC0yLCA4LCAtNCwgNywgLTYsIC0xLCAtMSwgOCwgOCwgNiwgNiwgNiwgNCwgNywgMiwgOCwgMSwgOSwgLTEsIDksIC0zLCA4LCAtNSwgNywgLTYsIDUsIC03XV0sXG4gICAgXCJ+XCI6IFsyNCwgWzMsIDYsIDMsIDgsIDQsIDExLCA2LCAxMiwgOCwgMTIsIDEwLCAxMSwgMTQsIDgsIDE2LCA3LCAxOCwgNywgMjAsIDgsIDIxLCAxMCwgLTEsIC0xLCAzLCA4LCA0LCAxMCwgNiwgMTEsIDgsIDExLCAxMCwgMTAsIDE0LCA3LCAxNiwgNiwgMTgsIDYsIDIwLCA3LCAyMSwgMTAsIDIxLCAxMl1dLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0VmVydGljZXModGV4dCwgbGVmdCwgYmFzZWxpbmUsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuXG4gICAgdmFyIHN0cm9rZXMgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBqLCBsZW4yLCBnbHlwaCwgZGF0YSwgeCwgeSwgcHJldjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2x5cGggPSBzaW1wbGV4X2ZvbnRbdGV4dFtpXV07XG4gICAgICAgIGlmICghZ2x5cGgpIGNvbnRpbnVlO1xuICAgICAgICBwcmV2ID0gbnVsbDtcblxuICAgICAgICBmb3IgKGogPSAwLCBsZW4yID0gZ2x5cGhbMV0ubGVuZ3RoOyBqIDwgbGVuMjsgaiArPSAyKSB7XG4gICAgICAgICAgICBpZiAoZ2x5cGhbMV1bal0gPT09IC0xICYmIGdseXBoWzFdW2ogKyAxXSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbnVsbDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gbGVmdCArIGdseXBoWzFdW2pdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgeSA9IGJhc2VsaW5lIC0gZ2x5cGhbMV1baiArIDFdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlcy5wdXNoKHByZXYueCwgcHJldi55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IHt4OiB4LCB5OiB5fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZWZ0ICs9IGdseXBoWzBdICogc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cm9rZXM7XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4yLjBcbiAqL1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG4oZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9e307dHlwZW9mIGV4cG9ydHM9PVwidW5kZWZpbmVkXCI/dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZGVmaW5lLmFtZD09XCJvYmplY3RcIiYmZGVmaW5lLmFtZD8odC5leHBvcnRzPXt9LGRlZmluZShmdW5jdGlvbigpe3JldHVybiB0LmV4cG9ydHN9KSk6dC5leHBvcnRzPXR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCI/d2luZG93OmU6dC5leHBvcnRzPWV4cG9ydHMsZnVuY3Rpb24oZSl7aWYoIXQpdmFyIHQ9MWUtNjtpZighbil2YXIgbj10eXBlb2YgRmxvYXQzMkFycmF5IT1cInVuZGVmaW5lZFwiP0Zsb2F0MzJBcnJheTpBcnJheTtpZighcil2YXIgcj1NYXRoLnJhbmRvbTt2YXIgaT17fTtpLnNldE1hdHJpeEFycmF5VHlwZT1mdW5jdGlvbihlKXtuPWV9LHR5cGVvZiBlIT1cInVuZGVmaW5lZFwiJiYoZS5nbE1hdHJpeD1pKTt2YXIgcz17fTtzLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDIpO3JldHVybiBlWzBdPTAsZVsxXT0wLGV9LHMuY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oMik7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdH0scy5mcm9tVmFsdWVzPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IG4oMik7cmV0dXJuIHJbMF09ZSxyWzFdPXQscn0scy5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZX0scy5zZXQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXQsZVsxXT1uLGV9LHMuYWRkPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdK25bMF0sZVsxXT10WzFdK25bMV0sZX0scy5zdWJ0cmFjdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXS1uWzBdLGVbMV09dFsxXS1uWzFdLGV9LHMuc3ViPXMuc3VidHJhY3Qscy5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSpuWzBdLGVbMV09dFsxXSpuWzFdLGV9LHMubXVsPXMubXVsdGlwbHkscy5kaXZpZGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0vblswXSxlWzFdPXRbMV0vblsxXSxlfSxzLmRpdj1zLmRpdmlkZSxzLm1pbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09TWF0aC5taW4odFswXSxuWzBdKSxlWzFdPU1hdGgubWluKHRbMV0sblsxXSksZX0scy5tYXg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPU1hdGgubWF4KHRbMF0sblswXSksZVsxXT1NYXRoLm1heCh0WzFdLG5bMV0pLGV9LHMuc2NhbGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0qbixlWzFdPXRbMV0qbixlfSxzLnNjYWxlQW5kQWRkPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBlWzBdPXRbMF0rblswXSpyLGVbMV09dFsxXStuWzFdKnIsZX0scy5kaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0tZVswXSxyPXRbMV0tZVsxXTtyZXR1cm4gTWF0aC5zcXJ0KG4qbityKnIpfSxzLmRpc3Q9cy5kaXN0YW5jZSxzLnNxdWFyZWREaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0tZVswXSxyPXRbMV0tZVsxXTtyZXR1cm4gbipuK3Iqcn0scy5zcXJEaXN0PXMuc3F1YXJlZERpc3RhbmNlLHMubGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVybiBNYXRoLnNxcnQodCp0K24qbil9LHMubGVuPXMubGVuZ3RoLHMuc3F1YXJlZExlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXTtyZXR1cm4gdCp0K24qbn0scy5zcXJMZW49cy5zcXVhcmVkTGVuZ3RoLHMubmVnYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09LXRbMF0sZVsxXT0tdFsxXSxlfSxzLm5vcm1hbGl6ZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9bipuK3IqcjtyZXR1cm4gaT4wJiYoaT0xL01hdGguc3FydChpKSxlWzBdPXRbMF0qaSxlWzFdPXRbMV0qaSksZX0scy5kb3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXSp0WzBdK2VbMV0qdFsxXX0scy5jcm9zcz1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSpuWzFdLXRbMV0qblswXTtyZXR1cm4gZVswXT1lWzFdPTAsZVsyXT1yLGV9LHMubGVycD1mdW5jdGlvbihlLHQsbixyKXt2YXIgaT10WzBdLHM9dFsxXTtyZXR1cm4gZVswXT1pK3IqKG5bMF0taSksZVsxXT1zK3IqKG5bMV0tcyksZX0scy5yYW5kb209ZnVuY3Rpb24oZSx0KXt0PXR8fDE7dmFyIG49cigpKjIqTWF0aC5QSTtyZXR1cm4gZVswXT1NYXRoLmNvcyhuKSp0LGVbMV09TWF0aC5zaW4obikqdCxlfSxzLnRyYW5zZm9ybU1hdDI9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdO3JldHVybiBlWzBdPW5bMF0qcituWzJdKmksZVsxXT1uWzFdKnIrblszXSppLGV9LHMudHJhbnNmb3JtTWF0MmQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdO3JldHVybiBlWzBdPW5bMF0qcituWzJdKmkrbls0XSxlWzFdPW5bMV0qcituWzNdKmkrbls1XSxlfSxzLnRyYW5zZm9ybU1hdDM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdO3JldHVybiBlWzBdPW5bMF0qcituWzNdKmkrbls2XSxlWzFdPW5bMV0qcituWzRdKmkrbls3XSxlfSxzLnRyYW5zZm9ybU1hdDQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdO3JldHVybiBlWzBdPW5bMF0qcituWzRdKmkrblsxMl0sZVsxXT1uWzFdKnIrbls1XSppK25bMTNdLGV9LHMuZm9yRWFjaD1mdW5jdGlvbigpe3ZhciBlPXMuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKHQsbixyLGkscyxvKXt2YXIgdSxhO258fChuPTIpLHJ8fChyPTApLGk/YT1NYXRoLm1pbihpKm4rcix0Lmxlbmd0aCk6YT10Lmxlbmd0aDtmb3IodT1yO3U8YTt1Kz1uKWVbMF09dFt1XSxlWzFdPXRbdSsxXSxzKGUsZSxvKSx0W3VdPWVbMF0sdFt1KzFdPWVbMV07cmV0dXJuIHR9fSgpLHMuc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwidmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUudmVjMj1zKTt2YXIgbz17fTtvLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDMpO3JldHVybiBlWzBdPTAsZVsxXT0wLGVbMl09MCxlfSxvLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDMpO3JldHVybiB0WzBdPWVbMF0sdFsxXT1lWzFdLHRbMl09ZVsyXSx0fSxvLmZyb21WYWx1ZXM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBpPW5ldyBuKDMpO3JldHVybiBpWzBdPWUsaVsxXT10LGlbMl09cixpfSxvLmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZX0sby5zZXQ9ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGVbMF09dCxlWzFdPW4sZVsyXT1yLGV9LG8uYWRkPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdK25bMF0sZVsxXT10WzFdK25bMV0sZVsyXT10WzJdK25bMl0sZX0sby5zdWJ0cmFjdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXS1uWzBdLGVbMV09dFsxXS1uWzFdLGVbMl09dFsyXS1uWzJdLGV9LG8uc3ViPW8uc3VidHJhY3Qsby5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSpuWzBdLGVbMV09dFsxXSpuWzFdLGVbMl09dFsyXSpuWzJdLGV9LG8ubXVsPW8ubXVsdGlwbHksby5kaXZpZGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0vblswXSxlWzFdPXRbMV0vblsxXSxlWzJdPXRbMl0vblsyXSxlfSxvLmRpdj1vLmRpdmlkZSxvLm1pbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09TWF0aC5taW4odFswXSxuWzBdKSxlWzFdPU1hdGgubWluKHRbMV0sblsxXSksZVsyXT1NYXRoLm1pbih0WzJdLG5bMl0pLGV9LG8ubWF4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT1NYXRoLm1heCh0WzBdLG5bMF0pLGVbMV09TWF0aC5tYXgodFsxXSxuWzFdKSxlWzJdPU1hdGgubWF4KHRbMl0sblsyXSksZX0sby5zY2FsZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSpuLGVbMV09dFsxXSpuLGVbMl09dFsyXSpuLGV9LG8uc2NhbGVBbmRBZGQ9ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGVbMF09dFswXStuWzBdKnIsZVsxXT10WzFdK25bMV0qcixlWzJdPXRbMl0rblsyXSpyLGV9LG8uZGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLWVbMF0scj10WzFdLWVbMV0saT10WzJdLWVbMl07cmV0dXJuIE1hdGguc3FydChuKm4rcipyK2kqaSl9LG8uZGlzdD1vLmRpc3RhbmNlLG8uc3F1YXJlZERpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXS1lWzBdLHI9dFsxXS1lWzFdLGk9dFsyXS1lWzJdO3JldHVybiBuKm4rcipyK2kqaX0sby5zcXJEaXN0PW8uc3F1YXJlZERpc3RhbmNlLG8ubGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXTtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtuKm4rcipyKX0sby5sZW49by5sZW5ndGgsby5zcXVhcmVkTGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXTtyZXR1cm4gdCp0K24qbityKnJ9LG8uc3FyTGVuPW8uc3F1YXJlZExlbmd0aCxvLm5lZ2F0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPS10WzBdLGVbMV09LXRbMV0sZVsyXT0tdFsyXSxlfSxvLm5vcm1hbGl6ZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPW4qbityKnIraSppO3JldHVybiBzPjAmJihzPTEvTWF0aC5zcXJ0KHMpLGVbMF09dFswXSpzLGVbMV09dFsxXSpzLGVbMl09dFsyXSpzKSxlfSxvLmRvdD1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdKnRbMF0rZVsxXSp0WzFdK2VbMl0qdFsyXX0sby5jcm9zcz1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89blswXSx1PW5bMV0sYT1uWzJdO3JldHVybiBlWzBdPWkqYS1zKnUsZVsxXT1zKm8tciphLGVbMl09cip1LWkqbyxlfSxvLmxlcnA9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9dFswXSxzPXRbMV0sbz10WzJdO3JldHVybiBlWzBdPWkrciooblswXS1pKSxlWzFdPXMrciooblsxXS1zKSxlWzJdPW8rciooblsyXS1vKSxlfSxvLnJhbmRvbT1mdW5jdGlvbihlLHQpe3Q9dHx8MTt2YXIgbj1yKCkqMipNYXRoLlBJLGk9cigpKjItMSxzPU1hdGguc3FydCgxLWkqaSkqdDtyZXR1cm4gZVswXT1NYXRoLmNvcyhuKSpzLGVbMV09TWF0aC5zaW4obikqcyxlWzJdPWkqdCxlfSxvLnRyYW5zZm9ybU1hdDQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXTtyZXR1cm4gZVswXT1uWzBdKnIrbls0XSppK25bOF0qcytuWzEyXSxlWzFdPW5bMV0qcituWzVdKmkrbls5XSpzK25bMTNdLGVbMl09blsyXSpyK25bNl0qaStuWzEwXSpzK25bMTRdLGV9LG8udHJhbnNmb3JtTWF0Mz1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdO3JldHVybiBlWzBdPXIqblswXStpKm5bM10rcypuWzZdLGVbMV09cipuWzFdK2kqbls0XStzKm5bN10sZVsyXT1yKm5bMl0raSpuWzVdK3Mqbls4XSxlfSxvLnRyYW5zZm9ybVF1YXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPW5bMF0sdT1uWzFdLGE9blsyXSxmPW5bM10sbD1mKnIrdSpzLWEqaSxjPWYqaSthKnItbypzLGg9ZipzK28qaS11KnIscD0tbypyLXUqaS1hKnM7cmV0dXJuIGVbMF09bCpmK3AqLW8rYyotYS1oKi11LGVbMV09YypmK3AqLXUraCotby1sKi1hLGVbMl09aCpmK3AqLWErbCotdS1jKi1vLGV9LG8uZm9yRWFjaD1mdW5jdGlvbigpe3ZhciBlPW8uY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKHQsbixyLGkscyxvKXt2YXIgdSxhO258fChuPTMpLHJ8fChyPTApLGk/YT1NYXRoLm1pbihpKm4rcix0Lmxlbmd0aCk6YT10Lmxlbmd0aDtmb3IodT1yO3U8YTt1Kz1uKWVbMF09dFt1XSxlWzFdPXRbdSsxXSxlWzJdPXRbdSsyXSxzKGUsZSxvKSx0W3VdPWVbMF0sdFt1KzFdPWVbMV0sdFt1KzJdPWVbMl07cmV0dXJuIHR9fSgpLG8uc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwidmVjMyhcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUudmVjMz1vKTt2YXIgdT17fTt1LmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDQpO3JldHVybiBlWzBdPTAsZVsxXT0wLGVbMl09MCxlWzNdPTAsZX0sdS5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbig0KTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0WzJdPWVbMl0sdFszXT1lWzNdLHR9LHUuZnJvbVZhbHVlcz1mdW5jdGlvbihlLHQscixpKXt2YXIgcz1uZXcgbig0KTtyZXR1cm4gc1swXT1lLHNbMV09dCxzWzJdPXIsc1szXT1pLHN9LHUuY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZX0sdS5zZXQ9ZnVuY3Rpb24oZSx0LG4scixpKXtyZXR1cm4gZVswXT10LGVbMV09bixlWzJdPXIsZVszXT1pLGV9LHUuYWRkPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdK25bMF0sZVsxXT10WzFdK25bMV0sZVsyXT10WzJdK25bMl0sZVszXT10WzNdK25bM10sZX0sdS5zdWJ0cmFjdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXS1uWzBdLGVbMV09dFsxXS1uWzFdLGVbMl09dFsyXS1uWzJdLGVbM109dFszXS1uWzNdLGV9LHUuc3ViPXUuc3VidHJhY3QsdS5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09dFswXSpuWzBdLGVbMV09dFsxXSpuWzFdLGVbMl09dFsyXSpuWzJdLGVbM109dFszXSpuWzNdLGV9LHUubXVsPXUubXVsdGlwbHksdS5kaXZpZGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0vblswXSxlWzFdPXRbMV0vblsxXSxlWzJdPXRbMl0vblsyXSxlWzNdPXRbM10vblszXSxlfSx1LmRpdj11LmRpdmlkZSx1Lm1pbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09TWF0aC5taW4odFswXSxuWzBdKSxlWzFdPU1hdGgubWluKHRbMV0sblsxXSksZVsyXT1NYXRoLm1pbih0WzJdLG5bMl0pLGVbM109TWF0aC5taW4odFszXSxuWzNdKSxlfSx1Lm1heD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGVbMF09TWF0aC5tYXgodFswXSxuWzBdKSxlWzFdPU1hdGgubWF4KHRbMV0sblsxXSksZVsyXT1NYXRoLm1heCh0WzJdLG5bMl0pLGVbM109TWF0aC5tYXgodFszXSxuWzNdKSxlfSx1LnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVswXT10WzBdKm4sZVsxXT10WzFdKm4sZVsyXT10WzJdKm4sZVszXT10WzNdKm4sZX0sdS5zY2FsZUFuZEFkZD1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gZVswXT10WzBdK25bMF0qcixlWzFdPXRbMV0rblsxXSpyLGVbMl09dFsyXStuWzJdKnIsZVszXT10WzNdK25bM10qcixlfSx1LmRpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXS1lWzBdLHI9dFsxXS1lWzFdLGk9dFsyXS1lWzJdLHM9dFszXS1lWzNdO3JldHVybiBNYXRoLnNxcnQobipuK3IqcitpKmkrcypzKX0sdS5kaXN0PXUuZGlzdGFuY2UsdS5zcXVhcmVkRGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLWVbMF0scj10WzFdLWVbMV0saT10WzJdLWVbMl0scz10WzNdLWVbM107cmV0dXJuIG4qbityKnIraSppK3Mqc30sdS5zcXJEaXN0PXUuc3F1YXJlZERpc3RhbmNlLHUubGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxpPWVbM107cmV0dXJuIE1hdGguc3FydCh0KnQrbipuK3IqcitpKmkpfSx1Lmxlbj11Lmxlbmd0aCx1LnNxdWFyZWRMZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV0scj1lWzJdLGk9ZVszXTtyZXR1cm4gdCp0K24qbityKnIraSppfSx1LnNxckxlbj11LnNxdWFyZWRMZW5ndGgsdS5uZWdhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT0tdFswXSxlWzFdPS10WzFdLGVbMl09LXRbMl0sZVszXT0tdFszXSxlfSx1Lm5vcm1hbGl6ZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz1uKm4rcipyK2kqaStzKnM7cmV0dXJuIG8+MCYmKG89MS9NYXRoLnNxcnQobyksZVswXT10WzBdKm8sZVsxXT10WzFdKm8sZVsyXT10WzJdKm8sZVszXT10WzNdKm8pLGV9LHUuZG90PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF0qdFswXStlWzFdKnRbMV0rZVsyXSp0WzJdK2VbM10qdFszXX0sdS5sZXJwPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXRbMF0scz10WzFdLG89dFsyXSx1PXRbM107cmV0dXJuIGVbMF09aStyKihuWzBdLWkpLGVbMV09cytyKihuWzFdLXMpLGVbMl09bytyKihuWzJdLW8pLGVbM109dStyKihuWzNdLXUpLGV9LHUucmFuZG9tPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9dHx8MSxlWzBdPXIoKSxlWzFdPXIoKSxlWzJdPXIoKSxlWzNdPXIoKSx1Lm5vcm1hbGl6ZShlLGUpLHUuc2NhbGUoZSxlLHQpLGV9LHUudHJhbnNmb3JtTWF0ND1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXTtyZXR1cm4gZVswXT1uWzBdKnIrbls0XSppK25bOF0qcytuWzEyXSpvLGVbMV09blsxXSpyK25bNV0qaStuWzldKnMrblsxM10qbyxlWzJdPW5bMl0qcituWzZdKmkrblsxMF0qcytuWzE0XSpvLGVbM109blszXSpyK25bN10qaStuWzExXSpzK25bMTVdKm8sZX0sdS50cmFuc2Zvcm1RdWF0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz1uWzBdLHU9blsxXSxhPW5bMl0sZj1uWzNdLGw9ZipyK3Uqcy1hKmksYz1mKmkrYSpyLW8qcyxoPWYqcytvKmktdSpyLHA9LW8qci11KmktYSpzO3JldHVybiBlWzBdPWwqZitwKi1vK2MqLWEtaCotdSxlWzFdPWMqZitwKi11K2gqLW8tbCotYSxlWzJdPWgqZitwKi1hK2wqLXUtYyotbyxlfSx1LmZvckVhY2g9ZnVuY3Rpb24oKXt2YXIgZT11LmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbih0LG4scixpLHMsbyl7dmFyIHUsYTtufHwobj00KSxyfHwocj0wKSxpP2E9TWF0aC5taW4oaSpuK3IsdC5sZW5ndGgpOmE9dC5sZW5ndGg7Zm9yKHU9cjt1PGE7dSs9billWzBdPXRbdV0sZVsxXT10W3UrMV0sZVsyXT10W3UrMl0sZVszXT10W3UrM10scyhlLGUsbyksdFt1XT1lWzBdLHRbdSsxXT1lWzFdLHRbdSsyXT1lWzJdLHRbdSszXT1lWzNdO3JldHVybiB0fX0oKSx1LnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cInZlYzQoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIiwgXCIrZVszXStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLnZlYzQ9dSk7dmFyIGE9e307YS5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbig0KTtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0xLGV9LGEuY2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG4oNCk7cmV0dXJuIHRbMF09ZVswXSx0WzFdPWVbMV0sdFsyXT1lWzJdLHRbM109ZVszXSx0fSxhLmNvcHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXT10WzBdLGVbMV09dFsxXSxlWzJdPXRbMl0sZVszXT10WzNdLGV9LGEuaWRlbnRpdHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MSxlfSxhLnRyYW5zcG9zZT1mdW5jdGlvbihlLHQpe2lmKGU9PT10KXt2YXIgbj10WzFdO2VbMV09dFsyXSxlWzJdPW59ZWxzZSBlWzBdPXRbMF0sZVsxXT10WzJdLGVbMl09dFsxXSxlWzNdPXRbM107cmV0dXJuIGV9LGEuaW52ZXJ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPW4qcy1pKnI7cmV0dXJuIG8/KG89MS9vLGVbMF09cypvLGVbMV09LXIqbyxlWzJdPS1pKm8sZVszXT1uKm8sZSk6bnVsbH0sYS5hZGpvaW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXTtyZXR1cm4gZVswXT10WzNdLGVbMV09LXRbMV0sZVsyXT0tdFsyXSxlWzNdPW4sZX0sYS5kZXRlcm1pbmFudD1mdW5jdGlvbihlKXtyZXR1cm4gZVswXSplWzNdLWVbMl0qZVsxXX0sYS5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PW5bMF0sYT1uWzFdLGY9blsyXSxsPW5bM107cmV0dXJuIGVbMF09cip1K2kqZixlWzFdPXIqYStpKmwsZVsyXT1zKnUrbypmLGVbM109cyphK28qbCxlfSxhLm11bD1hLm11bHRpcGx5LGEucm90YXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9TWF0aC5zaW4obiksYT1NYXRoLmNvcyhuKTtyZXR1cm4gZVswXT1yKmEraSp1LGVbMV09ciotdStpKmEsZVsyXT1zKmErbyp1LGVbM109cyotdStvKmEsZX0sYS5zY2FsZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PW5bMF0sYT1uWzFdO3JldHVybiBlWzBdPXIqdSxlWzFdPWkqYSxlWzJdPXMqdSxlWzNdPW8qYSxlfSxhLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cIm1hdDIoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIiwgXCIrZVszXStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLm1hdDI9YSk7dmFyIGY9e307Zi5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbig2KTtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0xLGVbNF09MCxlWzVdPTAsZX0sZi5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbig2KTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0WzJdPWVbMl0sdFszXT1lWzNdLHRbNF09ZVs0XSx0WzVdPWVbNV0sdH0sZi5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlWzRdPXRbNF0sZVs1XT10WzVdLGV9LGYuaWRlbnRpdHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MSxlWzRdPTAsZVs1XT0wLGV9LGYuaW52ZXJ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPXRbNF0sdT10WzVdLGE9bipzLXIqaTtyZXR1cm4gYT8oYT0xL2EsZVswXT1zKmEsZVsxXT0tciphLGVbMl09LWkqYSxlWzNdPW4qYSxlWzRdPShpKnUtcypvKSphLGVbNV09KHIqby1uKnUpKmEsZSk6bnVsbH0sZi5kZXRlcm1pbmFudD1mdW5jdGlvbihlKXtyZXR1cm4gZVswXSplWzNdLWVbMV0qZVsyXX0sZi5tdWx0aXBseT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXRbNF0sYT10WzVdLGY9blswXSxsPW5bMV0sYz1uWzJdLGg9blszXSxwPW5bNF0sZD1uWzVdO3JldHVybiBlWzBdPXIqZitpKmMsZVsxXT1yKmwraSpoLGVbMl09cypmK28qYyxlWzNdPXMqbCtvKmgsZVs0XT1mKnUrYyphK3AsZVs1XT1sKnUraCphK2QsZX0sZi5tdWw9Zi5tdWx0aXBseSxmLnJvdGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXRbNF0sYT10WzVdLGY9TWF0aC5zaW4obiksbD1NYXRoLmNvcyhuKTtyZXR1cm4gZVswXT1yKmwraSpmLGVbMV09LXIqZitpKmwsZVsyXT1zKmwrbypmLGVbM109LXMqZitsKm8sZVs0XT1sKnUrZiphLGVbNV09bCphLWYqdSxlfSxmLnNjYWxlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uWzBdLGk9blsxXTtyZXR1cm4gZVswXT10WzBdKnIsZVsxXT10WzFdKmksZVsyXT10WzJdKnIsZVszXT10WzNdKmksZVs0XT10WzRdKnIsZVs1XT10WzVdKmksZX0sZi50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZVs0XT10WzRdK25bMF0sZVs1XT10WzVdK25bMV0sZX0sZi5zdHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYXQyZChcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiLCBcIitlWzNdK1wiLCBcIitlWzRdK1wiLCBcIitlWzVdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUubWF0MmQ9Zik7dmFyIGw9e307bC5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbig5KTtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MSxlWzVdPTAsZVs2XT0wLGVbN109MCxlWzhdPTEsZX0sbC5mcm9tTWF0ND1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbNF0sZVs0XT10WzVdLGVbNV09dFs2XSxlWzZdPXRbOF0sZVs3XT10WzldLGVbOF09dFsxMF0sZX0sbC5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbig5KTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0WzJdPWVbMl0sdFszXT1lWzNdLHRbNF09ZVs0XSx0WzVdPWVbNV0sdFs2XT1lWzZdLHRbN109ZVs3XSx0WzhdPWVbOF0sdH0sbC5jb3B5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlWzRdPXRbNF0sZVs1XT10WzVdLGVbNl09dFs2XSxlWzddPXRbN10sZVs4XT10WzhdLGV9LGwuaWRlbnRpdHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTEsZVs1XT0wLGVbNl09MCxlWzddPTAsZVs4XT0xLGV9LGwudHJhbnNwb3NlPWZ1bmN0aW9uKGUsdCl7aWYoZT09PXQpe3ZhciBuPXRbMV0scj10WzJdLGk9dFs1XTtlWzFdPXRbM10sZVsyXT10WzZdLGVbM109bixlWzVdPXRbN10sZVs2XT1yLGVbN109aX1lbHNlIGVbMF09dFswXSxlWzFdPXRbM10sZVsyXT10WzZdLGVbM109dFsxXSxlWzRdPXRbNF0sZVs1XT10WzddLGVbNl09dFsyXSxlWzddPXRbNV0sZVs4XT10WzhdO3JldHVybiBlfSxsLmludmVydD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz10WzRdLHU9dFs1XSxhPXRbNl0sZj10WzddLGw9dFs4XSxjPWwqby11KmYsaD0tbCpzK3UqYSxwPWYqcy1vKmEsZD1uKmMrcipoK2kqcDtyZXR1cm4gZD8oZD0xL2QsZVswXT1jKmQsZVsxXT0oLWwqcitpKmYpKmQsZVsyXT0odSpyLWkqbykqZCxlWzNdPWgqZCxlWzRdPShsKm4taSphKSpkLGVbNV09KC11Km4raSpzKSpkLGVbNl09cCpkLGVbN109KC1mKm4rciphKSpkLGVbOF09KG8qbi1yKnMpKmQsZSk6bnVsbH0sbC5hZGpvaW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPXRbNF0sdT10WzVdLGE9dFs2XSxmPXRbN10sbD10WzhdO3JldHVybiBlWzBdPW8qbC11KmYsZVsxXT1pKmYtcipsLGVbMl09cip1LWkqbyxlWzNdPXUqYS1zKmwsZVs0XT1uKmwtaSphLGVbNV09aSpzLW4qdSxlWzZdPXMqZi1vKmEsZVs3XT1yKmEtbipmLGVbOF09bipvLXIqcyxlfSxsLmRldGVybWluYW50PWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxpPWVbM10scz1lWzRdLG89ZVs1XSx1PWVbNl0sYT1lWzddLGY9ZVs4XTtyZXR1cm4gdCooZipzLW8qYSkrbiooLWYqaStvKnUpK3IqKGEqaS1zKnUpfSxsLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9dFs0XSxhPXRbNV0sZj10WzZdLGw9dFs3XSxjPXRbOF0saD1uWzBdLHA9blsxXSxkPW5bMl0sdj1uWzNdLG09bls0XSxnPW5bNV0seT1uWzZdLGI9bls3XSx3PW5bOF07cmV0dXJuIGVbMF09aCpyK3AqbytkKmYsZVsxXT1oKmkrcCp1K2QqbCxlWzJdPWgqcytwKmErZCpjLGVbM109dipyK20qbytnKmYsZVs0XT12KmkrbSp1K2cqbCxlWzVdPXYqcyttKmErZypjLGVbNl09eSpyK2Iqbyt3KmYsZVs3XT15KmkrYip1K3cqbCxlWzhdPXkqcytiKmErdypjLGV9LGwubXVsPWwubXVsdGlwbHksbC50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT10WzRdLGE9dFs1XSxmPXRbNl0sbD10WzddLGM9dFs4XSxoPW5bMF0scD1uWzFdO3JldHVybiBlWzBdPXIsZVsxXT1pLGVbMl09cyxlWzNdPW8sZVs0XT11LGVbNV09YSxlWzZdPWgqcitwKm8rZixlWzddPWgqaStwKnUrbCxlWzhdPWgqcytwKmErYyxlfSxsLnJvdGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PXRbNF0sYT10WzVdLGY9dFs2XSxsPXRbN10sYz10WzhdLGg9TWF0aC5zaW4obikscD1NYXRoLmNvcyhuKTtyZXR1cm4gZVswXT1wKnIraCpvLGVbMV09cCppK2gqdSxlWzJdPXAqcytoKmEsZVszXT1wKm8taCpyLGVbNF09cCp1LWgqaSxlWzVdPXAqYS1oKnMsZVs2XT1mLGVbN109bCxlWzhdPWMsZX0sbC5zY2FsZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9blswXSxpPW5bMV07cmV0dXJuIGVbMF09cip0WzBdLGVbMV09cip0WzFdLGVbMl09cip0WzJdLGVbM109aSp0WzNdLGVbNF09aSp0WzRdLGVbNV09aSp0WzVdLGVbNl09dFs2XSxlWzddPXRbN10sZVs4XT10WzhdLGV9LGwuZnJvbU1hdDJkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT0wLGVbM109dFsyXSxlWzRdPXRbM10sZVs1XT0wLGVbNl09dFs0XSxlWzddPXRbNV0sZVs4XT0xLGV9LGwuZnJvbVF1YXQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl0scz10WzNdLG89bituLHU9cityLGE9aStpLGY9bipvLGw9bip1LGM9biphLGg9cip1LHA9ciphLGQ9aSphLHY9cypvLG09cyp1LGc9cyphO3JldHVybiBlWzBdPTEtKGgrZCksZVszXT1sK2csZVs2XT1jLW0sZVsxXT1sLWcsZVs0XT0xLShmK2QpLGVbN109cCt2LGVbMl09YyttLGVbNV09cC12LGVbOF09MS0oZitoKSxlfSxsLm5vcm1hbEZyb21NYXQ0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPXRbNF0sdT10WzVdLGE9dFs2XSxmPXRbN10sbD10WzhdLGM9dFs5XSxoPXRbMTBdLHA9dFsxMV0sZD10WzEyXSx2PXRbMTNdLG09dFsxNF0sZz10WzE1XSx5PW4qdS1yKm8sYj1uKmEtaSpvLHc9bipmLXMqbyxFPXIqYS1pKnUsUz1yKmYtcyp1LHg9aSpmLXMqYSxUPWwqdi1jKmQsTj1sKm0taCpkLEM9bCpnLXAqZCxrPWMqbS1oKnYsTD1jKmctcCp2LEE9aCpnLXAqbSxPPXkqQS1iKkwrdyprK0UqQy1TKk4reCpUO3JldHVybiBPPyhPPTEvTyxlWzBdPSh1KkEtYSpMK2YqaykqTyxlWzFdPShhKkMtbypBLWYqTikqTyxlWzJdPShvKkwtdSpDK2YqVCkqTyxlWzNdPShpKkwtcipBLXMqaykqTyxlWzRdPShuKkEtaSpDK3MqTikqTyxlWzVdPShyKkMtbipMLXMqVCkqTyxlWzZdPSh2KngtbSpTK2cqRSkqTyxlWzddPShtKnctZCp4LWcqYikqTyxlWzhdPShkKlMtdip3K2cqeSkqTyxlKTpudWxsfSxsLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cIm1hdDMoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIiwgXCIrZVszXStcIiwgXCIrZVs0XStcIiwgXCIrZVs1XStcIiwgXCIrZVs2XStcIiwgXCIrZVs3XStcIiwgXCIrZVs4XStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLm1hdDM9bCk7dmFyIGM9e307Yy5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbigxNik7cmV0dXJuIGVbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTAsZVs1XT0xLGVbNl09MCxlWzddPTAsZVs4XT0wLGVbOV09MCxlWzEwXT0xLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSxlfSxjLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuKDE2KTtyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVsxXSx0WzJdPWVbMl0sdFszXT1lWzNdLHRbNF09ZVs0XSx0WzVdPWVbNV0sdFs2XT1lWzZdLHRbN109ZVs3XSx0WzhdPWVbOF0sdFs5XT1lWzldLHRbMTBdPWVbMTBdLHRbMTFdPWVbMTFdLHRbMTJdPWVbMTJdLHRbMTNdPWVbMTNdLHRbMTRdPWVbMTRdLHRbMTVdPWVbMTVdLHR9LGMuY29weT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPXRbMF0sZVsxXT10WzFdLGVbMl09dFsyXSxlWzNdPXRbM10sZVs0XT10WzRdLGVbNV09dFs1XSxlWzZdPXRbNl0sZVs3XT10WzddLGVbOF09dFs4XSxlWzldPXRbOV0sZVsxMF09dFsxMF0sZVsxMV09dFsxMV0sZVsxMl09dFsxMl0sZVsxM109dFsxM10sZVsxNF09dFsxNF0sZVsxNV09dFsxNV0sZX0sYy5pZGVudGl0eT1mdW5jdGlvbihlKXtyZXR1cm4gZVswXT0xLGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MCxlWzVdPTEsZVs2XT0wLGVbN109MCxlWzhdPTAsZVs5XT0wLGVbMTBdPTEsZVsxMV09MCxlWzEyXT0wLGVbMTNdPTAsZVsxNF09MCxlWzE1XT0xLGV9LGMudHJhbnNwb3NlPWZ1bmN0aW9uKGUsdCl7aWYoZT09PXQpe3ZhciBuPXRbMV0scj10WzJdLGk9dFszXSxzPXRbNl0sbz10WzddLHU9dFsxMV07ZVsxXT10WzRdLGVbMl09dFs4XSxlWzNdPXRbMTJdLGVbNF09bixlWzZdPXRbOV0sZVs3XT10WzEzXSxlWzhdPXIsZVs5XT1zLGVbMTFdPXRbMTRdLGVbMTJdPWksZVsxM109byxlWzE0XT11fWVsc2UgZVswXT10WzBdLGVbMV09dFs0XSxlWzJdPXRbOF0sZVszXT10WzEyXSxlWzRdPXRbMV0sZVs1XT10WzVdLGVbNl09dFs5XSxlWzddPXRbMTNdLGVbOF09dFsyXSxlWzldPXRbNl0sZVsxMF09dFsxMF0sZVsxMV09dFsxNF0sZVsxMl09dFszXSxlWzEzXT10WzddLGVbMTRdPXRbMTFdLGVbMTVdPXRbMTVdO3JldHVybiBlfSxjLmludmVydD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz10WzRdLHU9dFs1XSxhPXRbNl0sZj10WzddLGw9dFs4XSxjPXRbOV0saD10WzEwXSxwPXRbMTFdLGQ9dFsxMl0sdj10WzEzXSxtPXRbMTRdLGc9dFsxNV0seT1uKnUtcipvLGI9biphLWkqbyx3PW4qZi1zKm8sRT1yKmEtaSp1LFM9cipmLXMqdSx4PWkqZi1zKmEsVD1sKnYtYypkLE49bCptLWgqZCxDPWwqZy1wKmQsaz1jKm0taCp2LEw9YypnLXAqdixBPWgqZy1wKm0sTz15KkEtYipMK3cqaytFKkMtUypOK3gqVDtyZXR1cm4gTz8oTz0xL08sZVswXT0odSpBLWEqTCtmKmspKk8sZVsxXT0oaSpMLXIqQS1zKmspKk8sZVsyXT0odip4LW0qUytnKkUpKk8sZVszXT0oaCpTLWMqeC1wKkUpKk8sZVs0XT0oYSpDLW8qQS1mKk4pKk8sZVs1XT0obipBLWkqQytzKk4pKk8sZVs2XT0obSp3LWQqeC1nKmIpKk8sZVs3XT0obCp4LWgqdytwKmIpKk8sZVs4XT0obypMLXUqQytmKlQpKk8sZVs5XT0ocipDLW4qTC1zKlQpKk8sZVsxMF09KGQqUy12KncrZyp5KSpPLGVbMTFdPShjKnctbCpTLXAqeSkqTyxlWzEyXT0odSpOLW8qay1hKlQpKk8sZVsxM109KG4qay1yKk4raSpUKSpPLGVbMTRdPSh2KmItZCpFLW0qeSkqTyxlWzE1XT0obCpFLWMqYitoKnkpKk8sZSk6bnVsbH0sYy5hZGpvaW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSxvPXRbNF0sdT10WzVdLGE9dFs2XSxmPXRbN10sbD10WzhdLGM9dFs5XSxoPXRbMTBdLHA9dFsxMV0sZD10WzEyXSx2PXRbMTNdLG09dFsxNF0sZz10WzE1XTtyZXR1cm4gZVswXT11KihoKmctcCptKS1jKihhKmctZiptKSt2KihhKnAtZipoKSxlWzFdPS0ociooaCpnLXAqbSktYyooaSpnLXMqbSkrdiooaSpwLXMqaCkpLGVbMl09ciooYSpnLWYqbSktdSooaSpnLXMqbSkrdiooaSpmLXMqYSksZVszXT0tKHIqKGEqcC1mKmgpLXUqKGkqcC1zKmgpK2MqKGkqZi1zKmEpKSxlWzRdPS0obyooaCpnLXAqbSktbCooYSpnLWYqbSkrZCooYSpwLWYqaCkpLGVbNV09biooaCpnLXAqbSktbCooaSpnLXMqbSkrZCooaSpwLXMqaCksZVs2XT0tKG4qKGEqZy1mKm0pLW8qKGkqZy1zKm0pK2QqKGkqZi1zKmEpKSxlWzddPW4qKGEqcC1mKmgpLW8qKGkqcC1zKmgpK2wqKGkqZi1zKmEpLGVbOF09byooYypnLXAqdiktbCoodSpnLWYqdikrZCoodSpwLWYqYyksZVs5XT0tKG4qKGMqZy1wKnYpLWwqKHIqZy1zKnYpK2QqKHIqcC1zKmMpKSxlWzEwXT1uKih1KmctZip2KS1vKihyKmctcyp2KStkKihyKmYtcyp1KSxlWzExXT0tKG4qKHUqcC1mKmMpLW8qKHIqcC1zKmMpK2wqKHIqZi1zKnUpKSxlWzEyXT0tKG8qKGMqbS1oKnYpLWwqKHUqbS1hKnYpK2QqKHUqaC1hKmMpKSxlWzEzXT1uKihjKm0taCp2KS1sKihyKm0taSp2KStkKihyKmgtaSpjKSxlWzE0XT0tKG4qKHUqbS1hKnYpLW8qKHIqbS1pKnYpK2QqKHIqYS1pKnUpKSxlWzE1XT1uKih1KmgtYSpjKS1vKihyKmgtaSpjKStsKihyKmEtaSp1KSxlfSxjLmRldGVybWluYW50PWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxpPWVbM10scz1lWzRdLG89ZVs1XSx1PWVbNl0sYT1lWzddLGY9ZVs4XSxsPWVbOV0sYz1lWzEwXSxoPWVbMTFdLHA9ZVsxMl0sZD1lWzEzXSx2PWVbMTRdLG09ZVsxNV0sZz10Km8tbipzLHk9dCp1LXIqcyxiPXQqYS1pKnMsdz1uKnUtcipvLEU9biphLWkqbyxTPXIqYS1pKnUseD1mKmQtbCpwLFQ9Zip2LWMqcCxOPWYqbS1oKnAsQz1sKnYtYypkLGs9bCptLWgqZCxMPWMqbS1oKnY7cmV0dXJuIGcqTC15KmsrYipDK3cqTi1FKlQrUyp4fSxjLm11bHRpcGx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9dFs0XSxhPXRbNV0sZj10WzZdLGw9dFs3XSxjPXRbOF0saD10WzldLHA9dFsxMF0sZD10WzExXSx2PXRbMTJdLG09dFsxM10sZz10WzE0XSx5PXRbMTVdLGI9blswXSx3PW5bMV0sRT1uWzJdLFM9blszXTtyZXR1cm4gZVswXT1iKnIrdyp1K0UqYytTKnYsZVsxXT1iKmkrdyphK0UqaCtTKm0sZVsyXT1iKnMrdypmK0UqcCtTKmcsZVszXT1iKm8rdypsK0UqZCtTKnksYj1uWzRdLHc9bls1XSxFPW5bNl0sUz1uWzddLGVbNF09YipyK3cqdStFKmMrUyp2LGVbNV09YippK3cqYStFKmgrUyptLGVbNl09YipzK3cqZitFKnArUypnLGVbN109YipvK3cqbCtFKmQrUyp5LGI9bls4XSx3PW5bOV0sRT1uWzEwXSxTPW5bMTFdLGVbOF09YipyK3cqdStFKmMrUyp2LGVbOV09YippK3cqYStFKmgrUyptLGVbMTBdPWIqcyt3KmYrRSpwK1MqZyxlWzExXT1iKm8rdypsK0UqZCtTKnksYj1uWzEyXSx3PW5bMTNdLEU9blsxNF0sUz1uWzE1XSxlWzEyXT1iKnIrdyp1K0UqYytTKnYsZVsxM109YippK3cqYStFKmgrUyptLGVbMTRdPWIqcyt3KmYrRSpwK1MqZyxlWzE1XT1iKm8rdypsK0UqZCtTKnksZX0sYy5tdWw9Yy5tdWx0aXBseSxjLnRyYW5zbGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9blswXSxpPW5bMV0scz1uWzJdLG8sdSxhLGYsbCxjLGgscCxkLHYsbSxnO3JldHVybiB0PT09ZT8oZVsxMl09dFswXSpyK3RbNF0qaSt0WzhdKnMrdFsxMl0sZVsxM109dFsxXSpyK3RbNV0qaSt0WzldKnMrdFsxM10sZVsxNF09dFsyXSpyK3RbNl0qaSt0WzEwXSpzK3RbMTRdLGVbMTVdPXRbM10qcit0WzddKmkrdFsxMV0qcyt0WzE1XSk6KG89dFswXSx1PXRbMV0sYT10WzJdLGY9dFszXSxsPXRbNF0sYz10WzVdLGg9dFs2XSxwPXRbN10sZD10WzhdLHY9dFs5XSxtPXRbMTBdLGc9dFsxMV0sZVswXT1vLGVbMV09dSxlWzJdPWEsZVszXT1mLGVbNF09bCxlWzVdPWMsZVs2XT1oLGVbN109cCxlWzhdPWQsZVs5XT12LGVbMTBdPW0sZVsxMV09ZyxlWzEyXT1vKnIrbCppK2Qqcyt0WzEyXSxlWzEzXT11KnIrYyppK3Yqcyt0WzEzXSxlWzE0XT1hKnIraCppK20qcyt0WzE0XSxlWzE1XT1mKnIrcCppK2cqcyt0WzE1XSksZX0sYy5zY2FsZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9blswXSxpPW5bMV0scz1uWzJdO3JldHVybiBlWzBdPXRbMF0qcixlWzFdPXRbMV0qcixlWzJdPXRbMl0qcixlWzNdPXRbM10qcixlWzRdPXRbNF0qaSxlWzVdPXRbNV0qaSxlWzZdPXRbNl0qaSxlWzddPXRbN10qaSxlWzhdPXRbOF0qcyxlWzldPXRbOV0qcyxlWzEwXT10WzEwXSpzLGVbMTFdPXRbMTFdKnMsZVsxMl09dFsxMl0sZVsxM109dFsxM10sZVsxNF09dFsxNF0sZVsxNV09dFsxNV0sZX0sYy5yb3RhdGU9ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIHM9aVswXSxvPWlbMV0sdT1pWzJdLGE9TWF0aC5zcXJ0KHMqcytvKm8rdSp1KSxmLGwsYyxoLHAsZCx2LG0sZyx5LGIsdyxFLFMseCxULE4sQyxrLEwsQSxPLE0sXztyZXR1cm4gTWF0aC5hYnMoYSk8dD9udWxsOihhPTEvYSxzKj1hLG8qPWEsdSo9YSxmPU1hdGguc2luKHIpLGw9TWF0aC5jb3MociksYz0xLWwsaD1uWzBdLHA9blsxXSxkPW5bMl0sdj1uWzNdLG09bls0XSxnPW5bNV0seT1uWzZdLGI9bls3XSx3PW5bOF0sRT1uWzldLFM9blsxMF0seD1uWzExXSxUPXMqcypjK2wsTj1vKnMqYyt1KmYsQz11KnMqYy1vKmYsaz1zKm8qYy11KmYsTD1vKm8qYytsLEE9dSpvKmMrcypmLE89cyp1KmMrbypmLE09byp1KmMtcypmLF89dSp1KmMrbCxlWzBdPWgqVCttKk4rdypDLGVbMV09cCpUK2cqTitFKkMsZVsyXT1kKlQreSpOK1MqQyxlWzNdPXYqVCtiKk4reCpDLGVbNF09aCprK20qTCt3KkEsZVs1XT1wKmsrZypMK0UqQSxlWzZdPWQqayt5KkwrUypBLGVbN109diprK2IqTCt4KkEsZVs4XT1oKk8rbSpNK3cqXyxlWzldPXAqTytnKk0rRSpfLGVbMTBdPWQqTyt5Kk0rUypfLGVbMTFdPXYqTytiKk0reCpfLG4hPT1lJiYoZVsxMl09blsxMl0sZVsxM109blsxM10sZVsxNF09blsxNF0sZVsxNV09blsxNV0pLGUpfSxjLnJvdGF0ZVg9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPU1hdGguc2luKG4pLGk9TWF0aC5jb3Mobikscz10WzRdLG89dFs1XSx1PXRbNl0sYT10WzddLGY9dFs4XSxsPXRbOV0sYz10WzEwXSxoPXRbMTFdO3JldHVybiB0IT09ZSYmKGVbMF09dFswXSxlWzFdPXRbMV0sZVsyXT10WzJdLGVbM109dFszXSxlWzEyXT10WzEyXSxlWzEzXT10WzEzXSxlWzE0XT10WzE0XSxlWzE1XT10WzE1XSksZVs0XT1zKmkrZipyLGVbNV09byppK2wqcixlWzZdPXUqaStjKnIsZVs3XT1hKmkraCpyLGVbOF09ZippLXMqcixlWzldPWwqaS1vKnIsZVsxMF09YyppLXUqcixlWzExXT1oKmktYSpyLGV9LGMucm90YXRlWT1mdW5jdGlvbihlLHQsbil7dmFyIHI9TWF0aC5zaW4obiksaT1NYXRoLmNvcyhuKSxzPXRbMF0sbz10WzFdLHU9dFsyXSxhPXRbM10sZj10WzhdLGw9dFs5XSxjPXRbMTBdLGg9dFsxMV07cmV0dXJuIHQhPT1lJiYoZVs0XT10WzRdLGVbNV09dFs1XSxlWzZdPXRbNl0sZVs3XT10WzddLGVbMTJdPXRbMTJdLGVbMTNdPXRbMTNdLGVbMTRdPXRbMTRdLGVbMTVdPXRbMTVdKSxlWzBdPXMqaS1mKnIsZVsxXT1vKmktbCpyLGVbMl09dSppLWMqcixlWzNdPWEqaS1oKnIsZVs4XT1zKnIrZippLGVbOV09bypyK2wqaSxlWzEwXT11KnIrYyppLGVbMTFdPWEqcitoKmksZX0sYy5yb3RhdGVaPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1NYXRoLnNpbihuKSxpPU1hdGguY29zKG4pLHM9dFswXSxvPXRbMV0sdT10WzJdLGE9dFszXSxmPXRbNF0sbD10WzVdLGM9dFs2XSxoPXRbN107cmV0dXJuIHQhPT1lJiYoZVs4XT10WzhdLGVbOV09dFs5XSxlWzEwXT10WzEwXSxlWzExXT10WzExXSxlWzEyXT10WzEyXSxlWzEzXT10WzEzXSxlWzE0XT10WzE0XSxlWzE1XT10WzE1XSksZVswXT1zKmkrZipyLGVbMV09byppK2wqcixlWzJdPXUqaStjKnIsZVszXT1hKmkraCpyLGVbNF09ZippLXMqcixlWzVdPWwqaS1vKnIsZVs2XT1jKmktdSpyLGVbN109aCppLWEqcixlfSxjLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9cityLGE9aStpLGY9cytzLGw9cip1LGM9ciphLGg9cipmLHA9aSphLGQ9aSpmLHY9cypmLG09byp1LGc9byphLHk9bypmO3JldHVybiBlWzBdPTEtKHArdiksZVsxXT1jK3ksZVsyXT1oLWcsZVszXT0wLGVbNF09Yy15LGVbNV09MS0obCt2KSxlWzZdPWQrbSxlWzddPTAsZVs4XT1oK2csZVs5XT1kLW0sZVsxMF09MS0obCtwKSxlWzExXT0wLGVbMTJdPW5bMF0sZVsxM109blsxXSxlWzE0XT1uWzJdLGVbMTVdPTEsZX0sYy5mcm9tUXVhdD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz1uK24sdT1yK3IsYT1pK2ksZj1uKm8sbD1uKnUsYz1uKmEsaD1yKnUscD1yKmEsZD1pKmEsdj1zKm8sbT1zKnUsZz1zKmE7cmV0dXJuIGVbMF09MS0oaCtkKSxlWzFdPWwrZyxlWzJdPWMtbSxlWzNdPTAsZVs0XT1sLWcsZVs1XT0xLShmK2QpLGVbNl09cCt2LGVbN109MCxlWzhdPWMrbSxlWzldPXAtdixlWzEwXT0xLShmK2gpLGVbMTFdPTAsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTAsZVsxNV09MSxlfSxjLmZydXN0dW09ZnVuY3Rpb24oZSx0LG4scixpLHMsbyl7dmFyIHU9MS8obi10KSxhPTEvKGktciksZj0xLyhzLW8pO3JldHVybiBlWzBdPXMqMip1LGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MCxlWzVdPXMqMiphLGVbNl09MCxlWzddPTAsZVs4XT0obit0KSp1LGVbOV09KGkrcikqYSxlWzEwXT0obytzKSpmLGVbMTFdPS0xLGVbMTJdPTAsZVsxM109MCxlWzE0XT1vKnMqMipmLGVbMTVdPTAsZX0sYy5wZXJzcGVjdGl2ZT1mdW5jdGlvbihlLHQsbixyLGkpe3ZhciBzPTEvTWF0aC50YW4odC8yKSxvPTEvKHItaSk7cmV0dXJuIGVbMF09cy9uLGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MCxlWzVdPXMsZVs2XT0wLGVbN109MCxlWzhdPTAsZVs5XT0wLGVbMTBdPShpK3IpKm8sZVsxMV09LTEsZVsxMl09MCxlWzEzXT0wLGVbMTRdPTIqaSpyKm8sZVsxNV09MCxlfSxjLm9ydGhvPWZ1bmN0aW9uKGUsdCxuLHIsaSxzLG8pe3ZhciB1PTEvKHQtbiksYT0xLyhyLWkpLGY9MS8ocy1vKTtyZXR1cm4gZVswXT0tMip1LGVbMV09MCxlWzJdPTAsZVszXT0wLGVbNF09MCxlWzVdPS0yKmEsZVs2XT0wLGVbN109MCxlWzhdPTAsZVs5XT0wLGVbMTBdPTIqZixlWzExXT0wLGVbMTJdPSh0K24pKnUsZVsxM109KGkrcikqYSxlWzE0XT0obytzKSpmLGVbMTVdPTEsZX0sYy5sb29rQXQ9ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIHMsbyx1LGEsZixsLGgscCxkLHYsbT1uWzBdLGc9blsxXSx5PW5bMl0sYj1pWzBdLHc9aVsxXSxFPWlbMl0sUz1yWzBdLHg9clsxXSxUPXJbMl07cmV0dXJuIE1hdGguYWJzKG0tUyk8dCYmTWF0aC5hYnMoZy14KTx0JiZNYXRoLmFicyh5LVQpPHQ/Yy5pZGVudGl0eShlKTooaD1tLVMscD1nLXgsZD15LVQsdj0xL01hdGguc3FydChoKmgrcCpwK2QqZCksaCo9dixwKj12LGQqPXYscz13KmQtRSpwLG89RSpoLWIqZCx1PWIqcC13Kmgsdj1NYXRoLnNxcnQocypzK28qbyt1KnUpLHY/KHY9MS92LHMqPXYsbyo9dix1Kj12KToocz0wLG89MCx1PTApLGE9cCp1LWQqbyxmPWQqcy1oKnUsbD1oKm8tcCpzLHY9TWF0aC5zcXJ0KGEqYStmKmYrbCpsKSx2Pyh2PTEvdixhKj12LGYqPXYsbCo9dik6KGE9MCxmPTAsbD0wKSxlWzBdPXMsZVsxXT1hLGVbMl09aCxlWzNdPTAsZVs0XT1vLGVbNV09ZixlWzZdPXAsZVs3XT0wLGVbOF09dSxlWzldPWwsZVsxMF09ZCxlWzExXT0wLGVbMTJdPS0ocyptK28qZyt1KnkpLGVbMTNdPS0oYSptK2YqZytsKnkpLGVbMTRdPS0oaCptK3AqZytkKnkpLGVbMTVdPTEsZSl9LGMuc3RyPWZ1bmN0aW9uKGUpe3JldHVyblwibWF0NChcIitlWzBdK1wiLCBcIitlWzFdK1wiLCBcIitlWzJdK1wiLCBcIitlWzNdK1wiLCBcIitlWzRdK1wiLCBcIitlWzVdK1wiLCBcIitlWzZdK1wiLCBcIitlWzddK1wiLCBcIitlWzhdK1wiLCBcIitlWzldK1wiLCBcIitlWzEwXStcIiwgXCIrZVsxMV0rXCIsIFwiK2VbMTJdK1wiLCBcIitlWzEzXStcIiwgXCIrZVsxNF0rXCIsIFwiK2VbMTVdK1wiKVwifSx0eXBlb2YgZSE9XCJ1bmRlZmluZWRcIiYmKGUubWF0ND1jKTt2YXIgaD17fTtoLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKDQpO3JldHVybiBlWzBdPTAsZVsxXT0wLGVbMl09MCxlWzNdPTEsZX0saC5yb3RhdGlvblRvPWZ1bmN0aW9uKCl7dmFyIGU9by5jcmVhdGUoKSx0PW8uZnJvbVZhbHVlcygxLDAsMCksbj1vLmZyb21WYWx1ZXMoMCwxLDApO3JldHVybiBmdW5jdGlvbihyLGkscyl7dmFyIHU9by5kb3QoaSxzKTtyZXR1cm4gdTwtMC45OTk5OTk/KG8uY3Jvc3MoZSx0LGkpLG8ubGVuZ3RoKGUpPDFlLTYmJm8uY3Jvc3MoZSxuLGkpLG8ubm9ybWFsaXplKGUsZSksaC5zZXRBeGlzQW5nbGUocixlLE1hdGguUEkpLHIpOnU+Ljk5OTk5OT8oclswXT0wLHJbMV09MCxyWzJdPTAsclszXT0xLHIpOihvLmNyb3NzKGUsaSxzKSxyWzBdPWVbMF0sclsxXT1lWzFdLHJbMl09ZVsyXSxyWzNdPTErdSxoLm5vcm1hbGl6ZShyLHIpKX19KCksaC5zZXRBeGVzPWZ1bmN0aW9uKCl7dmFyIGU9bC5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24odCxuLHIsaSl7cmV0dXJuIGVbMF09clswXSxlWzNdPXJbMV0sZVs2XT1yWzJdLGVbMV09aVswXSxlWzRdPWlbMV0sZVs3XT1pWzJdLGVbMl09blswXSxlWzVdPW5bMV0sZVs4XT1uWzJdLGgubm9ybWFsaXplKHQsaC5mcm9tTWF0Myh0LGUpKX19KCksaC5jbG9uZT11LmNsb25lLGguZnJvbVZhbHVlcz11LmZyb21WYWx1ZXMsaC5jb3B5PXUuY29weSxoLnNldD11LnNldCxoLmlkZW50aXR5PWZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPTAsZVsxXT0wLGVbMl09MCxlWzNdPTEsZX0saC5zZXRBeGlzQW5nbGU9ZnVuY3Rpb24oZSx0LG4pe24qPS41O3ZhciByPU1hdGguc2luKG4pO3JldHVybiBlWzBdPXIqdFswXSxlWzFdPXIqdFsxXSxlWzJdPXIqdFsyXSxlWzNdPU1hdGguY29zKG4pLGV9LGguYWRkPXUuYWRkLGgubXVsdGlwbHk9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1uWzBdLGE9blsxXSxmPW5bMl0sbD1uWzNdO3JldHVybiBlWzBdPXIqbCtvKnUraSpmLXMqYSxlWzFdPWkqbCtvKmErcyp1LXIqZixlWzJdPXMqbCtvKmYrciphLWkqdSxlWzNdPW8qbC1yKnUtaSphLXMqZixlfSxoLm11bD1oLm11bHRpcGx5LGguc2NhbGU9dS5zY2FsZSxoLnJvdGF0ZVg9ZnVuY3Rpb24oZSx0LG4pe24qPS41O3ZhciByPXRbMF0saT10WzFdLHM9dFsyXSxvPXRbM10sdT1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pO3JldHVybiBlWzBdPXIqYStvKnUsZVsxXT1pKmErcyp1LGVbMl09cyphLWkqdSxlWzNdPW8qYS1yKnUsZX0saC5yb3RhdGVZPWZ1bmN0aW9uKGUsdCxuKXtuKj0uNTt2YXIgcj10WzBdLGk9dFsxXSxzPXRbMl0sbz10WzNdLHU9TWF0aC5zaW4obiksYT1NYXRoLmNvcyhuKTtyZXR1cm4gZVswXT1yKmEtcyp1LGVbMV09aSphK28qdSxlWzJdPXMqYStyKnUsZVszXT1vKmEtaSp1LGV9LGgucm90YXRlWj1mdW5jdGlvbihlLHQsbil7bio9LjU7dmFyIHI9dFswXSxpPXRbMV0scz10WzJdLG89dFszXSx1PU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIGVbMF09ciphK2kqdSxlWzFdPWkqYS1yKnUsZVsyXT1zKmErbyp1LGVbM109byphLXMqdSxlfSxoLmNhbGN1bGF0ZVc9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHI9dFsxXSxpPXRbMl07cmV0dXJuIGVbMF09bixlWzFdPXIsZVsyXT1pLGVbM109LU1hdGguc3FydChNYXRoLmFicygxLW4qbi1yKnItaSppKSksZX0saC5kb3Q9dS5kb3QsaC5sZXJwPXUubGVycCxoLnNsZXJwPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXRbMF0scz10WzFdLG89dFsyXSx1PXRbM10sYT1uWzBdLGY9blsxXSxsPW5bMl0sYz1uWzNdLGgscCxkLHYsbTtyZXR1cm4gcD1pKmErcypmK28qbCt1KmMscDwwJiYocD0tcCxhPS1hLGY9LWYsbD0tbCxjPS1jKSwxLXA+MWUtNj8oaD1NYXRoLmFjb3MocCksZD1NYXRoLnNpbihoKSx2PU1hdGguc2luKCgxLXIpKmgpL2QsbT1NYXRoLnNpbihyKmgpL2QpOih2PTEtcixtPXIpLGVbMF09dippK20qYSxlWzFdPXYqcyttKmYsZVsyXT12Km8rbSpsLGVbM109dip1K20qYyxlfSxoLmludmVydD1mdW5jdGlvbihlLHQpe3ZhciBuPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sbz1uKm4rcipyK2kqaStzKnMsdT1vPzEvbzowO3JldHVybiBlWzBdPS1uKnUsZVsxXT0tcip1LGVbMl09LWkqdSxlWzNdPXMqdSxlfSxoLmNvbmp1Z2F0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBlWzBdPS10WzBdLGVbMV09LXRbMV0sZVsyXT0tdFsyXSxlWzNdPXRbM10sZX0saC5sZW5ndGg9dS5sZW5ndGgsaC5sZW49aC5sZW5ndGgsaC5zcXVhcmVkTGVuZ3RoPXUuc3F1YXJlZExlbmd0aCxoLnNxckxlbj1oLnNxdWFyZWRMZW5ndGgsaC5ub3JtYWxpemU9dS5ub3JtYWxpemUsaC5mcm9tTWF0Mz1mdW5jdGlvbigpe3ZhciBlPXR5cGVvZiBJbnQ4QXJyYXkhPVwidW5kZWZpbmVkXCI/bmV3IEludDhBcnJheShbMSwyLDBdKTpbMSwyLDBdO3JldHVybiBmdW5jdGlvbih0LG4pe3ZhciByPW5bMF0rbls0XStuWzhdLGk7aWYocj4wKWk9TWF0aC5zcXJ0KHIrMSksdFszXT0uNSppLGk9LjUvaSx0WzBdPShuWzddLW5bNV0pKmksdFsxXT0oblsyXS1uWzZdKSppLHRbMl09KG5bM10tblsxXSkqaTtlbHNle3ZhciBzPTA7bls0XT5uWzBdJiYocz0xKSxuWzhdPm5bcyozK3NdJiYocz0yKTt2YXIgbz1lW3NdLHU9ZVtvXTtpPU1hdGguc3FydChuW3MqMytzXS1uW28qMytvXS1uW3UqMyt1XSsxKSx0W3NdPS41KmksaT0uNS9pLHRbM109KG5bdSozK29dLW5bbyozK3VdKSppLHRbb109KG5bbyozK3NdK25bcyozK29dKSppLHRbdV09KG5bdSozK3NdK25bcyozK3VdKSppfXJldHVybiB0fX0oKSxoLnN0cj1mdW5jdGlvbihlKXtyZXR1cm5cInF1YXQoXCIrZVswXStcIiwgXCIrZVsxXStcIiwgXCIrZVsyXStcIiwgXCIrZVszXStcIilcIn0sdHlwZW9mIGUhPVwidW5kZWZpbmVkXCImJihlLnF1YXQ9aCl9KHQuZXhwb3J0cyl9KSh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmV3IChyZXF1aXJlKCcuL3NvdXJjZS93b3JrZXIuanMnKSkoc2VsZik7XG59IGVsc2Uge1xuICAgIC8vIGpzaGludCAtVzA3OVxuICAgIHZhciBtYXBib3hnbCA9IG1vZHVsZS5leHBvcnRzID0gd2luZG93Lm1hcGJveGdsID0ge307XG5cbiAgICBtYXBib3hnbC5NYXAgPSByZXF1aXJlKCcuL3VpL21hcC5qcycpO1xuICAgIG1hcGJveGdsLk5hdmlnYXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvbmF2aWdhdGlvbi5qcycpO1xuICAgIG1hcGJveGdsLkF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi91aS9jb250cm9sL2F0dHJpYnV0aW9uLmpzJyk7XG5cbiAgICBtYXBib3hnbC5Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9zb3VyY2UnKTtcbiAgICBtYXBib3hnbC5HZW9KU09OU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UvZ2VvanNvbnNvdXJjZScpO1xuICAgIG1hcGJveGdsLlZpZGVvU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UvdmlkZW9zb3VyY2UnKTtcblxuICAgIG1hcGJveGdsLlN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZS9zdHlsZS5qcycpO1xuXG4gICAgbWFwYm94Z2wuTGF0TG5nID0gcmVxdWlyZSgnLi9nZW8vbGF0bG5nLmpzJyk7XG4gICAgbWFwYm94Z2wuTGF0TG5nQm91bmRzID0gcmVxdWlyZSgnLi9nZW8vbGF0bG5nYm91bmRzLmpzJyk7XG4gICAgbWFwYm94Z2wuUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4gICAgbWFwYm94Z2wuRXZlbnRlZCA9IHJlcXVpcmUoJy4vdXRpbC9ldmVudGVkLmpzJyk7XG4gICAgbWFwYm94Z2wudXRpbCA9IHJlcXVpcmUoJy4vdXRpbC91dGlsLmpzJyk7XG5cbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbC9icm93c2VyLmpzJyk7XG4gICAgbWFwYm94Z2wudXRpbC5zdXBwb3J0ZWQgPSBicm93c2VyLnN1cHBvcnRlZDtcblxuICAgIHZhciBhamF4ID0gcmVxdWlyZSgnLi91dGlsL2FqYXguanMnKTtcbiAgICBtYXBib3hnbC51dGlsLmdldEpTT04gPSBhamF4LmdldEpTT047XG4gICAgbWFwYm94Z2wudXRpbC5nZXRBcnJheUJ1ZmZlciA9IGFqYXguZ2V0QXJyYXlCdWZmZXI7XG5cbiAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi91dGlsL2NvbmZpZy5qcycpO1xuICAgIG1hcGJveGdsLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXBib3hnbCwgJ2FjY2Vzc1Rva2VuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29uZmlnLkFDQ0VTU19UT0tFTjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0b2tlbikgeyBjb25maWcuQUNDRVNTX1RPS0VOID0gdG9rZW47IH1cbiAgICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDMgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdCYWNrZ3JvdW5kO1xuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChnbCwgcGFpbnRlciwgYnVja2V0LCBsYXllclN0eWxlLCBwb3NNYXRyaXgsIHBhcmFtcywgaW1hZ2VTcHJpdGUpIHtcbiAgICB2YXIgY29sb3IgPSBsYXllclN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ107XG4gICAgdmFyIGltYWdlID0gbGF5ZXJTdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddO1xuICAgIHZhciBvcGFjaXR5ID0gbGF5ZXJTdHlsZVsnYmFja2dyb3VuZC1vcGFjaXR5J10gfHwgMTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHZhciBpbWFnZVBvcyA9IGltYWdlU3ByaXRlLmdldFBvc2l0aW9uKGltYWdlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpbWFnZVBvcykgcmV0dXJuO1xuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIucGF0dGVyblNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlLCAwKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsLCBpbWFnZVBvcy50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9iciwgaW1hZ2VQb3MuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWl4LCBwYWludGVyLnRyYW5zZm9ybS56b29tRnJhY3Rpb24pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHBhaW50ZXIudHJhbnNmb3JtO1xuICAgICAgICB2YXIgc2l6ZSA9IGltYWdlUG9zLnNpemU7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKHRyYW5zZm9ybS5jZW50ZXIpO1xuICAgICAgICB2YXIgc2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgdHJhbnNmb3JtLnpvb21GcmFjdGlvbik7XG4gICAgICAgIHZhciBtYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4LCBtYXRyaXgsIFsxIC8gc2l6ZVswXSwgMSAvIHNpemVbMV0sIDFdKTtcbiAgICAgICAgbWF0My50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFtcbiAgICAgICAgICAgIChjZW50ZXIuY29sdW1uICogdHJhbnNmb3JtLnRpbGVTaXplKSAlIHNpemVbMF0sXG4gICAgICAgICAgICAoY2VudGVyLnJvdyAgICAqIHRyYW5zZm9ybS50aWxlU2l6ZSkgJSBzaXplWzFdLFxuICAgICAgICAgICAgMFxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My5yb3RhdGUobWF0cml4LCBtYXRyaXgsIC10cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeCwgbWF0cml4LCBbXG4gICAgICAgICAgICBzY2FsZSAqIHRyYW5zZm9ybS53aWR0aCAgLyAyLFxuICAgICAgICAgICAtc2NhbGUgKiB0cmFuc2Zvcm0uaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4LCBmYWxzZSwgbWF0cml4KTtcblxuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCB0cnVlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuZmlsbFNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFyYW1zLnBhZGRlZCB8fCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1Db3VudCk7XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXh0VmVydGljZXMgPSByZXF1aXJlKCcuLi9saWIvZGVidWd0ZXh0LmpzJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdEZWJ1ZztcblxuZnVuY3Rpb24gZHJhd0RlYnVnKGdsLCBwYWludGVyLCB0aWxlLCBwYXJhbXMpIHtcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRlYnVnU2hhZGVyLCBwYWludGVyLnRpbGUucG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xuXG4gICAgLy8gZHJhdyBib3VuZGluZyByZWN0YW5nbGVcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci5kZWJ1Z0J1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmRlYnVnU2hhZGVyLmFfcG9zLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDEsIDAsIDAsIDEpO1xuICAgIGdsLmxpbmVXaWR0aCg0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVfU1RSSVAsIDAsIHBhaW50ZXIuZGVidWdCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIC8vIGRyYXcgdGlsZSBjb29yZGluYXRlXG4gICAgdmFyIGNvb3JkID0gcGFyYW1zLnogKyAnLycgKyBwYXJhbXMueCArICcvJyArIHBhcmFtcy55O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGV4dFZlcnRpY2VzKGNvb3JkLCA1MCwgMjAwLCA1KTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KHZlcnRpY2VzKSwgZ2wuU1RSRUFNX0RSQVcpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kZWJ1Z1NoYWRlci5hX3BvcywgcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wubGluZVdpZHRoKDggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDEsIDEsIDEsIDEpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcbiAgICBnbC5saW5lV2lkdGgoMiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgZ2wudW5pZm9ybTRmKHBhaW50ZXIuZGVidWdTaGFkZXIudV9jb2xvciwgMCwgMCwgMCwgMSk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgdmVydGljZXMubGVuZ3RoIC8gcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUpO1xuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyk7XG52YXIgbWF0MyA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDM7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0ZpbGw7XG5cbmZ1bmN0aW9uIGRyYXdGaWxsKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRQb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHBhcmFtcy56LCBsYXllclN0eWxlWydmaWxsLXRyYW5zbGF0ZSddLCBsYXllclN0eWxlWydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICB2YXIgY29sb3IgPSBsYXllclN0eWxlWydmaWxsLWNvbG9yJ107XG5cbiAgICB2YXIgdmVydGV4LCBlbGVtZW50cywgZ3JvdXAsIGNvdW50O1xuXG4gICAgLy8gRHJhdyB0aGUgc3RlbmNpbCBtYXNrLlxuXG4gICAgLy8gV2UncmUgb25seSBkcmF3aW5nIHRvIHRoZSBmaXJzdCBzZXZlbiBiaXRzICg9PSBzdXBwb3J0IGEgbWF4aW11bSBvZlxuICAgIC8vIDEyNyBvdmVybGFwcGluZyBwb2x5Z29ucyBpbiBvbmUgcGxhY2UgYmVmb3JlIHdlIGdldCByZW5kZXJpbmcgZXJyb3JzKS5cbiAgICBnbC5zdGVuY2lsTWFzaygweDNGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuXG4gICAgLy8gRHJhdyBmcm9udCBmYWNpbmcgdHJpYW5nbGVzLiBXaGVyZXZlciB0aGUgMHg4MCBiaXQgaXMgMSwgd2UgYXJlXG4gICAgLy8gaW5jcmVhc2luZyB0aGUgbG93ZXIgNyBiaXRzIGJ5IG9uZSBpZiB0aGUgdHJpYW5nbGUgaXMgYSBmcm9udC1mYWNpbmdcbiAgICAvLyB0cmlhbmdsZS4gVGhpcyBtZWFucyB0aGF0IGFsbCB2aXNpYmxlIHBvbHlnb25zIHNob3VsZCBiZSBpbiBDQ1dcbiAgICAvLyBvcmllbnRhdGlvbiwgd2hpbGUgYWxsIGhvbGVzIChzZWUgYmVsb3cpIGFyZSBpbiBDVyBvcmllbnRhdGlvbi5cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMHg4MCwgMHg4MCk7XG5cbiAgICAvLyBXaGVuIHdlIGRvIGEgbm9uemVybyBmaWxsLCB3ZSBjb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgcGl4ZWwgaXNcbiAgICAvLyBjb3ZlcmVkIGJ5IGEgY291bnRlcmNsb2Nrd2lzZSBwb2x5Z29uLCBhbmQgc3VidHJhY3QgdGhlIG51bWJlciBvZlxuICAgIC8vIHRpbWVzIGl0IGlzIFwidW5jb3ZlcmVkXCIgYnkgYSBjbG9ja3dpc2UgcG9seWdvbi5cbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5GUk9OVCwgZ2wuSU5DUl9XUkFQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5CQUNLLCBnbC5ERUNSX1dSQVAsIGdsLktFRVAsIGdsLktFRVApO1xuXG4gICAgLy8gV2hlbiBkcmF3aW5nIGEgc2hhcGUsIHdlIGZpcnN0IGRyYXcgYWxsIHNoYXBlcyB0byB0aGUgc3RlbmNpbCBidWZmZXJcbiAgICAvLyBhbmQgaW5jcmVtZW50aW5nIGFsbCBhcmVhcyB3aGVyZSBwb2x5Z29ucyBhcmVcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIHRyaWFuZ2xlIGZhbiBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5maWxsU2hhZGVyLCB0cmFuc2xhdGVkUG9zTWF0cml4LCBwYWludGVyLnRpbGUuZXhNYXRyaXgpO1xuXG4gICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xuICAgIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgIGVsZW1lbnRzID0gYnVja2V0LmJ1ZmZlcnMuZmlsbEVsZW1lbnQ7XG4gICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICB2YXIgb2Zmc2V0LCBlbGVtZW50T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzW2ldO1xuICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZmlsbFNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA0LCBvZmZzZXQgKyAwKTtcblxuICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBzdGVuY2lsIG1hc2sgaW4gdGhlIHN0ZW5jaWwgYnVmZmVyLCB3ZSBjYW4gc3RhcnRcbiAgICAvLyB3cml0aW5nIHRvIHRoZSBjb2xvciBidWZmZXIuXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgLy8gRnJvbSBub3cgb24sIHdlIGRvbid0IHdhbnQgdG8gdXBkYXRlIHRoZSBzdGVuY2lsIGJ1ZmZlciBhbnltb3JlLlxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDApO1xuXG4gICAgdmFyIHN0cm9rZUNvbG9yID0gbGF5ZXJTdHlsZVsnZmlsbC1vdXRsaW5lLWNvbG9yJ107XG5cbiAgICAvLyBCZWNhdXNlIHdlJ3JlIGRyYXdpbmcgdG9wLXRvLWJvdHRvbSwgYW5kIHdlIHVwZGF0ZSB0aGUgc3RlbmNpbCBtYXNrXG4gICAgLy8gYmVsb3csIHdlIGhhdmUgdG8gZHJhdyB0aGUgb3V0bGluZSBmaXJzdCAoISlcbiAgICBpZiAobGF5ZXJTdHlsZVsnZmlsbC1hbnRpYWxpYXMnXSA9PT0gdHJ1ZSAmJiBwYXJhbXMuYW50aWFsaWFzaW5nICYmICEobGF5ZXJTdHlsZVsnZmlsbC1pbWFnZSddICYmICFzdHJva2VDb2xvcikpIHtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIub3V0bGluZVNoYWRlciwgdHJhbnNsYXRlZFBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcbiAgICAgICAgZ2wubGluZVdpZHRoKDIgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuXG4gICAgICAgIGlmIChzdHJva2VDb2xvcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGVmaW5lZCBhIGRpZmZlcmVudCBjb2xvciBmb3IgdGhlIGZpbGwgb3V0bGluZSwgd2UgYXJlXG4gICAgICAgICAgICAvLyBnb2luZyB0byBpZ25vcmUgdGhlIGJpdHMgaW4gMHgzRiBhbmQganVzdCBjYXJlIGFib3V0IHRoZSBnbG9iYWxcbiAgICAgICAgICAgIC8vIGNsaXBwaW5nIG1hc2suXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG9ubHkgd2FudCB0byBkcmF3IHRoZSBhbnRpYWxpYXNlZCBwYXJ0cyB0aGF0IGFyZVxuICAgICAgICAgICAgLy8gKm91dHNpZGUqIHRoZSBjdXJyZW50IHNoYXBlLiBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBmaWxsXG4gICAgICAgICAgICAvLyBvciBzdHJva2UgY29sb3IgaXMgdHJhbnNsdWNlbnQuIElmIHdlIHdvdWxkbid0IGNsaXAgdG8gb3V0c2lkZVxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2hhcGUsIHNvbWUgcGl4ZWxzIGZyb20gdGhlIG91dGxpbmUgc3Ryb2tlIG92ZXJsYXBwZWRcbiAgICAgICAgICAgIC8vIHRoZSAobm9uLWFudGlhbGlhc2VkKSBmaWxsLlxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4QkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKHBhaW50ZXIub3V0bGluZVNoYWRlci51X3dvcmxkLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHBhaW50ZXIub3V0bGluZVNoYWRlci51X2NvbG9yLCBzdHJva2VDb2xvciA/IHN0cm9rZUNvbG9yIDogY29sb3IpO1xuXG4gICAgICAgIC8vIERyYXcgYWxsIGJ1ZmZlcnNcbiAgICAgICAgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMuZmlsbFZlcnRleDtcbiAgICAgICAgZWxlbWVudHMgPSBidWNrZXQuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcbiAgICAgICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzW2tdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5vdXRsaW5lU2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDQsIG9mZnNldCArIDApO1xuXG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLnNlY29uZEVsZW1lbnRMZW5ndGggKiAyO1xuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLnNlY29uZEVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuTElORVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBsYXllclN0eWxlWydmaWxsLWltYWdlJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllclN0eWxlWydmaWxsLW9wYWNpdHknXSB8fCAxO1xuICAgIHZhciBzaGFkZXI7XG5cbiAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcbiAgICAgICAgdmFyIGltYWdlUG9zID0gaW1hZ2VTcHJpdGUuZ2V0UG9zaXRpb24oaW1hZ2UsIHRydWUpO1xuICAgICAgICBpZiAoIWltYWdlUG9zKSByZXR1cm47XG5cbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5wYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGwsIGltYWdlUG9zLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyLCBpbWFnZVBvcy5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIHBhaW50ZXIudHJhbnNmb3JtLnpvb21GcmFjdGlvbik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBvcGFjaXR5KTtcblxuICAgICAgICB2YXIgZmFjdG9yID0gOCAvIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gcGFyYW1zLnopO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeCwgbWF0cml4LCBbXG4gICAgICAgICAgICAxIC8gKGltYWdlUG9zLnNpemVbMF0gKiBmYWN0b3IpLFxuICAgICAgICAgICAgMSAvIChpbWFnZVBvcy5zaXplWzFdICogZmFjdG9yKSxcbiAgICAgICAgICAgIDEsIDFcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4LCBmYWxzZSwgbWF0cml4KTtcblxuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCB0cnVlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuZmlsbFNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFyYW1zLnBhZGRlZCB8fCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgLy8gT25seSBkcmF3IHJlZ2lvbnMgdGhhdCB3ZSBtYXJrZWRcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMHgwLCAweDNGKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRyYXdMaW5lKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xuXG4gICAgcG9zTWF0cml4ID0gcGFpbnRlci50cmFuc2xhdGVNYXRyaXgocG9zTWF0cml4LCBwYXJhbXMueiwgbGF5ZXJTdHlsZVsnbGluZS10cmFuc2xhdGUnXSwgbGF5ZXJTdHlsZVsnbGluZS10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgLy8gZG9uJ3QgZHJhdyB6ZXJvLXdpZHRoIGxpbmVzXG4gICAgaWYgKGxheWVyU3R5bGVbJ2xpbmUtd2lkdGgnXSA8PSAwKSByZXR1cm47XG5cbiAgICB2YXIgZ2FtbWEgPSAxO1xuICAgIHZhciBhbnRpYWxpYXNpbmcgPSBnYW1tYSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIHZhciBsaW5lT2Zmc2V0ID0gbGF5ZXJTdHlsZVsnbGluZS1vZmZzZXQnXSAvIDI7XG4gICAgdmFyIGluc2V0ID0gTWF0aC5tYXgoLTEsIGxpbmVPZmZzZXQgLSBsYXllclN0eWxlWydsaW5lLXdpZHRoJ10gLyAyIC0gYW50aWFsaWFzaW5nIC8gMikgKyAxO1xuICAgIHZhciBvdXRzZXQgPSBsaW5lT2Zmc2V0ICsgbGF5ZXJTdHlsZVsnbGluZS13aWR0aCddIC8gMiArIGFudGlhbGlhc2luZyAvIDI7XG5cbiAgICB2YXIgaW1hZ2VQb3MgPSBsYXllclN0eWxlWydsaW5lLWltYWdlJ10gJiYgaW1hZ2VTcHJpdGUuZ2V0UG9zaXRpb24obGF5ZXJTdHlsZVsnbGluZS1pbWFnZSddKTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKGltYWdlUG9zKSB7XG4gICAgICAgIHZhciBmYWN0b3IgPSA4IC8gTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20gLSBwYXJhbXMueik7XG5cbiAgICAgICAgaW1hZ2VTcHJpdGUuYmluZChnbCwgdHJ1ZSk7XG5cbiAgICAgICAgLy9mYWN0b3IgPSBNYXRoLnBvdygyLCA0IC0gcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20gKyBwYXJhbXMueik7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIubGluZXBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3NpemUsIFtpbWFnZVBvcy5zaXplWzBdICogZmFjdG9yLCBpbWFnZVBvcy5zaXplWzFdIF0pO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGwsIGltYWdlUG9zLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyLCBpbWFnZVBvcy5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlLCBwYWludGVyLnRyYW5zZm9ybS56b29tRnJhY3Rpb24pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5saW5lU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgsIHBhaW50ZXIudGlsZS5leE1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfZGFzaGFycmF5LCBsYXllclN0eWxlWydsaW5lLWRhc2hhcnJheSddKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgbGF5ZXJTdHlsZVsnbGluZS1jb2xvciddKTtcbiAgICB9XG5cbiAgICB2YXIgdGlsZVBpeGVsUmF0aW8gPSBwYWludGVyLnRyYW5zZm9ybS5zY2FsZSAvICgxIDw8IHBhcmFtcy56KSAvIDg7XG4gICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHRpbGVQaXhlbFJhdGlvKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYmx1ciwgbGF5ZXJTdHlsZVsnbGluZS1ibHVyJ10gKyBhbnRpYWxpYXNpbmcpO1xuXG5cbiAgICB2YXIgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMubGluZVZlcnRleDtcbiAgICB2ZXJ0ZXguYmluZChnbCk7XG4gICAgdmFyIGVsZW1lbnQgPSBidWNrZXQuYnVmZmVycy5saW5lRWxlbWVudDtcbiAgICBlbGVtZW50LmJpbmQoZ2wpO1xuXG4gICAgdmFyIGdyb3VwcyA9IGJ1Y2tldC5lbGVtZW50R3JvdXBzLmdyb3VwcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIHZhciBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgNCwgZ2wuU0hPUlQsIGZhbHNlLCA4LCBvZmZzZXQgKyAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9leHRydWRlLCAyLCBnbC5CWVRFLCBmYWxzZSwgOCwgb2Zmc2V0ICsgNik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfbGluZXNvZmFyLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIG9mZnNldCArIDQpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudC5pdGVtU2l6ZTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZWNvb3JkLmpzJyk7XG52YXIgUHJlcmVuZGVyZWRUZXh0dXJlID0gcmVxdWlyZSgnLi9wcmVyZW5kZXJlZC5qcycpO1xudmFyIG1hdDQgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdSYXN0ZXI7XG5cbmZ1bmN0aW9uIGRyYXdSYXN0ZXIoZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcGFyYW1zLCBzdHlsZSwgbGF5ZXIsIHRpbGUpIHtcblxuICAgIGlmIChsYXllciAmJiBsYXllci5sYXllcnMpIHtcblxuICAgICAgICBpZiAoIWJ1Y2tldC5wcmVyZW5kZXJlZCkge1xuICAgICAgICAgICAgYnVja2V0LnByZXJlbmRlcmVkID0gbmV3IFByZXJlbmRlcmVkVGV4dHVyZShnbCwgYnVja2V0LmluZm8sIHBhaW50ZXIpO1xuICAgICAgICAgICAgYnVja2V0LnByZXJlbmRlcmVkLmJpbmRGcmFtZWJ1ZmZlcigpO1xuXG4gICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoMHg4MCk7XG4gICAgICAgICAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG5cbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGJ1Y2tldC5wcmVyZW5kZXJlZC5zaXplLCBidWNrZXQucHJlcmVuZGVyZWQuc2l6ZSk7XG5cbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWNrZXQucHJlcmVuZGVyZWQuYnVmZmVyICogNDA5NjtcblxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgICAgICBtYXQ0Lm9ydGhvKG1hdHJpeCwgLWJ1ZmZlciwgNDA5NiArIGJ1ZmZlciwgLTQwOTYgLSBidWZmZXIsIGJ1ZmZlciwgMCwgMSk7XG4gICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWzAsIC00MDk2LCAwXSk7XG5cbiAgICAgICAgICAgIHBhcmFtcy5wYWRkZWQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbWF0NC5vcnRobyhwYXJhbXMucGFkZGVkLCAwLCA0MDk2LCAtNDA5NiwgMCwgMCwgMSk7XG4gICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZShwYXJhbXMucGFkZGVkLCBwYXJhbXMucGFkZGVkLCBbMCwgLTQwOTYsIDBdKTtcblxuICAgICAgICAgICAgcGFpbnRlci5kcmF3KHRpbGUsIHN0eWxlLCBsYXllci5sYXllcnMsIHBhcmFtcywgbWF0cml4KTtcblxuICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5wYWRkZWQ7XG5cbiAgICAgICAgICAgIGlmIChidWNrZXQuaW5mb1sncmFzdGVyLWJsdXInXSA+IDApIHtcbiAgICAgICAgICAgICAgICBidWNrZXQucHJlcmVuZGVyZWQuYmx1cihwYWludGVyLCBidWNrZXQuaW5mb1sncmFzdGVyLWJsdXInXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1Y2tldC5wcmVyZW5kZXJlZC51bmJpbmRGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgcGFpbnRlci53aWR0aCwgcGFpbnRlci5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgdGV4dHVyZSA9IGJ1Y2tldC50aWxlID8gYnVja2V0LnRpbGUgOiBidWNrZXQucHJlcmVuZGVyZWQ7XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICB2YXIgc2hhZGVyID0gcGFpbnRlci5yYXN0ZXJTaGFkZXI7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcGFpbnRlci50aWxlLnBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgIC8vIGNvbG9yIHBhcmFtZXRlcnNcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19sb3csIGxheWVyU3R5bGVbJ3Jhc3Rlci1icmlnaHRuZXNzJ11bMF0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9icmlnaHRuZXNzX2hpZ2gsIGxheWVyU3R5bGVbJ3Jhc3Rlci1icmlnaHRuZXNzJ11bMV0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllclN0eWxlWydyYXN0ZXItc2F0dXJhdGlvbiddKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2NvbnRyYXN0X2ZhY3RvciwgY29udHJhc3RGYWN0b3IobGF5ZXJTdHlsZVsncmFzdGVyLWNvbnRyYXN0J10pKTtcbiAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci51X3NwaW5fd2VpZ2h0cywgc3BpbldlaWdodHMobGF5ZXJTdHlsZVsncmFzdGVyLWh1ZS1yb3RhdGUnXSkpO1xuXG5cbiAgICB2YXIgcGFyZW50VGlsZSwgb3BhY2l0aWVzO1xuICAgIGlmIChsYXllciAmJiBsYXllci5sYXllcnMpIHtcbiAgICAgICAgcGFyZW50VGlsZSA9IG51bGw7XG4gICAgICAgIG9wYWNpdGllcyA9IFtsYXllclN0eWxlWydyYXN0ZXItb3BhY2l0eSddLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRUaWxlID0gZmluZFBhcmVudCh0ZXh0dXJlKTtcbiAgICAgICAgb3BhY2l0aWVzID0gZ2V0T3BhY2l0aWVzKHRleHR1cmUsIHBhcmVudFRpbGUpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50U2NhbGVCeSwgcGFyZW50VEw7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICB0ZXh0dXJlLmJpbmQoZ2wpO1xuXG4gICAgaWYgKHBhcmVudFRpbGUpIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIHBhcmVudFRpbGUuYmluZChnbCk7XG5cbiAgICAgICAgdmFyIHRpbGVQb3MgPSBUaWxlQ29vcmQuZnJvbUlEKHRleHR1cmUuaWQpO1xuICAgICAgICB2YXIgcGFyZW50UG9zID0gcGFyZW50VGlsZSAmJiBUaWxlQ29vcmQuZnJvbUlEKHBhcmVudFRpbGUuaWQpO1xuICAgICAgICBwYXJlbnRTY2FsZUJ5ID0gTWF0aC5wb3coMiwgcGFyZW50UG9zLnogLSB0aWxlUG9zLnopO1xuICAgICAgICBwYXJlbnRUTCA9IFt0aWxlUG9zLnggKiBwYXJlbnRTY2FsZUJ5ICUgMSwgdGlsZVBvcy55ICogcGFyZW50U2NhbGVCeSAlIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wYWNpdGllc1sxXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlclNjYWxlID0gYnVja2V0LnByZXJlbmRlcmVkID8gKDQwOTYgKiAoMSArIDIgKiBidWNrZXQucHJlcmVuZGVyZWQuYnVmZmVyKSkgLyA0MDk2IDogMTtcblxuICAgIC8vIGNyb3NzLWZhZGUgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfdGxfcGFyZW50LCBwYXJlbnRUTCB8fCBbMCwgMF0pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zY2FsZV9wYXJlbnQsIHBhcmVudFNjYWxlQnkgfHwgMSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2J1ZmZlcl9zY2FsZSwgYnVmZmVyU2NhbGUpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5MCwgb3BhY2l0aWVzWzBdKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eTEsIG9wYWNpdGllc1sxXSk7XG4gICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlMCwgMCk7XG4gICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlMSwgMSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4dHVyZS5ib3VuZHNCdWZmZXIgfHwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCAgICAgICAgIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV90ZXh0dXJlX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA4LCA0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xufVxuXG5mdW5jdGlvbiBmaW5kUGFyZW50KHRpbGUpIHtcbiAgICB2YXIgc291cmNlID0gdGlsZS5zb3VyY2U7XG4gICAgaWYgKCFzb3VyY2UpIHJldHVybjtcbiAgICB2YXIgcGFyZW50VGlsZXMgPSB7fTtcbiAgICBzb3VyY2UuX2ZpbmRMb2FkZWRQYXJlbnQodGlsZS5pZCwgc291cmNlLm9wdGlvbnMubWluWm9vbSwgcGFyZW50VGlsZXMpO1xuICAgIHJldHVybiBzb3VyY2UudGlsZXNbT2JqZWN0LmtleXMocGFyZW50VGlsZXMpWzBdXTtcbn1cblxuZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIG4pKTtcbn1cblxuZnVuY3Rpb24gc3BpbldlaWdodHMoYW5nbGUpIHtcbiAgICBhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgICgyICogYyArIDEpIC8gMyxcbiAgICAgICAgKC1NYXRoLnNxcnQoMykgKiBzIC0gYyArIDEpIC8gMyxcbiAgICAgICAgKE1hdGguc3FydCgzKSAqIHMgLSBjICsgMSkgLyAzXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gY29udHJhc3RGYWN0b3IoY29udHJhc3QpIHtcbiAgICByZXR1cm4gY29udHJhc3QgPiAwID9cbiAgICAgICAgMSAvICgxIC0gY29udHJhc3QpIDpcbiAgICAgICAgMSArIGNvbnRyYXN0O1xufVxuXG5mdW5jdGlvbiBzYXR1cmF0aW9uRmFjdG9yKHNhdHVyYXRpb24pIHtcbiAgICByZXR1cm4gc2F0dXJhdGlvbiA+IDAgP1xuICAgICAgICAxIC0gMSAvICgxLjAwMSAtIHNhdHVyYXRpb24pIDpcbiAgICAgICAgLXNhdHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldE9wYWNpdGllcyh0aWxlLCBwYXJlbnRUaWxlKSB7XG4gICAgaWYgKCF0aWxlLnNvdXJjZSkgcmV0dXJuIFsxLCAwXTtcblxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgZmFkZUR1cmF0aW9uID0gdGlsZS5zb3VyY2UubWFwLnN0eWxlLnJhc3RlckZhZGVEdXJhdGlvbjtcblxuICAgIHZhciBzaW5jZVRpbGUgPSAobm93IC0gdGlsZS50aW1lQWRkZWQpIC8gZmFkZUR1cmF0aW9uO1xuICAgIHZhciBzaW5jZVBhcmVudCA9IHBhcmVudFRpbGUgPyAobm93IC0gcGFyZW50VGlsZS50aW1lQWRkZWQpIC8gZmFkZUR1cmF0aW9uIDogLTE7XG5cbiAgICB2YXIgdGlsZVBvcyA9IFRpbGVDb29yZC5mcm9tSUQodGlsZS5pZCk7XG4gICAgdmFyIHBhcmVudFBvcyA9IHBhcmVudFRpbGUgJiYgVGlsZUNvb3JkLmZyb21JRChwYXJlbnRUaWxlLmlkKTtcblxuICAgIHZhciBpZGVhbFogPSB0aWxlLnNvdXJjZS5fY292ZXJpbmdab29tTGV2ZWwodGlsZS5zb3VyY2UuX2dldFpvb20oKSk7XG4gICAgdmFyIHBhcmVudEZ1cnRoZXIgPSBwYXJlbnRUaWxlID8gTWF0aC5hYnMocGFyZW50UG9zLnogLSBpZGVhbFopID4gTWF0aC5hYnModGlsZVBvcy56IC0gaWRlYWxaKSA6IGZhbHNlO1xuXG4gICAgdmFyIG9wYWNpdHkgPSBbXTtcbiAgICBpZiAoIXBhcmVudFRpbGUgfHwgcGFyZW50RnVydGhlcikge1xuICAgICAgICAvLyBpZiBubyBwYXJlbnQgb3IgcGFyZW50IGlzIG9sZGVyXG4gICAgICAgIG9wYWNpdHlbMF0gPSBjbGFtcChzaW5jZVRpbGUsIDAsIDEpO1xuICAgICAgICBvcGFjaXR5WzFdID0gMSAtIG9wYWNpdHlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIHlvdW5nZXIsIHpvb21pbmcgb3V0XG4gICAgICAgIG9wYWNpdHlbMF0gPSBjbGFtcCgxIC0gc2luY2VQYXJlbnQsIDAsIDEpO1xuICAgICAgICBvcGFjaXR5WzFdID0gMSAtIG9wYWNpdHlbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wYWNpdHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLm1hdDQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1N5bWJvbHM7XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2xzKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSkge1xuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICBpZiAoYnVja2V0LmVsZW1lbnRHcm91cHMudGV4dC5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgIGRyYXdTeW1ib2woZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlLCAndGV4dCcpO1xuICAgIH1cbiAgICBpZiAoYnVja2V0LmVsZW1lbnRHcm91cHMuaWNvbi5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgIGRyYXdTeW1ib2woZ2wsIHBhaW50ZXIsIGJ1Y2tldCwgbGF5ZXJTdHlsZSwgcG9zTWF0cml4LCBwYXJhbXMsIGltYWdlU3ByaXRlLCAnaWNvbicpO1xuICAgIH1cbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn1cblxudmFyIGRlZmF1bHRTaXplcyA9IHtcbiAgICBpY29uOiAxLFxuICAgIHRleHQ6IDI0XG59O1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9sKGdsLCBwYWludGVyLCBidWNrZXQsIGxheWVyU3R5bGUsIHBvc01hdHJpeCwgcGFyYW1zLCBpbWFnZVNwcml0ZSwgcHJlZml4KSB7XG5cbiAgICBwb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHBhcmFtcy56LCBsYXllclN0eWxlW3ByZWZpeCArICctdHJhbnNsYXRlJ10sIGxheWVyU3R5bGVbcHJlZml4ICsgJy10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgdmFyIGluZm8gPSBidWNrZXQuaW5mbztcblxuICAgIHZhciBleE1hdHJpeCA9IG1hdDQuY2xvbmUocGFpbnRlci5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICB2YXIgYWxpZ25lZFdpdGhNYXAgPSBpbmZvW3ByZWZpeCArICctcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnO1xuICAgIHZhciBhbmdsZU9mZnNldCA9IChhbGlnbmVkV2l0aE1hcCA/IHBhaW50ZXIudHJhbnNmb3JtLmFuZ2xlIDogMCk7XG5cbiAgICBpZiAoYW5nbGVPZmZzZXQpIHtcbiAgICAgICAgbWF0NC5yb3RhdGVaKGV4TWF0cml4LCBleE1hdHJpeCwgYW5nbGVPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIElmIGxheWVyU3R5bGUuc2l6ZSA+IGluZm9bcHJlZml4ICsgJy1tYXgtc2l6ZSddIHRoZW4gbGFiZWxzIG1heSBjb2xsaWRlXG4gICAgdmFyIGZvbnRTaXplID0gbGF5ZXJTdHlsZVtwcmVmaXggKyAnLXNpemUnXSB8fCBpbmZvW3ByZWZpeCArICctbWF4LXNpemUnXTtcbiAgICB2YXIgZm9udFNjYWxlID0gZm9udFNpemUgLyBkZWZhdWx0U2l6ZXNbcHJlZml4XTtcbiAgICBtYXQ0LnNjYWxlKGV4TWF0cml4LCBleE1hdHJpeCwgWyBmb250U2NhbGUsIGZvbnRTY2FsZSwgMSBdKTtcblxuICAgIHZhciB0ZXh0ID0gcHJlZml4ID09PSAndGV4dCc7XG4gICAgdmFyIHNkZiA9IHRleHQgfHwgYnVja2V0LmVsZW1lbnRHcm91cHMuc2RmSWNvbnM7XG4gICAgdmFyIHNoYWRlciwgYnVmZmVyLCB0ZXhzaXplO1xuXG4gICAgaWYgKCF0ZXh0ICYmICFpbWFnZVNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICBpZiAoc2RmKSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuc2RmU2hhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuaWNvblNoYWRlcjtcbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgICBwYWludGVyLmdseXBoQXRsYXMudXBkYXRlVGV4dHVyZShnbCk7XG4gICAgICAgIGJ1ZmZlciA9IGJ1Y2tldC5idWZmZXJzLmdseXBoVmVydGV4O1xuICAgICAgICB0ZXhzaXplID0gW3BhaW50ZXIuZ2x5cGhBdGxhcy53aWR0aCAvIDQsIHBhaW50ZXIuZ2x5cGhBdGxhcy5oZWlnaHQgLyA0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZVNwcml0ZS5iaW5kKGdsLCBhbGlnbmVkV2l0aE1hcCB8fCBwYXJhbXMucm90YXRpbmcgfHwgcGFyYW1zLnpvb21pbmcgfHwgZm9udFNjYWxlICE9IDEgfHwgc2RmKTtcbiAgICAgICAgYnVmZmVyID0gYnVja2V0LmJ1ZmZlcnMuaWNvblZlcnRleDtcbiAgICAgICAgdGV4c2l6ZSA9IFtpbWFnZVNwcml0ZS5pbWcud2lkdGgsIGltYWdlU3ByaXRlLmltZy5oZWlnaHRdO1xuICAgIH1cblxuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCwgZXhNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV90ZXh0dXJlLCAwKTtcbiAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3RleHNpemUsIHRleHNpemUpO1xuXG4gICAgYnVmZmVyLmJpbmQoZ2wpO1xuXG4gICAgdmFyIHVieXRlID0gZ2wuVU5TSUdORURfQllURTtcblxuICAgIHZhciBzdHJpZGUgPSB0ZXh0ID8gMTYgOiAyMDtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCAgICAgICAgICAyLCBnbC5TSE9SVCwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9vZmZzZXQsICAgICAgIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2xhYmVsbWluem9vbSwgMSwgdWJ5dGUsICAgIGZhbHNlLCBzdHJpZGUsIDgpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfbWluem9vbSwgICAgICAxLCB1Ynl0ZSwgICAgZmFsc2UsIHN0cmlkZSwgOSk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9tYXh6b29tLCAgICAgIDEsIHVieXRlLCAgICBmYWxzZSwgc3RyaWRlLCAxMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9hbmdsZSwgICAgICAgIDEsIHVieXRlLCAgICBmYWxzZSwgc3RyaWRlLCAxMSk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9yYW5nZWVuZCwgICAgIDEsIHVieXRlLCAgICBmYWxzZSwgc3RyaWRlLCAxMik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9yYW5nZXN0YXJ0LCAgIDEsIHVieXRlLCAgICBmYWxzZSwgc3RyaWRlLCAxMyk7XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3RleCwgICAgICAgICAgMiwgdWJ5dGUsICAgICBmYWxzZSwgc3RyaWRlLCAxNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV90ZXgsICAgICAgICAgIDIsIGdsLlNIT1JULCAgZmFsc2UsIHN0cmlkZSwgMTYpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdGhlIC1waS4ucGkgdG8gYW4gaW50OCByYW5nZS5cbiAgICB2YXIgYW5nbGUgPSBNYXRoLnJvdW5kKChwYWludGVyLnRyYW5zZm9ybS5hbmdsZSkgLyBNYXRoLlBJICogMTI4KTtcblxuICAgIC8vIGFkanVzdCBtaW4vbWF4IHpvb21zIGZvciB2YXJpYWJsZSBmb250IHNpZXNcbiAgICB2YXIgem9vbUFkanVzdCA9IE1hdGgubG9nKGZvbnRTaXplIC8gaW5mb1twcmVmaXggKyAnLW1heC1zaXplJ10pIC8gTWF0aC5MTjIgfHwgMDtcblxuICAgIHZhciBmbGlwID0gYWxpZ25lZFdpdGhNYXAgJiYgaW5mb1twcmVmaXggKyAnLWtlZXAtdXByaWdodCddO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mbGlwLCBmbGlwID8gMSA6IDApO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9hbmdsZSwgKGFuZ2xlICsgMjU2KSAlIDI1Nik7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3pvb20sIChwYWludGVyLnRyYW5zZm9ybS56b29tIC0gem9vbUFkanVzdCkgKiAxMCk7IC8vIGN1cnJlbnQgem9vbSBsZXZlbFxuXG4gICAgdmFyIGYgPSBwYWludGVyLmZyYW1lSGlzdG9yeS5nZXRGYWRlUHJvcGVydGllcygzMDApO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlZGlzdCwgZi5mYWRlZGlzdCAqIDEwKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWluZmFkZXpvb20sIE1hdGguZmxvb3IoZi5taW5mYWRlem9vbSAqIDEwKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21heGZhZGV6b29tLCBNYXRoLmZsb29yKGYubWF4ZmFkZXpvb20gKiAxMCkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlem9vbSwgKHBhaW50ZXIudHJhbnNmb3JtLnpvb20gKyBmLmJ1bXApICogMTApO1xuXG4gICAgaWYgKCFzZGYpIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBsYXllclN0eWxlWydpY29uLW9wYWNpdHknXSk7XG5cbiAgICB2YXIgc2RmRm9udFNpemUgPSB0ZXh0ID8gMjQgOiAxO1xuICAgIHZhciBzZGZQeCA9IDg7XG4gICAgdmFyIGJsdXJPZmZzZXQgPSAxLjE5O1xuICAgIHZhciBoYWxvT2Zmc2V0ID0gNjtcblxuICAgIGlmIChzZGYpIHtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIDAuMTA1ICogc2RmRm9udFNpemUgLyBmb250U2l6ZSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGxheWVyU3R5bGVbcHJlZml4ICsgJy1jb2xvciddKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2J1ZmZlciwgKDI1NiAtIDY0KSAvIDI1Nik7XG4gICAgfVxuXG4gICAgdmFyIGJlZ2luID0gYnVja2V0LmVsZW1lbnRHcm91cHNbcHJlZml4XS5ncm91cHNbMF0udmVydGV4U3RhcnRJbmRleCxcbiAgICAgICAgbGVuID0gYnVja2V0LmVsZW1lbnRHcm91cHNbcHJlZml4XS5ncm91cHNbMF0udmVydGV4TGVuZ3RoO1xuXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIGJlZ2luLCBsZW4pO1xuXG4gICAgaWYgKHNkZiAmJiBsYXllclN0eWxlW3ByZWZpeCArICctaGFsby1jb2xvciddKSB7XG4gICAgICAgIC8vIERyYXcgaGFsbyB1bmRlcm5lYXRoIHRoZSB0ZXh0LlxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIChsYXllclN0eWxlW3ByZWZpeCArICctaGFsby1ibHVyJ10gKiBibHVyT2Zmc2V0IC8gKGZvbnRTaXplIC8gc2RmRm9udFNpemUpIC8gc2RmUHgpICsgKDAuMTA1ICogc2RmRm9udFNpemUgLyBmb250U2l6ZSkgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBsYXllclN0eWxlW3ByZWZpeCArICctaGFsby1jb2xvciddKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2J1ZmZlciwgKGhhbG9PZmZzZXQgLSBsYXllclN0eWxlW3ByZWZpeCArICctaGFsby13aWR0aCddIC8gKGZvbnRTaXplIC8gc2RmRm9udFNpemUpKSAvIHNkZlB4KTtcblxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgYmVnaW4sIGxlbik7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xudmFyIG1hdDQgPSByZXF1aXJlKCcuLi9saWIvZ2xtYXRyaXguanMnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdWZXJ0aWNlcztcblxuZnVuY3Rpb24gZHJhd1ZlcnRpY2VzKGdsLCBwYWludGVyLCBidWNrZXQpIHtcbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRvdFNoYWRlciwgcGFpbnRlci50aWxlLnBvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgIC8vIC8vIERyYXcgZGVidWcgcG9pbnRzLlxuICAgIGdsLnVuaWZvcm0xZihwYWludGVyLmRvdFNoYWRlci51X3NpemUsIDQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGdsLnVuaWZvcm0xZihwYWludGVyLmRvdFNoYWRlci51X2JsdXIsIDAuMjUpO1xuICAgIGdsLnVuaWZvcm00ZnYocGFpbnRlci5kb3RTaGFkZXIudV9jb2xvciwgWzAuMjUsIDAsIDAsIDAuMjVdKTtcblxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCB0cmlhbmdsZSBmYW4gaW50byB0aGUgc3RlbmNpbCBidWZmZXIuXG5cbiAgICB2YXIgdmVydGV4LCBncm91cHMsIGdyb3VwLCBiZWdpbiwgY291bnQ7XG5cbiAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgaWYgKGJ1Y2tldC5pbmZvLmZpbGwpIHtcbiAgICAgICAgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMuZmlsbFZlcnRleDtcbiAgICAgICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgICAgICBncm91cHMgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5ncm91cHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIGJlZ2luID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgICAgIGNvdW50ID0gZ3JvdXAudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmRvdFNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCBiZWdpbiwgY291bnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld1Bvc01hdHJpeCA9IG1hdDQuY2xvbmUocGFpbnRlci50aWxlLnBvc01hdHJpeCk7XG4gICAgbWF0NC5zY2FsZShuZXdQb3NNYXRyaXgsIG5ld1Bvc01hdHJpeCwgWzAuNSwgMC41LCAxXSk7XG5cbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5kb3RTaGFkZXIsIG5ld1Bvc01hdHJpeCwgcGFpbnRlci50aWxlLmV4TWF0cml4KTtcblxuICAgIC8vIERyYXcgYWxsIGxpbmUgYnVmZmVyc1xuICAgIGlmIChidWNrZXQuaW5mby5saW5lKSB7XG4gICAgICAgIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmxpbmVWZXJ0ZXg7XG4gICAgICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICAgICAgZ3JvdXBzID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZ3JvdXBzO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyb3Vwcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBncm91cHNba107XG4gICAgICAgICAgICBiZWdpbiA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLnZlcnRleExlbmd0aDtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kb3RTaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgYmVnaW4sIGNvdW50KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWVIaXN0b3J5O1xuXG5mdW5jdGlvbiBGcmFtZUhpc3RvcnkoKSB7XG59XG5cbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUuZ2V0RmFkZVByb3BlcnRpZXMgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSBkdXJhdGlvbiA9IDMwMDtcbiAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUmVtb3ZlIGZyYW1lcyB1bnRpbCBvbmx5IG9uZSBpcyBvdXRzaWRlIHRoZSBkdXJhdGlvbiwgb3IgdW50aWwgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICB3aGlsZSAoZnJhbWVIaXN0b3J5Lmxlbmd0aCA+IDMgJiYgZnJhbWVIaXN0b3J5WzFdLnRpbWUgKyBkdXJhdGlvbiA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIGZyYW1lSGlzdG9yeS5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChmcmFtZUhpc3RvcnlbMV0udGltZSArIGR1cmF0aW9uIDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgZnJhbWVIaXN0b3J5WzBdLnogPSBmcmFtZUhpc3RvcnlbMV0uejtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVMZW4gPSBmcmFtZUhpc3RvcnkubGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbiA8IDMpIGNvbnNvbGUud2FybigndGhlcmUgc2hvdWxkIG5ldmVyIGJlIGxlc3MgdGhhbiB0aHJlZSBmcmFtZXMgaW4gdGhlIGhpc3RvcnknKTtcblxuICAgIC8vIEZpbmQgdGhlIHJhbmdlIG9mIHpvb20gbGV2ZWxzIHdlIHdhbnQgdG8gZmFkZSBiZXR3ZWVuXG4gICAgdmFyIHN0YXJ0aW5nWiA9IGZyYW1lSGlzdG9yeVswXS56LFxuICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZUhpc3RvcnlbZnJhbWVMZW4gLSAxXSxcbiAgICAgICAgZW5kaW5nWiA9IGxhc3RGcmFtZS56LFxuICAgICAgICBsb3daID0gTWF0aC5taW4oc3RhcnRpbmdaLCBlbmRpbmdaKSxcbiAgICAgICAgaGlnaFogPSBNYXRoLm1heChzdGFydGluZ1osIGVuZGluZ1opO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzcGVlZCBvZiB6b29taW5nLCBhbmQgaG93IGZhciBpdCB3b3VsZCB6b29tIGluIHRlcm1zIG9mIHpvb20gbGV2ZWxzIGluIG9uZSBkdXJhdGlvblxuICAgIHZhciB6b29tRGlmZiA9IGxhc3RGcmFtZS56IC0gZnJhbWVIaXN0b3J5WzFdLnosXG4gICAgICAgIHRpbWVEaWZmID0gbGFzdEZyYW1lLnRpbWUgLSBmcmFtZUhpc3RvcnlbMV0udGltZTtcbiAgICB2YXIgZmFkZWRpc3QgPSB6b29tRGlmZiAvICh0aW1lRGlmZiAvIGR1cmF0aW9uKTtcblxuICAgIGlmIChpc05hTihmYWRlZGlzdCkpIGNvbnNvbGUud2FybignZmFkZWRpc3Qgc2hvdWxkIG5ldmVyIGJlIE5hTicpO1xuXG4gICAgLy8gQXQgZW5kIG9mIGEgem9vbSB3aGVuIHRoZSB6b29tIHN0b3BzIGNoYW5naW5nIGNvbnRpbnVlIHByZXRlbmRpbmcgdG8gem9vbSBhdCB0aGF0IHNwZWVkXG4gICAgLy8gYnVtcCBpcyBob3cgbXVjaCBmYXJ0aGVyIGl0IHdvdWxkIGhhdmUgYmVlbiBpZiBpdCBoYWQgY29udGludWVkIHpvb21pbmcgYXQgdGhlIHNhbWUgcmF0ZVxuICAgIHZhciBidW1wID0gKGN1cnJlbnRUaW1lIC0gbGFzdEZyYW1lLnRpbWUpIC8gZHVyYXRpb24gKiBmYWRlZGlzdDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZhZGVkaXN0OiBmYWRlZGlzdCxcbiAgICAgICAgbWluZmFkZXpvb206IGxvd1osXG4gICAgICAgIG1heGZhZGV6b29tOiBoaWdoWixcbiAgICAgICAgYnVtcDogYnVtcFxuICAgIH07XG59O1xuXG4vLyBTdG9yZSBwcmV2aW91cyByZW5kZXIgdGltZXNcbnZhciBmcmFtZUhpc3RvcnkgPSBbXTtcblxuLy8gUmVjb3JkIGZyYW1lIGhpc3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGZhZGluZyBwYXJhbXNcbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBmaXJzdCBmcmFtZSBldmVyXG4gICAgaWYgKCFmcmFtZUhpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgIGZyYW1lSGlzdG9yeS5wdXNoKHt0aW1lOiAwLCB6OiB6b29tIH0sIHt0aW1lOiAwLCB6OiB6b29tIH0pO1xuICAgIH1cblxuICAgIGlmIChmcmFtZUhpc3RvcnkubGVuZ3RoID09PSAyIHx8IGZyYW1lSGlzdG9yeVtmcmFtZUhpc3RvcnkubGVuZ3RoIC0gMV0ueiAhPT0gem9vbSkge1xuICAgICAgICBmcmFtZUhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiBjdXJyZW50VGltZSxcbiAgICAgICAgICAgIHo6IHpvb21cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2hhZGVycyA9IHJlcXVpcmUoJy4vc2hhZGVycy5qcycpO1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmdldFNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0eXBlID09IHRoaXMuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnO1xuICAgICAgICBpZiAoIXNoYWRlcnNbbmFtZV0gfHwgIXNoYWRlcnNbbmFtZV1ba2luZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHNoYWRlciBcIiArIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICB0aGlzLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlcnNbbmFtZV1ba2luZF0pO1xuICAgICAgICB0aGlzLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIGNvbnRleHQuaW5pdGlhbGl6ZVNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSB7XG4gICAgICAgICAgICBwcm9ncmFtOiB0aGlzLmNyZWF0ZVByb2dyYW0oKSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmdldFNoYWRlcihuYW1lLCB0aGlzLkZSQUdNRU5UX1NIQURFUiksXG4gICAgICAgICAgICB2ZXJ0ZXg6IHRoaXMuZ2V0U2hhZGVyKG5hbWUsIHRoaXMuVkVSVEVYX1NIQURFUiksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgc2hhZGVyLnZlcnRleCk7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBzaGFkZXIuZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLmxpbmtQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblxuICAgICAgICBpZiAoIXRoaXMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXIucHJvZ3JhbSwgdGhpcy5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5nZXRQcm9ncmFtSW5mb0xvZyhzaGFkZXIucHJvZ3JhbSkpO1xuICAgICAgICAgICAgYWxlcnQoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIgXCIgKyBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNoYWRlclthdHRyaWJ1dGVzW2ldXSA9IHRoaXMuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLnB1c2goc2hhZGVyW2F0dHJpYnV0ZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pZm9ybXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJbdW5pZm9ybXNba11dID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIHVuaWZvcm1zW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIC8vIFN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHNoYWRlciBwcm9ncmFtLlxuICAgIGNvbnRleHQuc3dpdGNoU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KSB7XG4gICAgICAgIGlmICghcG9zTWF0cml4KSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCdwb3NNYXRyaXggZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNoYWRlciAhPT0gc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuXG4gICAgICAgICAgICAvLyBEaXNhYmxlIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGV4aXN0aW5nIHNoYWRlciB0aGF0IGFyZW4ndCB1c2VkIGluXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHNoYWRlci4gTm90ZTogYXR0cmlidXRlIGluZGljZXMgYXJlICpub3QqIHByb2dyYW0gc3BlY2lmaWMhXG4gICAgICAgICAgICB2YXIgZW5hYmxlZCA9IHRoaXMuY3VycmVudFNoYWRlciA/IHRoaXMuY3VycmVudFNoYWRlci5hdHRyaWJ1dGVzIDogW107XG4gICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBzaGFkZXIuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmFibGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkLmluZGV4T2YoZW5hYmxlZFtpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGVuYWJsZWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5hYmxlIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGUgbmV3IHNoYWRlci5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVxdWlyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZC5pbmRleE9mKHJlcXVpcmVkW2pdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShyZXF1aXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1hdHJpY2VzIGlmIG5lY2Vzc2FyeS4gTm90ZTogVGhpcyByZWxpZXMgb24gb2JqZWN0IGlkZW50aXR5IVxuICAgICAgICAvLyBUaGlzIG1lYW5zIGNoYW5naW5nIHRoZSBtYXRyaXggdmFsdWVzIHdpdGhvdXQgdGhlIGFjdHVhbCBtYXRyaXggb2JqZWN0XG4gICAgICAgIC8vIHdpbGwgRkFJTCB0byB1cGRhdGUgdGhlIG1hdHJpeCBwcm9wZXJseS5cbiAgICAgICAgaWYgKHNoYWRlci5wb3NNYXRyaXggIT09IHBvc01hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtTWF0cml4NGZ2KHNoYWRlci51X3Bvc21hdHJpeCwgZmFsc2UsIHBvc01hdHJpeCk7XG4gICAgICAgICAgICBzaGFkZXIucG9zTWF0cml4ID0gcG9zTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleE1hdHJpeCAmJiBzaGFkZXIuZXhNYXRyaXggIT09IGV4TWF0cml4ICYmIHNoYWRlci51X2V4bWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVfZXhtYXRyaXgsIGZhbHNlLCBleE1hdHJpeCk7XG4gICAgICAgICAgICBzaGFkZXIuZXhNYXRyaXggPSBleE1hdHJpeDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbHV0aWwgPSByZXF1aXJlKCcuL2dsdXRpbC5qcycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXIuanMnKTtcbnZhciBHbHlwaEF0bGFzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoYXRsYXMuanMnKTtcbnZhciBnbG1hdHJpeCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpO1xudmFyIEZyYW1lSGlzdG9yeSA9IHJlcXVpcmUoJy4vZnJhbWVoaXN0b3J5LmpzJyk7XG5cbnZhciBtYXQ0ID0gZ2xtYXRyaXgubWF0NDtcblxudmFyIGRyYXdTeW1ib2wgPSByZXF1aXJlKCcuL2RyYXdzeW1ib2wuanMnKTtcbnZhciBkcmF3TGluZSA9IHJlcXVpcmUoJy4vZHJhd2xpbmUuanMnKTtcbnZhciBkcmF3RmlsbCA9IHJlcXVpcmUoJy4vZHJhd2ZpbGwuanMnKTtcbnZhciBkcmF3UmFzdGVyID0gcmVxdWlyZSgnLi9kcmF3cmFzdGVyLmpzJyk7XG52YXIgZHJhd0RlYnVnID0gcmVxdWlyZSgnLi9kcmF3ZGVidWcuanMnKTtcbnZhciBkcmF3QmFja2dyb3VuZCA9IHJlcXVpcmUoJy4vZHJhd2JhY2tncm91bmQuanMnKTtcbnZhciBkcmF3VmVydGljZXMgPSByZXF1aXJlKCcuL2RyYXd2ZXJ0aWNlcy5qcycpO1xuXG4vKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBwYWludGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0NhbnZhc30gZ2wgYW4gZXhwZXJpbWVudGFsLXdlYmdsIGRyYXdpbmcgY29udGV4dFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEdMUGFpbnRlcjtcbmZ1bmN0aW9uIEdMUGFpbnRlcihnbCwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5nbCA9IGdsdXRpbC5leHRlbmQoZ2wpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXG4gICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzID0ge307XG4gICAgdGhpcy5wcmVGYm9zID0ge307XG5cbiAgICB0aGlzLnRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHRoaXMuZnJhbWVIaXN0b3J5ID0gbmV3IEZyYW1lSGlzdG9yeSgpO1xuXG4gICAgdGhpcy5zZXR1cCgpO1xufVxuXG4vKlxuICogVXBkYXRlIHRoZSBHTCB2aWV3cG9ydCwgcHJvamVjdGlvbiBtYXRyaXgsIGFuZCB0cmFuc2Zvcm1zIHRvIGNvbXBlbnNhdGVcbiAqIGZvciBhIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlLlxuICovXG5HTFBhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIEluaXRpYWxpemUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIG1hdDQub3J0aG8odGhpcy5wcm9qZWN0aW9uTWF0cml4LCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCAtMSk7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG59O1xuXG5cbkdMUGFpbnRlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wudmVyYm9zZSA9IHRydWU7XG5cbiAgICAvLyBXZSBhcmUgYmxlbmRpbmcgdGhlIG5ldyBwaXhlbHMgKmJlaGluZCogdGhlIGV4aXN0aW5nIHBpeGVscy4gVGhhdCB3YXkgd2UgY2FuXG4gICAgLy8gZHJhdyBmcm9udC10by1iYWNrIGFuZCB1c2UgdGhlbiBzdGVuY2lsIGJ1ZmZlciB0byBjdWxsIG9wYXF1ZSBwaXhlbHMgZWFybHkuXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FKTtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgdGhpcy5nbHlwaEF0bGFzID0gbmV3IEdseXBoQXRsYXMoMTAyNCwgMTAyNCk7XG4gICAgLy8gdGhpcy5nbHlwaEF0bGFzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmdseXBoQXRsYXMuYmluZChnbCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcbiAgICB0aGlzLmRlYnVnU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZGVidWcnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9wb3NtYXRyaXgnLCAndV9wb2ludHNpemUnLCAndV9jb2xvciddKTtcblxuICAgIHRoaXMuY29tcG9zaXRlU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignY29tcG9zaXRlJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfcG9zbWF0cml4JywgJ3Vfb3BhY2l0eSddKTtcblxuICAgIHRoaXMuZ2F1c3NpYW5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdnYXVzc2lhbicsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X3Bvc21hdHJpeCcsICd1X29wYWNpdHknLCAndV9pbWFnZScsICd1X29mZnNldCddKTtcblxuICAgIHRoaXMucmFzdGVyU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcigncmFzdGVyJyxcbiAgICAgICAgWydhX3BvcycsICdhX3RleHR1cmVfcG9zJ10sXG4gICAgICAgIFsndV9wb3NtYXRyaXgnLCAndV9icmlnaHRuZXNzX2xvdycsICd1X2JyaWdodG5lc3NfaGlnaCcsICd1X3NhdHVyYXRpb25fZmFjdG9yJywgJ3Vfc3Bpbl93ZWlnaHRzJywgJ3VfY29udHJhc3RfZmFjdG9yJywgJ3Vfb3BhY2l0eTAnLCAndV9vcGFjaXR5MScsICd1X2ltYWdlMCcsICd1X2ltYWdlMScsICd1X3RsX3BhcmVudCcsICd1X3NjYWxlX3BhcmVudCcsICd1X2J1ZmZlcl9zY2FsZSddKTtcblxuICAgIHRoaXMubGluZVNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmUnLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfZXh0cnVkZScsICdhX2xpbmVzb2ZhciddLFxuICAgICAgICBbJ3VfcG9zbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV9saW5ld2lkdGgnLCAndV9jb2xvcicsICd1X2RlYnVnJywgJ3VfcmF0aW8nLCAndV9kYXNoYXJyYXknLCAndV9ibHVyJ10pO1xuXG4gICAgdGhpcy5saW5lcGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmVwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcycsICdhX2V4dHJ1ZGUnLCAnYV9saW5lc29mYXInXSxcbiAgICAgICAgWyd1X3Bvc21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfcmF0aW8nLCAndV9wYXR0ZXJuX3NpemUnLCAndV9wYXR0ZXJuX3RsJywgJ3VfcGF0dGVybl9icicsICd1X3BvaW50JywgJ3VfYmx1cicsICd1X2ZhZGUnXSk7XG5cbiAgICB0aGlzLmRvdFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2RvdCcsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X3Bvc21hdHJpeCcsICd1X3NpemUnLCAndV9jb2xvcicsICd1X2JsdXInXSk7XG5cbiAgICB0aGlzLnNkZlNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ3NkZicsXG4gICAgICAgIFsnYV9wb3MnLCAnYV90ZXgnLCAnYV9vZmZzZXQnLCAnYV9hbmdsZScsICdhX21pbnpvb20nLCAnYV9tYXh6b29tJywgJ2FfcmFuZ2VlbmQnLCAnYV9yYW5nZXN0YXJ0JywgJ2FfbGFiZWxtaW56b29tJ10sXG4gICAgICAgIFsndV9wb3NtYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3VfY29sb3InLCAndV9nYW1tYScsICd1X2J1ZmZlcicsICd1X2FuZ2xlJywgJ3Vfem9vbScsICd1X2ZsaXAnLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbSddKTtcblxuICAgIHRoaXMuaWNvblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ljb24nLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4JywgJ2Ffb2Zmc2V0JywgJ2FfYW5nbGUnLCAnYV9taW56b29tJywgJ2FfbWF4em9vbScsICdhX3JhbmdlZW5kJywgJ2FfcmFuZ2VzdGFydCcsICdhX2xhYmVsbWluem9vbSddLFxuICAgICAgICBbJ3VfcG9zbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV90ZXh0dXJlJywgJ3VfdGV4c2l6ZScsICd1X2FuZ2xlJywgJ3Vfem9vbScsICd1X2ZsaXAnLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbScsICd1X29wYWNpdHknXSk7XG5cbiAgICB0aGlzLm91dGxpbmVTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdvdXRsaW5lJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfcG9zbWF0cml4JywgJ3VfY29sb3InLCAndV93b3JsZCddXG4gICAgKTtcblxuICAgIHRoaXMucGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ3BhdHRlcm4nLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9wb3NtYXRyaXgnLCAndV9wYXR0ZXJuX3RsJywgJ3VfcGF0dGVybl9icicsICd1X21peCcsICd1X3BhdHRlcm5tYXRyaXgnLCAndV9vcGFjaXR5JywgJ3VfaW1hZ2UnXVxuICAgICk7XG5cbiAgICB0aGlzLmZpbGxTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdmaWxsJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfcG9zbWF0cml4JywgJ3VfY29sb3InXVxuICAgICk7XG5cbiAgICB0aGlzLmlkZW50aXR5TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAgIC8vIFRoZSBiYWNrZ3JvdW5kQnVmZmVyIGlzIHVzZWQgd2hlbiBkcmF3aW5nIHRvIHRoZSBmdWxsICpjYW52YXMqXG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1TaXplID0gMjtcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbUNvdW50ID0gNDtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoWy0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxXSksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIFRoZSB0aWxlRXh0ZW50QnVmZmVyIGlzIHVzZWQgd2hlbiBkcmF3aW5nIHRvIGEgZnVsbCAqdGlsZSpcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbVNpemUgPSA0O1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQgPSA0O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheShbXG4gICAgICAgIC8vIHRpbGUgY29vcmQgeCwgdGlsZSBjb29yZCB5LCB0ZXh0dXJlIGNvb3JkIHgsIHRleHR1cmUgY29vcmQgeVxuICAgICAgICAgICAgICAgICAgICAgIDAsIDAsICAgICAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICB0aGlzLnRpbGVFeHRlbnQsIDAsICAgICAgICAgICAgICAgIDMyNzY3LCAwLFxuICAgICAgICAgICAgICAgICAgICAgIDAsIHRoaXMudGlsZUV4dGVudCwgICAgICAwLCAzMjc2NyxcbiAgICAgICAgdGhpcy50aWxlRXh0ZW50LCB0aGlzLnRpbGVFeHRlbnQsICAzMjc2NywgMzI3NjdcbiAgICBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gVGhlIGRlYnVnQnVmZmVyIGlzIHVzZWQgdG8gZHJhdyB0aWxlIG91dGxpbmVzIGZvciBkZWJ1Z2dpbmdcbiAgICB0aGlzLmRlYnVnQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtU2l6ZSA9IDI7XG4gICAgdGhpcy5kZWJ1Z0J1ZmZlci5pdGVtQ291bnQgPSA1O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmRlYnVnQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoWzAsIDAsIDQwOTUsIDAsIDQwOTUsIDQwOTUsIDAsIDQwOTUsIDAsIDBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gVGhlIGRlYnVnVGV4dEJ1ZmZlciBpcyB1c2VkIHRvIGRyYXcgdGlsZSBJRHMgZm9yIGRlYnVnZ2luZ1xuICAgIHRoaXMuZGVidWdUZXh0QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUgPSAyO1xufTtcblxuLypcbiAqIFJlc2V0IHRoZSBjb2xvciBidWZmZXJzIG9mIHRoZSBkcmF3aW5nIGNhbnZhcy5cbiAqL1xuR0xQYWludGVyLnByb3RvdHlwZS5jbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xufTtcblxuLypcbiAqIFJlc2V0IHRoZSBkcmF3aW5nIGNhbnZhcyBieSBjbGVhcmluZyB0aGUgc3RlbmNpbCBidWZmZXIgc28gdGhhdCB3ZSBjYW4gZHJhd1xuICogbmV3IHRpbGVzIGF0IHRoZSBzYW1lIGxvY2F0aW9uLCB3aGlsZSByZXRhaW5pbmcgcHJldmlvdXNseSBkcmF3biBwaXhlbHMuXG4gKi9cbkdMUGFpbnRlci5wcm90b3R5cGUuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhclN0ZW5jaWwoMHgwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3Q2xpcHBpbmdNYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5zd2l0Y2hTaGFkZXIodGhpcy5maWxsU2hhZGVyLCB0aGlzLnRpbGUucG9zTWF0cml4LCB0aGlzLnRpbGUuZXhNYXRyaXgpO1xuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAvLyBDbGVhciB0aGUgZW50aXJlIHN0ZW5jaWwgYnVmZmVyLCBleGNlcHQgZm9yIHRoZSA3dGggYml0LCB3aGljaCBzdG9yZXNcbiAgICAvLyB0aGUgZ2xvYmFsIGNsaXBwaW5nIG1hc2sgdGhhdCBhbGxvd3MgdXMgdG8gYXZvaWQgZHJhd2luZyBpbiByZWdpb25zIG9mXG4gICAgLy8gdGlsZXMgd2UndmUgYWxyZWFkeSBwYWludGVkIGluLlxuICAgIGdsLmNsZWFyU3RlbmNpbCgweDApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4QkYpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cbiAgICAvLyBUaGUgc3RlbmNpbCB0ZXN0IHdpbGwgZmFpbCBhbHdheXMsIG1lYW5pbmcgd2Ugc2V0IGFsbCBwaXhlbHMgY292ZXJlZFxuICAgIC8vIGJ5IHRoaXMgZ2VvbWV0cnkgdG8gMHg4MC4gV2UgdXNlIHRoZSBoaWdoZXN0IGJpdCAweDgwIHRvIG1hcmsgdGhlIHJlZ2lvbnNcbiAgICAvLyB3ZSB3YW50IHRvIGRyYXcgaW4uIEFsbCBwaXhlbHMgdGhhdCBoYXZlIHRoaXMgYml0ICpub3QqIHNldCB3aWxsIG5ldmVyIGJlXG4gICAgLy8gZHJhd24gaW4uXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4QzAsIDB4NDApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4QzApO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5SRVBMQUNFLCBnbC5LRUVQLCBnbC5LRUVQKTtcblxuICAgIC8vIERyYXcgdGhlIGNsaXBwaW5nIG1hc2tcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuZmlsbFNoYWRlci5hX3BvcywgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5SRVBMQUNFKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG59O1xuXG4vKlxuICogRHJhdyBhIG5ldyB0aWxlIHRvIHRoZSBjb250ZXh0LCBhc3N1bWluZyB0aGF0IHRoZSB2aWV3cG9ydCBpc1xuICogYWxyZWFkeSBjb3JyZWN0bHkgc2V0LlxuICovXG5HTFBhaW50ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBnbFBhaW50ZXJEcmF3KHRpbGUsIHN0eWxlLCBsYXllcnMsIHBhcmFtcywgbWF0cml4KSB7XG4gICAgdGhpcy50aWxlID0gdGlsZTtcblxuICAgIC8vIGZhbHNlIHdoZW4gZHJhd2luZyBhIGdyb3VwIG9mIGNvbXBvc2l0ZWQgbGF5ZXJzXG4gICAgaWYgKHRpbGUgJiYgIW1hdHJpeCkge1xuICAgICAgICAvLyBEcmF3IHRoZSByb290IGNsaXBwaW5nIG1hc2suXG4gICAgICAgIHRoaXMuZHJhd0NsaXBwaW5nTWFzaygpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShsYXllcnMpKSBjb25zb2xlLndhcm4oJ0xheWVycyBpcyBub3QgYW4gYXJyYXknKTtcblxuICAgIHRoaXMuZnJhbWVIaXN0b3J5LnJlY29yZCh0aGlzLnRyYW5zZm9ybS56b29tKTtcblxuICAgIC8vIERyYXcgbGF5ZXJzIGZyb250LXRvLWJhY2suXG4gICAgLy8gTGF5ZXJzIGFyZSBhbHJlYWR5IGluIHJldmVyc2Ugb3JkZXIgZnJvbSBzdHlsZS5yZXN0cnVjdHVyZSgpXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmFwcGx5U3R5bGUobGF5ZXJzW2ldLCBzdHlsZSwgdGlsZSAmJiB0aWxlLmJ1Y2tldHMsIHBhcmFtcywgdGlsZSwgbWF0cml4KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRlYnVnKSB7XG4gICAgICAgIGRyYXdEZWJ1Zyh0aGlzLmdsLCB0aGlzLCB0aWxlLCBwYXJhbXMpO1xuICAgIH1cbn07XG5cbkdMUGFpbnRlci5wcm90b3R5cGUuYXBwbHlTdHlsZSA9IGZ1bmN0aW9uKGxheWVyLCBzdHlsZSwgYnVja2V0cywgcGFyYW1zLCB0aWxlLCBtYXRyaXgpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIGxheWVyU3R5bGUgPSBzdHlsZS5jb21wdXRlZFtsYXllci5pZF07XG4gICAgaWYgKCFsYXllclN0eWxlIHx8IGxheWVyU3R5bGUuaGlkZGVuKSByZXR1cm47XG5cbiAgICBpZiAobGF5ZXIubGF5ZXJzICYmIGxheWVyLnR5cGUgPT09ICdyYXN0ZXInKSB7XG4gICAgICAgIGRyYXdSYXN0ZXIoZ2wsIHRoaXMsIGJ1Y2tldHNbbGF5ZXIuYnVja2V0XSwgbGF5ZXJTdHlsZSwgcGFyYW1zLCBzdHlsZSwgbGF5ZXIsIHRpbGUpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcbiAgICAgICAgZHJhd0JhY2tncm91bmQoZ2wsIHRoaXMsIHVuZGVmaW5lZCwgbGF5ZXJTdHlsZSwgdGhpcy5pZGVudGl0eU1hdHJpeCwgcGFyYW1zLCBzdHlsZS5zcHJpdGUpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNbbGF5ZXIuYnVja2V0XTtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIHZlcnRpY2VzIHlldCBmb3IgdGhpcyBsYXllci5cbiAgICAgICAgaWYgKCFidWNrZXQgfHwgKGJ1Y2tldC5oYXNEYXRhICYmICFidWNrZXQuaGFzRGF0YSgpKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0eXBlID0gYnVja2V0LnR5cGU7XG5cbiAgICAgICAgaWYgKGJ1Y2tldC5taW5ab29tICYmIHRoaXMudHJhbnNmb3JtLnpvb20gPCBidWNrZXQubWluWm9vbSkgcmV0dXJuO1xuICAgICAgICBpZiAoYnVja2V0Lm1heFpvb20gJiYgdGhpcy50cmFuc2Zvcm0uem9vbSA+PSBidWNrZXQubWF4Wm9vbSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBkcmF3ID0gdHlwZSA9PT0gJ3N5bWJvbCcgPyBkcmF3U3ltYm9sIDpcbiAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnZmlsbCcgPyBkcmF3RmlsbCA6XG4gICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ2xpbmUnID8gZHJhd0xpbmUgOlxuICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdyYXN0ZXInID8gZHJhd1Jhc3RlciA6IG51bGw7XG5cbiAgICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgICAgIHZhciB1c2VNYXRyaXggPSBtYXRyaXggfHwgdGhpcy50aWxlLnBvc01hdHJpeDtcblxuICAgICAgICAgICAgZHJhdyhnbCwgdGhpcywgYnVja2V0LCBsYXllclN0eWxlLCB1c2VNYXRyaXgsIHBhcmFtcywgc3R5bGUuc3ByaXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gYnVja2V0IHR5cGUgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnZlcnRpY2VzICYmICFsYXllci5sYXllcnMpIHtcbiAgICAgICAgICAgIGRyYXdWZXJ0aWNlcyhnbCwgdGhpcywgYnVja2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIERyYXdzIG5vbi1vcGFxdWUgYXJlYXMuIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbkdMUGFpbnRlci5wcm90b3R5cGUuZHJhd1N0ZW5jaWxCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnN3aXRjaFNoYWRlcih0aGlzLmZpbGxTaGFkZXIsIHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuXG4gICAgLy8gQmxlbmQgdG8gdGhlIGZyb250LCBub3QgdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xuXG4gICAgLy8gRHJ3IHRoZSBmaWxsaW5nIHF1YWQgd2hlcmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzbid0IHNldC5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuZmlsbFNoYWRlci5hX3BvcywgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm00ZnYodGhpcy5maWxsU2hhZGVyLnVfY29sb3IsIFswLCAwLCAwLCAwLjVdKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIC8vIFJldmVydCBibGVuZGluZyBtb2RlIHRvIGJsZW5kIHRvIHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS50cmFuc2xhdGVNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgsIHosIHRyYW5zbGF0ZSwgYW5jaG9yKSB7XG4gICAgaWYgKCF0cmFuc2xhdGVbMF0gJiYgIXRyYW5zbGF0ZVsxXSkgcmV0dXJuIG1hdHJpeDtcblxuICAgIGlmIChhbmNob3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgdmFyIHNpbl9hID0gTWF0aC5zaW4oLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdmFyIGNvc19hID0gTWF0aC5jb3MoLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdHJhbnNsYXRlID0gW1xuICAgICAgICAgICAgdHJhbnNsYXRlWzBdICogY29zX2EgLSB0cmFuc2xhdGVbMV0gKiBzaW5fYSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIHNpbl9hICsgdHJhbnNsYXRlWzFdICogY29zX2FcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgdGlsZVBpeGVsUmF0aW8gPSB0aGlzLnRyYW5zZm9ybS5zY2FsZSAvICgxIDw8IHopIC8gODtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSBbXG4gICAgICAgIHRyYW5zbGF0ZVswXSAvIHRpbGVQaXhlbFJhdGlvLFxuICAgICAgICB0cmFuc2xhdGVbMV0gLyB0aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgMFxuICAgIF07XG5cbiAgICB2YXIgdHJhbnNsYXRlZE1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zbGF0ZWRNYXRyaXgsIG1hdHJpeCwgdHJhbnNsYXRpb24pO1xuICAgIHJldHVybiB0cmFuc2xhdGVkTWF0cml4O1xufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5zYXZlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbdGV4dHVyZS5zaXplXTtcbiAgICBpZiAoIXRleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdID0gW3RleHR1cmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxufTtcblxuXG5HTFBhaW50ZXIucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5yZXVzYWJsZVRleHR1cmVzW3NpemVdO1xuICAgIHJldHVybiB0ZXh0dXJlcyAmJiB0ZXh0dXJlcy5sZW5ndGggPiAwID8gdGV4dHVyZXMucG9wKCkgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsbWF0cml4ID0gcmVxdWlyZSgnLi4vbGliL2dsbWF0cml4LmpzJyk7XG52YXIgbWF0NCA9IGdsbWF0cml4Lm1hdDQ7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJlcmVuZGVyZWRUZXh0dXJlO1xuXG5mdW5jdGlvbiBQcmVyZW5kZXJlZFRleHR1cmUoZ2wsIGJ1Y2tldCwgcGFpbnRlcikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1Y2tldFsncmFzdGVyLWJ1ZmZlciddIHx8ICgxLzMyKTtcbiAgICB0aGlzLnNpemUgPSAoYnVja2V0WydyYXN0ZXItc2l6ZSddIHx8IDUxMikgKiAoMSArIDIgKiB0aGlzLmJ1ZmZlcik7XG4gICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5mYm8gPSBudWxsO1xuICAgIHRoaXMuZmJvcyA9IHRoaXMucGFpbnRlci5wcmVGYm9zW3RoaXMuc2l6ZV07XG59XG5cblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUuYmluZEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIHRyeSB0byByZXVzZSBhdmFpbGFibGUgcmFzdGVyIHRleHR1cmVzXG4gICAgdGhpcy50ZXh0dXJlID0gdGhpcy5wYWludGVyLmdldFRleHR1cmUodGhpcy5zaXplKTtcblxuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy5zaXplLCB0aGlzLnNpemUsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgICB0aGlzLnRleHR1cmUuc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5mYm9zKSB7XG4gICAgICAgIHRoaXMuZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgdmFyIHN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWwpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuU1RFTkNJTF9JTkRFWDgsIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZibyA9IHRoaXMuZmJvcy5wb3AoKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLCAwKTtcbiAgICB9XG59O1xuXG5QcmVyZW5kZXJlZFRleHR1cmUucHJvdG90eXBlLnVuYmluZEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGlmICh0aGlzLmZib3MpIHRoaXMuZmJvcy5wdXNoKHRoaXMuZmJvKTsgZWxzZSB0aGlzLnBhaW50ZXIucHJlRmJvc1t0aGlzLnNpemVdID0gW3RoaXMuZmJvXTtcbn07XG5cblByZXJlbmRlcmVkVGV4dHVyZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB0aHJvdygncHJlLXJlbmRlcmVkIHRleHR1cmUgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG59O1xuXG5QcmVyZW5kZXJlZFRleHR1cmUucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbihwYWludGVyLCBwYXNzZXMpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBvcmlnaW5hbFRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgdmFyIHNlY29uZGFyeVRleHR1cmUgPSB0aGlzLnBhaW50ZXIuZ2V0VGV4dHVyZSh0aGlzLnNpemUpO1xuICAgIGlmICghc2Vjb25kYXJ5VGV4dHVyZSkge1xuICAgICAgICBzZWNvbmRhcnlUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzZWNvbmRhcnlUZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy5zaXplLCB0aGlzLnNpemUsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgICBzZWNvbmRhcnlUZXh0dXJlLnNpemUgPSB0aGlzLnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSk7XG4gICAgfVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG4gICAgdmFyIG1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgbWF0NC5vcnRobyhtYXRyaXgsIDAsIDQwOTYsIC00MDk2LCAwLCAwLCAxKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgWzAsIC00MDk2LCAwXSk7XG5cbiAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5nYXVzc2lhblNoYWRlciwgbWF0cml4KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC51bmlmb3JtMWkocGFpbnRlci5nYXVzc2lhblNoYWRlci51X2ltYWdlLCAwKTtcbiAgICBnbC51bmlmb3JtMWYocGFpbnRlci5nYXVzc2lhblNoYWRlci51X29wYWNpdHksIDEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXNzZXM7IGkrKykge1xuXG4gICAgICAgIC8vIFJlbmRlciBob3Jpem9udGFsXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSwgMCk7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIudV9vZmZzZXQsIFsxIC8gdGhpcy5zaXplLCAwXSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9yaWdpbmFsVGV4dHVyZSk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXG5cbiAgICAgICAgLy8gUmVuZGVyIHZlcnRpY2FsXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3JpZ2luYWxUZXh0dXJlLCAwKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocGFpbnRlci5nYXVzc2lhblNoYWRlci51X29mZnNldCwgWzAsIDEgLyB0aGlzLnNpemVdKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc2Vjb25kYXJ5VGV4dHVyZSk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZ2F1c3NpYW5TaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cblxuICAgIHRoaXMucGFpbnRlci5zYXZlVGV4dHVyZShzZWNvbmRhcnlUZXh0dXJlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbGlmeSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXCJjb21wb3NpdGVcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9wb3NtYXRyaXg7XFxudmFyeWluZyBoaWdocCB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgdmVjNCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHVfcG9zbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9zaXRpb24gPSB0bXB2YXJfMjtcXG4gIGEgPSAoKHRtcHZhcl8yLnh5IC8gMi4wKSArIDAuNSk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudmFyeWluZyB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAodGV4dHVyZTJEICh1X2ltYWdlLCBhKSAqIHVfb3BhY2l0eSk7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMTtcXG59XFxuXFxuXCJ9LFxuICAgIFwiZGVidWdcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIGZsb2F0IHVfcG9pbnRzaXplO1xcbnVuaWZvcm0gbWF0NCB1X3Bvc21hdHJpeDtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEudyA9IDEuMDtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICB0bXB2YXJfMS56ID0gZmxvYXQoKGFfcG9zLnggPj0gMzI3NjcuMCkpO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9wb3NtYXRyaXggKiB0bXB2YXJfMSk7XFxuICBnbF9Qb2ludFNpemUgPSB1X3BvaW50c2l6ZTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudm9pZCBtYWluICgpXFxue1xcbiAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcXG59XFxuXFxuXCJ9LFxuICAgIFwiZG90XCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfcG9zbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIGdsX1Bvc2l0aW9uID0gKHVfcG9zbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9pbnRTaXplID0gdV9zaXplO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG52b2lkIG1haW4gKClcXG57XFxuICBtZWRpdW1wIHZlYzIgeF8xO1xcbiAgeF8xID0gKGdsX1BvaW50Q29vcmQgLSAwLjUpO1xcbiAgbWVkaXVtcCBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gY2xhbXAgKCgoXFxuICAgIHNxcnQoZG90ICh4XzEsIHhfMSkpXFxuICAgLSAwLjUpIC8gKFxcbiAgICAoMC41IC0gdV9ibHVyKVxcbiAgIC0gMC41KSksIDAuMCwgMS4wKTtcXG4gIGdsX0ZyYWdDb2xvciA9ICh1X2NvbG9yICogKHRtcHZhcl8yICogKHRtcHZhcl8yICogXFxuICAgICgzLjAgLSAoMi4wICogdG1wdmFyXzIpKVxcbiAgKSkpO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJmaWxsXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudW5pZm9ybSBtYXQ0IHVfcG9zbWF0cml4O1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIGdsX1Bvc2l0aW9uID0gKHVfcG9zbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9pbnRTaXplID0gMi4wO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG52b2lkIG1haW4gKClcXG57XFxuICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJnYXVzc2lhblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnVuaWZvcm0gbWF0NCB1X3Bvc21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxudmFyeWluZyBoaWdocCB2ZWMyIGJbM107XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgdmVjNCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHVfcG9zbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9zaXRpb24gPSB0bXB2YXJfMjtcXG4gIGhpZ2hwIHZlYzIgdG1wdmFyXzM7XFxuICB0bXB2YXJfMyA9ICgodG1wdmFyXzIueHkgLyAyLjApICsgMC41KTtcXG4gIGJbMF0gPSB0bXB2YXJfMztcXG4gIHZlYzIgY3NlXzQ7XFxuICBjc2VfNCA9ICh1X29mZnNldCAqIDEuMTgyNDMpO1xcbiAgYlsxXSA9ICh0bXB2YXJfMyArIGNzZV80KTtcXG4gIGJbMl0gPSAodG1wdmFyXzMgLSBjc2VfNCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmFyeWluZyB2ZWMyIGJbM107XFxudm9pZCBtYWluICgpXFxue1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAoKCh0ZXh0dXJlMkQgKHVfaW1hZ2UsIGJbMF0pICogMC40MDI2MikgKyAodGV4dHVyZTJEICh1X2ltYWdlLCBiWzFdKSAqIDAuMjk4NjkpKSArICh0ZXh0dXJlMkQgKHVfaW1hZ2UsIGJbMl0pICogMC4yOTg2OSkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdG1wdmFyXzE7XFxufVxcblxcblwifSxcbiAgICBcImxpbmVcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX2V4dHJ1ZGU7XFxuYXR0cmlidXRlIGZsb2F0IGFfbGluZXNvZmFyO1xcbnVuaWZvcm0gbWF0NCB1X3Bvc21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWMyIGNfMTtcXG4gIHZlYzIgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh2ZWMyKG1vZCAoYV9wb3MsIDIuMCkpKTtcXG4gIGNfMS54ID0gdG1wdmFyXzIueDtcXG4gIGNfMS55ID0gc2lnbigodG1wdmFyXzIueSAtIDAuNSkpO1xcbiAgYSA9IGNfMTtcXG4gIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMy56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzMueHkgPSBmbG9vcigoYV9wb3MgLyAyLjApKTtcXG4gIHZlYzQgdG1wdmFyXzQ7XFxuICB0bXB2YXJfNC56dyA9IHZlYzIoMC4wLCAwLjApO1xcbiAgdG1wdmFyXzQueHkgPSAodV9saW5ld2lkdGgueCAqIChhX2V4dHJ1ZGUgLyA2My4wKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICgodV9wb3NtYXRyaXggKiB0bXB2YXJfMykgKyAodV9leG1hdHJpeCAqIHRtcHZhcl80KSk7XFxuICBiID0gKGFfbGluZXNvZmFyICogdV9yYXRpbyk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gZmxvYXQgdV9kZWJ1ZztcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWMyIHVfZGFzaGFycmF5O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKHNxcnQoZG90IChhLCBhKSkgKiB1X2xpbmV3aWR0aC54KTtcXG4gIGZsb2F0IHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAoZmxvYXQobW9kIChiLCAodV9kYXNoYXJyYXkueCArIHVfZGFzaGFycmF5LnkpKSkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gKHVfY29sb3IgKiAoY2xhbXAgKFxcbiAgICAobWluICgodG1wdmFyXzEgLSAodV9saW5ld2lkdGgueSAtIHVfYmx1cikpLCAodV9saW5ld2lkdGgueCAtIHRtcHZhcl8xKSkgLyB1X2JsdXIpXFxuICAsIDAuMCwgMS4wKSAqIG1heCAoXFxuICAgIGZsb2F0KCgtKHVfZGFzaGFycmF5LnkpID49IDAuMCkpXFxuICAsIFxcbiAgICBjbGFtcCAobWluICh0bXB2YXJfMiwgKHVfZGFzaGFycmF5LnggLSB0bXB2YXJfMikpLCAwLjAsIDEuMClcXG4gICkpKTtcXG4gIGlmICgodV9kZWJ1ZyA+IDAuMCkpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgfTtcXG59XFxuXFxuXCJ9LFxuICAgIFwibGluZXBhdHRlcm5cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX2V4dHJ1ZGU7XFxuYXR0cmlidXRlIGZsb2F0IGFfbGluZXNvZmFyO1xcbnVuaWZvcm0gbWF0NCB1X3Bvc21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcG9pbnQ7XFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWMyIGNfMTtcXG4gIHZlYzIgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh2ZWMyKG1vZCAoYV9wb3MsIDIuMCkpKTtcXG4gIGNfMS54ID0gdG1wdmFyXzIueDtcXG4gIGNfMS55ID0gc2lnbigodG1wdmFyXzIueSAtIDAuNSkpO1xcbiAgYSA9IGNfMTtcXG4gIHZlYzQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMy56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzMueHkgPSBmbG9vcigoYV9wb3MgLyAyLjApKTtcXG4gIHZlYzQgdG1wdmFyXzQ7XFxuICB0bXB2YXJfNC53ID0gMC4wO1xcbiAgdG1wdmFyXzQueHkgPSAoKHVfbGluZXdpZHRoLnggKiAoYV9leHRydWRlIC8gNjMuMCkpICogKDEuMCAtIHVfcG9pbnQpKTtcXG4gIHRtcHZhcl80LnogPSAoZmxvYXQoKGFfcG9zLnggPj0gMzI3NjcuMCkpICsgKHVfcG9pbnQgKiBmbG9hdChcXG4gICAgKGNfMS55ID49IDEuMClcXG4gICkpKTtcXG4gIGdsX1Bvc2l0aW9uID0gKCh1X3Bvc21hdHJpeCAqIHRtcHZhcl8zKSArICh1X2V4bWF0cml4ICogdG1wdmFyXzQpKTtcXG4gIGIgPSBhX2xpbmVzb2ZhcjtcXG4gIGdsX1BvaW50U2l6ZSA9ICgoMi4wICogdV9saW5ld2lkdGgueCkgLSAxLjApO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGZsb2F0IHVfcG9pbnQ7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGU7XFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgbG93cCB2ZWM0IGpfMTtcXG4gIG1lZGl1bXAgdmVjMiB4XzI7XFxuICB4XzIgPSAoKGdsX1BvaW50Q29vcmQgKiAyLjApIC0gMS4wKTtcXG4gIG1lZGl1bXAgZmxvYXQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMyA9ICgoKFxcbiAgICBzcXJ0KGRvdCAoYSwgYSkpXFxuICAgKiBcXG4gICAgKDEuMCAtIHVfcG9pbnQpXFxuICApICsgKHVfcG9pbnQgKiBcXG4gICAgc3FydChkb3QgKHhfMiwgeF8yKSlcXG4gICkpICogdV9saW5ld2lkdGgueCk7XFxuICBmbG9hdCB0bXB2YXJfNDtcXG4gIHRtcHZhcl80ID0gKGZsb2F0KG1vZCAoKGIgLyB1X3BhdHRlcm5fc2l6ZS54KSwgMS4wKSkpO1xcbiAgZmxvYXQgdG1wdmFyXzU7XFxuICB0bXB2YXJfNSA9ICgwLjUgKyAoKGEueSAqIHVfbGluZXdpZHRoLngpIC8gdV9wYXR0ZXJuX3NpemUueSkpO1xcbiAgdmVjMiB0bXB2YXJfNjtcXG4gIHRtcHZhcl82LnggPSB0bXB2YXJfNDtcXG4gIHRtcHZhcl82LnkgPSB0bXB2YXJfNTtcXG4gIHZlYzIgdG1wdmFyXzc7XFxuICB0bXB2YXJfNy54ID0gKGZsb2F0KG1vZCAoKHRtcHZhcl80ICogMi4wKSwgMS4wKSkpO1xcbiAgdG1wdmFyXzcueSA9IHRtcHZhcl81O1xcbiAgbG93cCB2ZWM0IHRtcHZhcl84O1xcbiAgdG1wdmFyXzggPSAoKHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGwsIHVfcGF0dGVybl9iciwgdG1wdmFyXzYpKSAqICgxLjAgLSB1X2ZhZGUpKSArICh1X2ZhZGUgKiB0ZXh0dXJlMkQgKHVfaW1hZ2UsIG1peCAodV9wYXR0ZXJuX3RsLCB1X3BhdHRlcm5fYnIsIHRtcHZhcl83KSkpKTtcXG4gIGpfMS53ID0gdG1wdmFyXzgudztcXG4gIGpfMS54eXogPSAodG1wdmFyXzgueHl6ICogdG1wdmFyXzgudyk7XFxuICBnbF9GcmFnQ29sb3IgPSAoal8xICogY2xhbXAgKChcXG4gICAgbWluICgodG1wdmFyXzMgLSAodV9saW5ld2lkdGgueSAtIHVfYmx1cikpLCAodV9saW5ld2lkdGgueCAtIHRtcHZhcl8zKSlcXG4gICAvIHVfYmx1ciksIDAuMCwgMS4wKSk7XFxufVxcblxcblwifSxcbiAgICBcIm91dGxpbmVcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9wb3NtYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfd29ybGQ7XFxudmFyeWluZyBoaWdocCB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgdmVjNCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHVfcG9zbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9zaXRpb24gPSB0bXB2YXJfMjtcXG4gIGEgPSAoKCh0bXB2YXJfMi54eSArIDEuMCkgLyAyLjApICogdV93b3JsZCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGhpZ2hwIHZlYzIgeF8xO1xcbiAgeF8xID0gKGEgLSBnbF9GcmFnQ29vcmQueHkpO1xcbiAgaGlnaHAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IGNsYW1wICgoKFxcbiAgICBzcXJ0KGRvdCAoeF8xLCB4XzEpKVxcbiAgIC0gMS4wKSAvIC0xLjApLCAwLjAsIDEuMCk7XFxuICBoaWdocCB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAodV9jb2xvciAqICh0bXB2YXJfMiAqICh0bXB2YXJfMiAqIFxcbiAgICAoMy4wIC0gKDIuMCAqIHRtcHZhcl8yKSlcXG4gICkpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8zO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJwYXR0ZXJuXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfcG9zbWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1X3BhdHRlcm5tYXRyaXg7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudmFyeWluZyB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9wb3NtYXRyaXggKiB0bXB2YXJfMSk7XFxuICB2ZWMzIHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIueiA9IDEuMDtcXG4gIHRtcHZhcl8yLnh5ID0gYV9wb3M7XFxuICBhID0gKHVfcGF0dGVybm1hdHJpeCAqIHRtcHZhcl8yKS54eTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWMyIHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAodmVjMihtb2QgKGEsIDEuMCkpKTtcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKG1peCAodGV4dHVyZTJEICh1X2ltYWdlLCBtaXggKHVfcGF0dGVybl90bCwgdV9wYXR0ZXJuX2JyLCB0bXB2YXJfMSkpLCB0ZXh0dXJlMkQgKHVfaW1hZ2UsIG1peCAodV9wYXR0ZXJuX3RsLCB1X3BhdHRlcm5fYnIsIFxcbiAgICAodmVjMihtb2QgKCh0bXB2YXJfMSAqIDIuMCksIDEuMCkpKVxcbiAgKSksIHVfbWl4KSAqIHVfb3BhY2l0eSk7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMjtcXG59XFxuXFxuXCJ9LFxuICAgIFwicmFzdGVyXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfcG9zbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIHZlYzIgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X3Bvc21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIHZlYzIgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICgoKFxcbiAgICAoYV90ZXh0dXJlX3BvcyAvIDMyNzY3LjApXFxuICAgLSAwLjUpIC8gdV9idWZmZXJfc2NhbGUpICsgMC41KTtcXG4gIGEgPSB0bXB2YXJfMjtcXG4gIGIgPSAoKHRtcHZhcl8yICogdV9zY2FsZV9wYXJlbnQpICsgdV90bF9wYXJlbnQpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTA7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHkxO1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2xvdztcXG51bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzc19oaWdoO1xcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3RfZmFjdG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2UwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2UxO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgdmVjMiBiO1xcbnVuaWZvcm0gdmVjMyB1X3NwaW5fd2VpZ2h0cztcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9ICgodGV4dHVyZTJEICh1X2ltYWdlMCwgYSkgKiB1X29wYWNpdHkwKSArICh0ZXh0dXJlMkQgKHVfaW1hZ2UxLCBiKSAqIHVfb3BhY2l0eTEpKTtcXG4gIGxvd3AgdmVjMyB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yLnggPSBkb3QgKHRtcHZhcl8xLnh5eiwgdV9zcGluX3dlaWdodHMpO1xcbiAgdG1wdmFyXzIueSA9IGRvdCAodG1wdmFyXzEueHl6LCB1X3NwaW5fd2VpZ2h0cy56eHkpO1xcbiAgdG1wdmFyXzIueiA9IGRvdCAodG1wdmFyXzEueHl6LCB1X3NwaW5fd2VpZ2h0cy55engpO1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMueHl6ID0gbWl4ICh2ZWMzKHVfYnJpZ2h0bmVzc19sb3cpLCB2ZWMzKHVfYnJpZ2h0bmVzc19oaWdoKSwgKChcXG4gICAgKCh0bXB2YXJfMiArICgoXFxuICAgICAgKCgodG1wdmFyXzEueCArIHRtcHZhcl8xLnkpICsgdG1wdmFyXzEueikgLyAzLjApXFxuICAgICAtIHRtcHZhcl8yKSAqIHVfc2F0dXJhdGlvbl9mYWN0b3IpKSAtIDAuNSlcXG4gICAqIHVfY29udHJhc3RfZmFjdG9yKSArIDAuNSkpO1xcbiAgdG1wdmFyXzMudyA9IHRtcHZhcl8xLnc7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMztcXG59XFxuXFxuXCJ9LFxuICAgIFwiaWNvblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2FuZ2xlO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX21pbnpvb207XFxuYXR0cmlidXRlIGZsb2F0IGFfbWF4em9vbTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYW5nZWVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYW5nZXN0YXJ0O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2xhYmVsbWluem9vbTtcXG51bmlmb3JtIG1hdDQgdV9wb3NtYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfZXhtYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X2FuZ2xlO1xcbnVuaWZvcm0gZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9mbGlwO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlZGlzdDtcXG51bmlmb3JtIGZsb2F0IHVfbWluZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X21heGZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIHZlYzIgdV90ZXhzaXplO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCBkXzE7XFxuICBkXzEgPSAwLjA7XFxuICBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKGZsb2F0KG1vZCAoKGFfYW5nbGUgKyB1X2FuZ2xlKSwgMjU2LjApKSk7XFxuICBpZiAoKCgodV9mbGlwID4gMC4wKSAmJiAodG1wdmFyXzIgPj0gNjQuMCkpICYmICh0bXB2YXJfMiA8IDE5Mi4wKSkpIHtcXG4gICAgZF8xID0gMS4wO1xcbiAgfTtcXG4gIGZsb2F0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAoKCgyLjAgLSBcXG4gICAgZmxvYXQoKHVfem9vbSA+PSBhX21pbnpvb20pKVxcbiAgKSAtICgxLjAgLSBcXG4gICAgZmxvYXQoKHVfem9vbSA+PSBhX21heHpvb20pKVxcbiAgKSkgKyBkXzEpO1xcbiAgZmxvYXQgdG1wdmFyXzQ7XFxuICB0bXB2YXJfNCA9IGNsYW1wICgoKHVfZmFkZXpvb20gLSBhX2xhYmVsbWluem9vbSkgLyB1X2ZhZGVkaXN0KSwgMC4wLCAxLjApO1xcbiAgaWYgKCh1X2ZhZGVkaXN0ID49IDAuMCkpIHtcXG4gICAgYiA9IHRtcHZhcl80O1xcbiAgfSBlbHNlIHtcXG4gICAgYiA9ICgxLjAgLSB0bXB2YXJfNCk7XFxuICB9O1xcbiAgaWYgKCh1X21heGZhZGV6b29tIDwgYV9sYWJlbG1pbnpvb20pKSB7XFxuICAgIGIgPSAwLjA7XFxuICB9O1xcbiAgaWYgKCh1X21pbmZhZGV6b29tID49IGFfbGFiZWxtaW56b29tKSkge1xcbiAgICBiID0gMS4wO1xcbiAgfTtcXG4gIHZlYzQgdG1wdmFyXzU7XFxuICB0bXB2YXJfNS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzUueHkgPSBhX3BvcztcXG4gIHZlYzQgdG1wdmFyXzY7XFxuICB0bXB2YXJfNi53ID0gMC4wO1xcbiAgdG1wdmFyXzYueHkgPSAoYV9vZmZzZXQgLyA2NC4wKTtcXG4gIHRtcHZhcl82LnogPSAoKHRtcHZhcl8zICsgZmxvYXQoXFxuICAgICgwLjAgPj0gYilcXG4gICkpICsgKGZsb2F0KFxcbiAgICAodV9hbmdsZSA+PSBhX3JhbmdlZW5kKVxcbiAgKSAqICgxLjAgLSBcXG4gICAgZmxvYXQoKHVfYW5nbGUgPj0gYV9yYW5nZXN0YXJ0KSlcXG4gICkpKTtcXG4gIGdsX1Bvc2l0aW9uID0gKCh1X3Bvc21hdHJpeCAqIHRtcHZhcl81KSArICh1X2V4bWF0cml4ICogdG1wdmFyXzYpKTtcXG4gIGEgPSAoYV90ZXggLyB1X3RleHNpemUpO1xcbiAgYiA9IChiICogdV9vcGFjaXR5KTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9ICh0ZXh0dXJlMkQgKHVfdGV4dHVyZSwgYSkgKiBiKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8xO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJzZGZcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9taW56b29tO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX21heHpvb207XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFuZ2VlbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFuZ2VzdGFydDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9sYWJlbG1pbnpvb207XFxudW5pZm9ybSBtYXQ0IHVfcG9zbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9hbmdsZTtcXG51bmlmb3JtIGZsb2F0IHVfem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmxpcDtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZWRpc3Q7XFxudW5pZm9ybSBmbG9hdCB1X21pbmZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXhmYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZXpvb207XFxudW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgZmxvYXQgZF8xO1xcbiAgZF8xID0gMC4wO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IChmbG9hdChtb2QgKChhX2FuZ2xlICsgdV9hbmdsZSksIDI1Ni4wKSkpO1xcbiAgaWYgKCgoKHVfZmxpcCA+IDAuMCkgJiYgKHRtcHZhcl8yID49IDY0LjApKSAmJiAodG1wdmFyXzIgPCAxOTIuMCkpKSB7XFxuICAgIGRfMSA9IDEuMDtcXG4gIH07XFxuICBmbG9hdCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gKCgoMi4wIC0gXFxuICAgIGZsb2F0KCh1X3pvb20gPj0gYV9taW56b29tKSlcXG4gICkgLSAoMS4wIC0gXFxuICAgIGZsb2F0KCh1X3pvb20gPj0gYV9tYXh6b29tKSlcXG4gICkpICsgZF8xKTtcXG4gIGZsb2F0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQgPSBjbGFtcCAoKCh1X2ZhZGV6b29tIC0gYV9sYWJlbG1pbnpvb20pIC8gdV9mYWRlZGlzdCksIDAuMCwgMS4wKTtcXG4gIGlmICgodV9mYWRlZGlzdCA+PSAwLjApKSB7XFxuICAgIGIgPSB0bXB2YXJfNDtcXG4gIH0gZWxzZSB7XFxuICAgIGIgPSAoMS4wIC0gdG1wdmFyXzQpO1xcbiAgfTtcXG4gIGlmICgodV9tYXhmYWRlem9vbSA8IGFfbGFiZWxtaW56b29tKSkge1xcbiAgICBiID0gMC4wO1xcbiAgfTtcXG4gIGlmICgodV9taW5mYWRlem9vbSA+PSBhX2xhYmVsbWluem9vbSkpIHtcXG4gICAgYiA9IDEuMDtcXG4gIH07XFxuICB2ZWM0IHRtcHZhcl81O1xcbiAgdG1wdmFyXzUuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl81Lnh5ID0gYV9wb3M7XFxuICB2ZWM0IHRtcHZhcl82O1xcbiAgdG1wdmFyXzYudyA9IDAuMDtcXG4gIHRtcHZhcl82Lnh5ID0gKGFfb2Zmc2V0IC8gNjQuMCk7XFxuICB0bXB2YXJfNi56ID0gKCh0bXB2YXJfMyArIGZsb2F0KFxcbiAgICAoMC4wID49IGIpXFxuICApKSArIChmbG9hdChcXG4gICAgKHVfYW5nbGUgPj0gYV9yYW5nZWVuZClcXG4gICkgKiAoMS4wIC0gXFxuICAgIGZsb2F0KCh1X2FuZ2xlID49IGFfcmFuZ2VzdGFydCkpXFxuICApKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICgodV9wb3NtYXRyaXggKiB0bXB2YXJfNSkgKyAodV9leG1hdHJpeCAqIHRtcHZhcl82KSk7XFxuICBhID0gKGFfdGV4IC8gdV90ZXhzaXplKTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXI7XFxudW5pZm9ybSBmbG9hdCB1X2dhbW1hO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCBlZGdlMF8xO1xcbiAgZWRnZTBfMSA9ICh1X2J1ZmZlciAtIHVfZ2FtbWEpO1xcbiAgbG93cCBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gY2xhbXAgKCgodGV4dHVyZTJEICh1X3RleHR1cmUsIGEpLncgLSBlZGdlMF8xKSAvIChcXG4gICAgKHVfYnVmZmVyICsgdV9nYW1tYSlcXG4gICAtIGVkZ2UwXzEpKSwgMC4wLCAxLjApO1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAodV9jb2xvciAqICgodG1wdmFyXzIgKiBcXG4gICAgKHRtcHZhcl8yICogKDMuMCAtICgyLjAgKiB0bXB2YXJfMikpKVxcbiAgKSAqIGIpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8zO1xcbn1cXG5cXG5cIn1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS5qcycpO1xudmFyIEdlb0pTT05UaWxlID0gcmVxdWlyZSgnLi9nZW9qc29udGlsZS5qcycpO1xuXG52YXIgR2VvSlNPTlNvdXJjZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICB0aGlzLmFsbHRpbGVzID0ge307XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuem9vbXMgPSBbMSwgNSwgOSwgMTNdO1xuICAgIHRoaXMubWluVGlsZVpvb20gPSB0aGlzLnpvb21zWzBdO1xuICAgIHRoaXMubWF4VGlsZVpvb20gPSB0aGlzLnpvb21zW3RoaXMuem9vbXMubGVuZ3RoIC0gMV07XG5cbiAgICB0aGlzLmxvYWROZXdUaWxlcyA9IHRydWU7XG4gICAgdGhpcy50aWxlSlNPTiA9IHtcbiAgICAgICAgbWluWm9vbTogMSxcbiAgICAgICAgbWF4Wm9vbTogMTNcbiAgICB9O1xuXG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xufTtcblxuR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZS5wcm90b3R5cGUpO1xuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgaWYgKHRoaXMubWFwKSB0aGlzLl91cGRhdGVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMucGFpbnRlciA9IG1hcC5wYWludGVyO1xuXG4gICAgaWYgKHRoaXMubWFwLnN0eWxlKSB0aGlzLl91cGRhdGVEYXRhKCk7XG4gICAgbWFwLm9uKCdzdHlsZS5jaGFuZ2UnLCB0aGlzLl91cGRhdGVEYXRhLmJpbmQodGhpcykpO1xufTtcblxuR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUuX3VwZGF0ZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICB0aGlzLndvcmtlcklEID0gdGhpcy5tYXAuZGlzcGF0Y2hlci5zZW5kKCdwYXJzZSBnZW9qc29uJywge1xuICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgIHpvb21zOiB0aGlzLnpvb21zLFxuICAgICAgICB0aWxlU2l6ZTogNTEyLFxuICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICB9LCBmdW5jdGlvbihlcnIsIHRpbGVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc291cmNlLmFsbHRpbGVzW3RpbGVzW2ldLmlkXSA9IG5ldyBHZW9KU09OVGlsZSh0aWxlc1tpXS5pZCwgc291cmNlLCB0aWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS5tYXApIHNvdXJjZS5tYXAudXBkYXRlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZS5fYWRkVGlsZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHRpbGUgPSB0aGlzLmFsbHRpbGVzW2lkXTtcbiAgICBpZiAodGlsZSkge1xuICAgICAgICB0aWxlLl9sb2FkKCk7XG4gICAgICAgIHRoaXMudGlsZXNbaWRdID0gdGlsZTtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmFkZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWxlIHx8IHt9O1xufTtcblxuR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUuX2NvdmVyaW5nWm9vbUxldmVsID0gZnVuY3Rpb24oem9vbSkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnpvb21zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLnpvb21zW2ldIDw9IHpvb20pIHtcbiAgICAgICAgICAgIHZhciB6ID0gdGhpcy56b29tc1tpXTtcbiAgICAgICAgICAgIHJldHVybiB6O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRpbGUgPSByZXF1aXJlKCcuL3RpbGUuanMnKTtcbnZhciBCdWZmZXJTZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlci9idWZmZXJzZXQuanMnKTtcbnZhciBjcmVhdGVCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2NyZWF0ZWJ1Y2tldC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb0pTT05UaWxlO1xuXG5mdW5jdGlvbiBHZW9KU09OVGlsZShpZCwgc291cmNlLCBkYXRhKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy53b3JrZXJJRCA9IHNvdXJjZS53b3JrZXJJRDtcbn1cblxuR2VvSlNPTlRpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUaWxlLnByb3RvdHlwZSk7XG5cbkdlb0pTT05UaWxlLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxvYWRlZCkgcmV0dXJuO1xuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuYnVmZmVycyA9IG5ldyBCdWZmZXJTZXQoZGF0YS5idWZmZXJzKTtcblxuICAgIHRoaXMuYnVja2V0cyA9IHt9O1xuICAgIGZvciAodmFyIGIgaW4gZGF0YS5lbGVtZW50R3JvdXBzKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c1tiXSA9IGNyZWF0ZUJ1Y2tldCh0aGlzLnNvdXJjZS5tYXAuc3R5bGUuYnVja2V0c1tiXSwgdGhpcy5idWZmZXJzLCB1bmRlZmluZWQsIGRhdGEuZWxlbWVudEdyb3Vwc1tiXSk7XG4gICAgfVxuXG5cbn07XG5cbi8vIG5vb3BzXG5HZW9KU09OVGlsZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHsgfTtcbkdlb0pTT05UaWxlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcmFwcGVyO1xuXG4vLyBjb25mb3JtIHRvIHZlY3RvcnRpbGUgYXBpXG5mdW5jdGlvbiBXcmFwcGVyKGZlYXR1cmVzKSB7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgIHRoaXMubGVuZ3RoID0gZmVhdHVyZXMubGVuZ3RoO1xufVxuXG5XcmFwcGVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgRmVhdHVyZVdyYXBwZXIodGhpcy5mZWF0dXJlc1tpXSk7XG59O1xuXG52YXIgbWFwcGluZyA9IHtcbiAgICAnUG9pbnQnOiAxLFxuICAgICdMaW5lU3RyaW5nJzogMixcbiAgICAnUG9seWdvbic6IDNcbn07XG5cbmZ1bmN0aW9uIEZlYXR1cmVXcmFwcGVyKGZlYXR1cmUpIHtcbiAgICB0aGlzLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIHRoaXMudHlwZSA9IG1hcHBpbmdbZmVhdHVyZS50eXBlXTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlLmNvb3Jkcztcbn07XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSBtYXBwaW5nLlBvaW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuY29vcmRzWzBdWzBdLngsXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuY29vcmRzWzBdWzBdLnksXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuY29vcmRzWzBdWzBdLngsXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuY29vcmRzWzBdWzBdLnlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgcmluZ3MgPSB0aGlzLmZlYXR1cmUuY29vcmRzO1xuXG4gICAgdmFyIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IHJpbmdbal07XG5cbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4oeDEsIGNvb3JkLngpO1xuICAgICAgICAgICAgeDIgPSBNYXRoLm1heCh4MiwgY29vcmQueCk7XG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHkxLCBjb29yZC55KTtcbiAgICAgICAgICAgIHkyID0gTWF0aC5tYXgoeTIsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZS5qcycpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXN0ZXJUaWxlO1xuXG5mdW5jdGlvbiBSYXN0ZXJUaWxlKGlkLCBzb3VyY2UsIHVybCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG4gICAgdGhpcy5fbG9hZCgpO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnVzZXMgPSAxO1xuXG4gICAgLy8gVG9kbyBmaW5pc2ggZmlndXJpbmcgb3V0IHdoYXQgcmFzdGVyIGJ1Y2tldHMgYXJlXG4gICAgdGhpcy5idWNrZXRzID0ge307XG4gICAgdGhpcy5pbmZvID0geyByYXN0ZXI6IHRydWUgfTtcbiAgICB2YXIgYnVja2V0cyA9IHRoaXMubWFwLnN0eWxlLmJ1Y2tldHM7XG4gICAgZm9yICh2YXIgYiBpbiBidWNrZXRzKSB7XG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2JdO1xuICAgICAgICB2YXIgc291cmNlaWQgPSBidWNrZXQgJiYgYnVja2V0LnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gc291cmNlaWQpIHtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0c1tiXSA9IHtcbiAgICAgICAgICAgICAgICBpbmZvOiBidWNrZXQucmVuZGVyLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdyYXN0ZXInLFxuICAgICAgICAgICAgICAgIHRpbGU6IHRoaXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cblJhc3RlclRpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUaWxlLnByb3RvdHlwZSk7XG5cblJhc3RlclRpbGUucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpbGUgPSB0aGlzO1xuICAgIGFqYXguZ2V0SW1hZ2UodGhpcy51cmwsIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgICAgIC8vIEBUT0RPIGhhbmRsZSBlcnJvcnMuXG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcbiAgICAgICAgdGlsZS5pbWcgPSBpbWc7XG4gICAgICAgIGlmICh0aWxlLm1hcCkgdGlsZS5vblRpbGVMb2FkKCk7XG4gICAgfSk7XG59O1xuXG5SYXN0ZXJUaWxlLnByb3RvdHlwZS5vblRpbGVMb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc3RhcnQgdGV4dHVyZSB1cGxvYWRcbiAgICB0aGlzLmJpbmQodGhpcy5tYXAucGFpbnRlci5nbCk7XG5cbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgdGhpcy5jYWxsYmFjaygpO1xufTtcblxuUmFzdGVyVGlsZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmltZykgdGhpcy5pbWcuc3JjID0gJyc7XG4gICAgZGVsZXRlIHRoaXMuaW1nO1xufTtcblxuUmFzdGVyVGlsZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGZpbmQgcmV1c2FibGUgdGV4dHVyZVxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLm1hcC5wYWludGVyLmdldFRleHR1cmUodGhpcy5pbWcud2lkdGgpO1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmltZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1nKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5zaXplID0gdGhpcy5pbWcud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5SYXN0ZXJUaWxlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlKSB0aGlzLm1hcC5wYWludGVyLnNhdmVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gICAgZGVsZXRlIHRoaXMubWFwO1xufTtcblxuUmFzdGVyVGlsZS5wcm90b3R5cGUuZmVhdHVyZXNBdCA9IGZ1bmN0aW9uKHBvcywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIC8vIG5vb3BcbiAgICBjYWxsYmFjayhudWxsLCBbXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxuICAgIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKSxcbiAgICB0aWxlSlNPTiA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLmpzJykudGlsZUpTT04sXG4gICAgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZC5qcycpLFxuICAgIENhY2hlID0gcmVxdWlyZSgnLi4vdXRpbC9tcnVjYWNoZS5qcycpLFxuICAgIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZWNvb3JkJyksXG4gICAgVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZScpLFxuICAgIFJhc3RlclRpbGUgPSByZXF1aXJlKCcuL3Jhc3RlcnRpbGUuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU291cmNlO1xuXG5Tb3VyY2UucHJvdG9jb2xzID0ge1xuICAgIFwibWFwYm94XCI6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgYWpheC5nZXRKU09OKHRpbGVKU09OKHVybC5zcGxpdCgnOi8vJylbMV0pLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBcImh0dHBzXCI6IGFqYXguZ2V0SlNPTixcbiAgICBcImh0dHBcIjogYWpheC5nZXRKU09OXG59O1xuXG5mdW5jdGlvbiBTb3VyY2Uob3B0aW9ucykge1xuICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZlY3RvcicgJiYgb3B0aW9ucy50aWxlU2l6ZSAmJiBvcHRpb25zLnRpbGVTaXplICE9PSA1MTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZWN0b3IgdGlsZSBzb3VyY2VzIG11c3QgaGF2ZSBhIHRpbGVTaXplIG9mIDUxMicpO1xuICAgIH1cbiAgICB0aGlzLlRpbGUgPSB0aGlzLnR5cGUgPT09ICd2ZWN0b3InID8gVmVjdG9yVGlsZSA6IFJhc3RlclRpbGU7XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5pbmhlcml0KHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZSh0aGlzLm9wdGlvbnMuY2FjaGVTaXplLCBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgbG9hZFRpbGVKU09OID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIGxvYWRUaWxlSlNPTiA9IFNvdXJjZS5wcm90b2NvbHNbb3B0aW9ucy51cmwuc3BsaXQoJzonKVswXV07XG4gICAgICAgIGlmICghbG9hZFRpbGVKU09OKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcHJvdG9jb2wgZm9yIHNvdXJjZSBVUkwgJyArIG9wdGlvbnMudXJsKTtcbiAgICB9XG5cbiAgICBsb2FkVGlsZUpTT04ob3B0aW9ucy51cmwsIGZ1bmN0aW9uKGVyciwgdGlsZUpTT04pIHtcbiAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuXG4gICAgICAgIGlmICghdGlsZUpTT04udGlsZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdGlsZXMgcHJvcGVydHknKTtcblxuICAgICAgICB0aGlzLnRpbGVKU09OID0gdXRpbC5leHRlbmQoeyBtaW56b29tOiAwLCBtYXh6b29tOiAyMiB9LCB0aWxlSlNPTik7XG4gICAgICAgIHRoaXMubG9hZE5ld1RpbGVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpcmUoJ3NvdXJjZS5hZGQnLCB7c291cmNlOiB0aGlzfSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX3VwZGF0ZVRpbGVzID0gdXRpbC50aHJvdHRsZSh0aGlzLl91cGRhdGVUaWxlcywgNTAsIHRoaXMpO1xufVxuXG5Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHRpbGVTaXplOiA1MTIsXG4gICAgICAgIGNhY2hlU2l6ZTogMjBcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5wYWludGVyID0gbWFwLnBhaW50ZXI7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZXNbdF0uX2xvYWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50aWxlc1t0XS5sb2FkZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl91cGRhdGVUaWxlcygpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgICAvLyBJdGVyYXRpdmVseSBwYWludCBldmVyeSB0aWxlLlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB2YXIgb3JkZXIgPSBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKTtcbiAgICAgICAgb3JkZXIuc29ydCh0aGlzLl96X29yZGVyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gb3JkZXJbaV07XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNbaWRdO1xuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGVkICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRpbGUodGlsZSwgaWQsIGxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgcG9pbnQgPSBQb2ludC5jb252ZXJ0KHBvaW50KTtcblxuICAgICAgICBpZiAocGFyYW1zLmxheWVyKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLm1hcC5zdHlsZSxcbiAgICAgICAgICAgICAgICBsYXllciA9IHN0eWxlLmdldExheWVyKHBhcmFtcy5sYXllcik7XG4gICAgICAgICAgICBwYXJhbXMuYnVja2V0ID0gc3R5bGUuYnVja2V0c1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yZGVyID0gT2JqZWN0LmtleXModGhpcy50aWxlcyk7XG4gICAgICAgIG9yZGVyLnNvcnQodGhpcy5fel9vcmRlcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW2lkXTtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aWxlLnBvc2l0aW9uQXQoaWQsIHBvaW50KTtcblxuICAgICAgICAgICAgaWYgKHBvcyAmJiBwb3MueCA+PSAwICYmIHBvcy54IDwgNDA5NiAmJiBwb3MueSA+PSAwICYmIHBvcy55IDwgNDA5Nikge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjbGljayBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0LiBUaGVyZSBpcyBvbmx5IGV2ZXIgb25lIHRpbGUgaW5cbiAgICAgICAgICAgICAgICAvLyBhIGxheWVyIHRoYXQgaGFzIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGUuZmVhdHVyZXNBdChwb3MsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIG1hcCBhbmQgc291cmNlIHRpbGVzaXplc1xuICAgIF9nZXRab29tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHpPZmZzZXQgPSBNYXRoLmxvZyh0aGlzLm1hcC50cmFuc2Zvcm0udGlsZVNpemUvdGhpcy5vcHRpb25zLnRpbGVTaXplKSAvIE1hdGguTE4yO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAudHJhbnNmb3JtLnpvb20gKyB6T2Zmc2V0O1xuICAgIH0sXG5cbiAgICBfY292ZXJpbmdab29tTGV2ZWw6IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgZm9yICh2YXIgeiA9IHRoaXMudGlsZUpTT04ubWF4em9vbTsgeiA+PSB0aGlzLnRpbGVKU09OLm1pbnpvb207IHotLSkge1xuICAgICAgICAgICAgaWYgKHogPD0gem9vbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHVuZGVyc2NhbGluZyBieSByb3VuZGluZyB0byB0aGUgbmVhcmVzdCB6b29tIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGlmICh6IDwgdGhpcy50aWxlSlNPTi5tYXh6b29tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6ICs9IE1hdGgucm91bmQoem9vbSAtIHopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBfY2hpbGRab29tTGV2ZWw6IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgem9vbSA9IE1hdGgubWF4KHRoaXMudGlsZUpTT04ubWluem9vbSwgem9vbSArIDEpO1xuICAgICAgICByZXR1cm4gem9vbSA8PSB0aGlzLnRpbGVKU09OLm1heHpvb20gPyB6b29tIDogbnVsbDtcbiAgICB9LFxuXG4gICAgX2dldENvdmVyaW5nVGlsZXM6IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkgem9vbSA9IHRoaXMuX2dldFpvb20oKTtcbiAgICAgICAgdmFyIHogPSB0aGlzLl9jb3ZlcmluZ1pvb21MZXZlbCh6b29tKSxcbiAgICAgICAgICAgIHRpbGVzID0gMSA8PCB6LFxuICAgICAgICAgICAgdHIgPSB0aGlzLm1hcC50cmFuc2Zvcm0sXG4gICAgICAgICAgICB0aWxlQ2VudGVyID0gVGlsZUNvb3JkLnpvb21Ubyh0ci5sb2NhdGlvbkNvb3JkaW5hdGUodHIuY2VudGVyKSwgeik7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgIFRpbGVDb29yZC56b29tVG8odHIucG9pbnRDb29yZGluYXRlKHRpbGVDZW50ZXIsIHt4OiAwLCB5OiAwfSksIHopLFxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUodGlsZUNlbnRlciwge3g6IHRyLndpZHRoLCB5OiAwfSksIHopLFxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUodGlsZUNlbnRlciwge3g6IHRyLndpZHRoLCB5OiB0ci5oZWlnaHR9KSwgeiksXG4gICAgICAgICAgICBUaWxlQ29vcmQuem9vbVRvKHRyLnBvaW50Q29vcmRpbmF0ZSh0aWxlQ2VudGVyLCB7eDogMCwgeTogdHIuaGVpZ2h0fSksIHopXG4gICAgICAgIF0sIHQgPSB7fTtcblxuICAgICAgICAvLyBEaXZpZGUgdGhlIHNjcmVlbiB1cCBpbiB0d28gdHJpYW5nbGVzIGFuZCBzY2FuIGVhY2ggb2YgdGhlbTpcbiAgICAgICAgLy8gKy0tLS9cbiAgICAgICAgLy8gfCAvIHxcbiAgICAgICAgLy8gLy0tLStcbiAgICAgICAgdGhpcy5fc2NhblRyaWFuZ2xlKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG4gICAgICAgIHRoaXMuX3NjYW5UcmlhbmdsZShwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzBdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0KS5zb3J0KGZyb21DZW50ZXIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZyb21DZW50ZXIoYSwgYikge1xuICAgICAgICAgICAgdmFyIGFkID0gTWF0aC5hYnMoYS54IC0gdGlsZUNlbnRlci5jb2x1bW4pICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYS55IC0gdGlsZUNlbnRlci5yb3cpLFxuICAgICAgICAgICAgICAgIGJkID0gTWF0aC5hYnMoYi54IC0gdGlsZUNlbnRlci5jb2x1bW4pICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYi55IC0gdGlsZUNlbnRlci5yb3cpO1xuXG4gICAgICAgICAgICByZXR1cm4gYWQgLSBiZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNjYW5MaW5lKHgwLCB4MSwgeSkge1xuICAgICAgICAgICAgdmFyIHgsIHd4O1xuICAgICAgICAgICAgaWYgKHkgPj0gMCAmJiB5IDw9IHRpbGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHd4ID0gKHggKyB0aWxlcykgJSB0aWxlcztcbiAgICAgICAgICAgICAgICAgICAgdFtUaWxlQ29vcmQudG9JRCh6LCB3eCwgeSwgTWF0aC5mbG9vcih4L3RpbGVzKSldID0ge3g6IHd4LCB5OiB5fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSB0aWxlIG9mIGRhdGEsIGl0cyBpZCwgYW5kIGEgc3R5bGUgbGF5ZXJzLCByZW5kZXIgdGhlIHRpbGUgdG8gdGhlIGNhbnZhc1xuICAgIF9yZW5kZXJUaWxlOiBmdW5jdGlvbih0aWxlLCBpZCwgbGF5ZXJzKSB7XG4gICAgICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICAgICAgdmFyIHogPSBwb3MueiwgeCA9IHBvcy54LCB5ID0gcG9zLnksIHcgPSBwb3MudztcbiAgICAgICAgeCArPSB3ICogKDEgPDwgeik7XG5cbiAgICAgICAgdGlsZS5jYWxjdWxhdGVNYXRyaWNlcyh6LCB4LCB5LCB0aGlzLm1hcC50cmFuc2Zvcm0sIHRoaXMucGFpbnRlcik7XG5cbiAgICAgICAgdGhpcy5wYWludGVyLmRyYXcodGlsZSwgdGhpcy5tYXAuc3R5bGUsIGxheWVycywge1xuICAgICAgICAgICAgejogeiwgeDogeCwgeTogeSxcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLm1hcC5kZWJ1ZyxcbiAgICAgICAgICAgIGFudGlhbGlhc2luZzogdGhpcy5tYXAuYW50aWFsaWFzaW5nLFxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMubWFwLnZlcnRpY2VzLFxuICAgICAgICAgICAgcm90YXRpbmc6IHRoaXMubWFwLnJvdGF0aW5nLFxuICAgICAgICAgICAgem9vbWluZzogdGhpcy5tYXAuem9vbWluZ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVjdXJzaXZlbHkgZmluZCBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWF4Q292ZXJpbmdab29tKSB0aGF0IGFyZSBhbHJlYWR5IGxvYWRlZDtcbiAgICAvLyBhZGRzIGZvdW5kIHRpbGVzIHRvIHJldGFpbiBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiBjaGlsZHJlbiBjb21wbGV0ZWx5IGNvdmVyIHRoZSB0aWxlXG5cbiAgICBfZmluZExvYWRlZENoaWxkcmVuOiBmdW5jdGlvbihpZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHogPSBUaWxlQ29vcmQuZnJvbUlEKGlkKS56O1xuICAgICAgICB2YXIgaWRzID0gVGlsZUNvb3JkLmNoaWxkcmVuKGlkKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbGVzW2lkc1tpXV0gJiYgdGhpcy50aWxlc1tpZHNbaV1dLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldGFpbltpZHNbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeiA8IG1heENvdmVyaW5nWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHbyBmdXJ0aGVyIGRvd24gdGhlIGhpZXJhcmNoeSB0byBmaW5kIG1vcmUgdW5sb2FkZWQgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRMb2FkZWRDaGlsZHJlbihpZHNbaV0sIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGEgbG9hZGVkIHBhcmVudCBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWluQ292ZXJpbmdab29tKTtcbiAgICAvLyBhZGRzIHRoZSBmb3VuZCB0aWxlIHRvIHJldGFpbiBvYmplY3QgYW5kIHJldHVybnMgdHJ1ZSBpZiBhIHBhcmVudCB3YXMgZm91bmRcblxuICAgIF9maW5kTG9hZGVkUGFyZW50OiBmdW5jdGlvbihpZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgZm9yICh2YXIgeiA9IFRpbGVDb29yZC5mcm9tSUQoaWQpLno7IHogPj0gbWluQ292ZXJpbmdab29tOyB6LS0pIHtcbiAgICAgICAgICAgIGlkID0gVGlsZUNvb3JkLnBhcmVudChpZCk7XG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1tpZF0gJiYgdGhpcy50aWxlc1tpZF0ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmVzIHRpbGVzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHZpZXdwb3J0IGFuZCBhZGRzIG5ldyB0aWxlcyB0aGF0IGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgIF91cGRhdGVUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXAgfHwgIXRoaXMubWFwLmxvYWROZXdUaWxlcyB8fCAhdGhpcy5sb2FkTmV3VGlsZXMgfHwgIXRoaXMubWFwLnNvdXJjZXNbdGhpcy5pZF0pIHJldHVybjtcblxuICAgICAgICB2YXIgem9vbSA9IE1hdGguZmxvb3IodGhpcy5fZ2V0Wm9vbSgpKTtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gdGhpcy5fZ2V0Q292ZXJpbmdUaWxlcygpLnNvcnQodGhpcy5fY2VudGVyT3V0LmJpbmQodGhpcykpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgY29tcGxldGU7XG4gICAgICAgIHZhciB0aWxlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgb3Zlcnpvb21pbmcvdW5kZXJ6b29taW5nIGFtb3VudHMuXG4gICAgICAgIHZhciBtaW5Db3ZlcmluZ1pvb20gPSBNYXRoLm1heCh0aGlzLnRpbGVKU09OLm1pbnpvb20sIHpvb20gLSAxMCk7XG4gICAgICAgIHZhciBtYXhDb3ZlcmluZ1pvb20gPSB0aGlzLnRpbGVKU09OLm1pbnpvb207XG4gICAgICAgIHdoaWxlIChtYXhDb3ZlcmluZ1pvb20gPCB6b29tICsgMSkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fY2hpbGRab29tTGV2ZWwobWF4Q292ZXJpbmdab29tKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgICAgICBlbHNlIG1heENvdmVyaW5nWm9vbSA9IGxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0YWluIGlzIGEgbGlzdCBvZiB0aWxlcyB0aGF0IHdlIHNob3VsZG4ndCBkZWxldGUsIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHRoZSBtb3N0IGlkZWFsIHRpbGUgZm9yIHRoZSBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIG1heSBpbmNsdWRlIHRpbGVzIGxpa2VcbiAgICAgICAgLy8gcGFyZW50IG9yIGNoaWxkIHRpbGVzIHRoYXQgYXJlICphbHJlYWR5KiBsb2FkZWQuXG4gICAgICAgIHZhciByZXRhaW4gPSB7fTtcbiAgICAgICAgLy8gQ292ZXJlZCBpcyBhIGxpc3Qgb2YgcmV0YWluZWQgdGlsZXMgd2hvJ3MgYXJlYXMgYXJlIGZ1bGwgY292ZXJlZCBieSBvdGhlcixcbiAgICAgICAgLy8gYmV0dGVyLCByZXRhaW5lZCB0aWxlcy4gVGhleSBhcmUgbm90IGRyYXduIHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuY292ZXJlZFRpbGVzID0ge307XG5cbiAgICAgICAgdmFyIGZ1bGx5Q29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCBleGlzdGluZyBjaGlsZC9wYXJlbnQgdGlsZXMgaWYgdGhlIGFjdHVhbCB0aWxlIGlzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWQgPSArcmVxdWlyZWRbaV07XG4gICAgICAgICAgICByZXRhaW5baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl9hZGRUaWxlKGlkKTtcblxuICAgICAgICAgICAgaWYgKCF0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0aWxlIHdlIHJlcXVpcmUgaXMgbm90IHlldCBsb2FkZWQuIFRyeSB0byBmaW5kIGEgcGFyZW50IG9yXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgdGlsZSB0aGF0IHdlIGFscmVhZHkgaGF2ZS5cblxuICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gZmluZCBleGlzdGluZyBjaGlsZCB0aWxlcyB0aGF0IGNvbXBsZXRlbHkgY292ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gbWlzc2luZyB0aWxlLlxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gdGhpcy5fZmluZExvYWRlZENoaWxkcmVuKGlkLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbik7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuLCBpZiB0aGVyZSBhcmUgbm8gY29tcGxldGUgY2hpbGQgdGlsZXMsIHRyeSB0byBmaW5kIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IHRpbGVzIHRoYXQgY29tcGxldGVseSBjb3ZlciB0aGUgbWlzc2luZyB0aWxlLlxuICAgICAgICAgICAgICAgIGlmICghY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSB0aGlzLl9maW5kTG9hZGVkUGFyZW50KGlkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVubG9hZGVkIHRpbGUncyBhcmVhIGlzIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgbG9hZGVkIHRpbGVzXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmdWxseUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgZmFkZUR1cmF0aW9uID0gdGhpcy50eXBlID09PSAncmFzdGVyJyA/IHRoaXMubWFwLnN0eWxlLnJhc3RlckZhZGVEdXJhdGlvbiA6IDA7XG5cbiAgICAgICAgZm9yIChpZCBpbiByZXRhaW4pIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUudGltZUFkZGVkID4gbm93IC0gZmFkZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0aWxlIGlzIHN0aWxsIGZhZGluZyBpbi4gRmluZCB0aWxlcyB0byBjcm9zcy1mYWRlIHdpdGggaXQuXG5cbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHRoaXMuX2ZpbmRMb2FkZWRDaGlsZHJlbihpZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY292ZXJlZFRpbGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluZExvYWRlZFBhcmVudChpZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaWQgaW4gdGhpcy5jb3ZlcmVkVGlsZXMpIHJldGFpbltpZF0gPSB0cnVlO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdGlsZXMgd2UgZG9uJ3QgbmVlZCBhbnltb3JlLlxuICAgICAgICB2YXIgcmVtb3ZlID0gdXRpbC5rZXlzRGlmZmVyZW5jZSh0aGlzLnRpbGVzLCByZXRhaW4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZCA9ICtyZW1vdmVbaV07XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbG9hZFRpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXM7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCxcbiAgICAgICAgICAgIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQoaWQpLFxuICAgICAgICAgICAgdGlsZTtcblxuICAgICAgICBpZiAocG9zLncgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUudGltZSgnbG9hZGluZyAnICsgcG9zLnogKyAnLycgKyBwb3MueCArICcvJyArIHBvcy55KTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBUaWxlQ29vcmQudXJsKGlkLCB0aGlzLnRpbGVKU09OLnRpbGVzKTtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSA9IG5ldyB0aGlzLlRpbGUoaWQsIHRoaXMsIHVybCwgdGlsZUNvbXBsZXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gVGlsZUNvb3JkLnRvSUQocG9zLnosIHBvcy54LCBwb3MueSwgMCk7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0gPSB0aGlzLnRpbGVzW3dyYXBwZWRdIHx8IHRoaXMuX2FkZFRpbGUod3JhcHBlZCk7XG4gICAgICAgICAgICB0aWxlLnVzZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRpbGVDb21wbGV0ZShlcnIpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUudGltZUVuZCgnbG9hZGluZyAnICsgcG9zLnogKyAnLycgKyBwb3MueCArICcvJyArIHBvcy55KTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZhaWxlZCB0byBsb2FkIHRpbGUgJWQvJWQvJWQ6ICVzJywgcG9zLnosIHBvcy54LCBwb3MueSwgZXJyLnN0YWNrIHx8IGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgICAgICAgICAgbWFwLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfSxcblxuICAgIC8vIEFkZHMgYSB2ZWN0b3IgdGlsZSB0byB0aGUgbWFwLiBJdCB3aWxsIHRyaWdnZXIgYSByZXJlbmRlciBvZiB0aGUgbWFwIGFuZCB3aWxsXG4gICAgLy8gYmUgcGFydCBpbiBhbGwgZnV0dXJlIHJlbmRlcnMgb2YgdGhlIG1hcC4gVGhlIG1hcCBvYmplY3Qgd2lsbCBoYW5kbGUgY29weWluZ1xuICAgIC8vIHRoZSB0aWxlIGRhdGEgdG8gdGhlIEdQVSBpZiBpdCBpcyByZXF1aXJlZCB0byBwYWludCB0aGUgY3VycmVudCB2aWV3cG9ydC5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW2lkXTtcblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmNhY2hlLmdldChpZCk7XG4gICAgICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgICAgIHRpbGUudXNlcyA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlc1tpZF0gPSB0aWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fbG9hZFRpbGUoaWQpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmFkZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCAmJiAhdGlsZS50aW1lQWRkZWQpIHtcbiAgICAgICAgICAgIHRpbGUudGltZUFkZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAncmFzdGVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLmFuaW1hdGlvbkxvb3Auc2V0KHRoaXMubWFwLnN0eWxlLnJhc3RlckZhZGVEdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1tpZF07XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aWxlLnVzZXMtLTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzW2lkXTtcblxuICAgICAgICAgICAgaWYgKHRpbGUudXNlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRpbGUudGltZUFkZGVkO1xuICAgICAgICAgICAgICAgIGlmICghdGlsZS5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuYWRkKGlkLCB0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUucmVtb3ZlJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUYWtlbiBmcm9tIHBvbHltYXBzIHNyYy9MYXllci5qc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1wbGVnZW8vcG9seW1hcHMvYmxvYi9tYXN0ZXIvc3JjL0xheWVyLmpzI0wzMzMtTDM4M1xuXG4gICAgLy8gc2Nhbi1saW5lIGNvbnZlcnNpb25cbiAgICBfc2NhblRyaWFuZ2xlOiBmdW5jdGlvbihhLCBiLCBjLCB5bWluLCB5bWF4LCBzY2FuTGluZSkge1xuICAgICAgICB2YXIgYWIgPSB0aGlzLl9lZGdlKGEsIGIpLFxuICAgICAgICAgICAgYmMgPSB0aGlzLl9lZGdlKGIsIGMpLFxuICAgICAgICAgICAgY2EgPSB0aGlzLl9lZGdlKGMsIGEpO1xuXG4gICAgICAgIHZhciB0O1xuXG4gICAgICAgIC8vIHNvcnQgZWRnZXMgYnkgeS1sZW5ndGhcbiAgICAgICAgaWYgKGFiLmR5ID4gYmMuZHkpIHsgdCA9IGFiOyBhYiA9IGJjOyBiYyA9IHQ7IH1cbiAgICAgICAgaWYgKGFiLmR5ID4gY2EuZHkpIHsgdCA9IGFiOyBhYiA9IGNhOyBjYSA9IHQ7IH1cbiAgICAgICAgaWYgKGJjLmR5ID4gY2EuZHkpIHsgdCA9IGJjOyBiYyA9IGNhOyBjYSA9IHQ7IH1cblxuICAgICAgICAvLyBzY2FuIHNwYW4hIHNjYW4gc3BhbiFcbiAgICAgICAgaWYgKGFiLmR5KSB0aGlzLl9zY2FuU3BhbnMoY2EsIGFiLCB5bWluLCB5bWF4LCBzY2FuTGluZSk7XG4gICAgICAgIGlmIChiYy5keSkgdGhpcy5fc2NhblNwYW5zKGNhLCBiYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xuICAgIH0sXG5cbiAgICAvLyBzY2FuLWxpbmUgY29udmVyc2lvblxuICAgIF9lZGdlOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhLnJvdyA+IGIucm93KSB7IHZhciB0ID0gYTsgYSA9IGI7IGIgPSB0OyB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MDogYS5jb2x1bW4sXG4gICAgICAgICAgICB5MDogYS5yb3csXG4gICAgICAgICAgICB4MTogYi5jb2x1bW4sXG4gICAgICAgICAgICB5MTogYi5yb3csXG4gICAgICAgICAgICBkeDogYi5jb2x1bW4gLSBhLmNvbHVtbixcbiAgICAgICAgICAgIGR5OiBiLnJvdyAtIGEucm93XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIHNjYW4tbGluZSBjb252ZXJzaW9uXG4gICAgX3NjYW5TcGFuczogZnVuY3Rpb24oZTAsIGUxLCB5bWluLCB5bWF4LCBzY2FuTGluZSkge1xuICAgICAgICB2YXIgeTAgPSBNYXRoLm1heCh5bWluLCBNYXRoLmZsb29yKGUxLnkwKSksXG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHltYXgsIE1hdGguY2VpbChlMS55MSkpO1xuXG4gICAgICAgIC8vIHNvcnQgZWRnZXMgYnkgeC1jb29yZGluYXRlXG4gICAgICAgIGlmICgoZTAueDAgPT0gZTEueDAgJiYgZTAueTAgPT0gZTEueTApID9cbiAgICAgICAgICAgIChlMC54MCArIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngxKSA6XG4gICAgICAgICAgICAoZTAueDEgLSBlMS5keSAvIGUwLmR5ICogZTAuZHggPCBlMS54MCkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZTA7IGUwID0gZTE7IGUxID0gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYW4gbGluZXMhXG4gICAgICAgIHZhciBtMCA9IGUwLmR4IC8gZTAuZHksXG4gICAgICAgICAgICBtMSA9IGUxLmR4IC8gZTEuZHksXG4gICAgICAgICAgICBkMCA9IGUwLmR4ID4gMCwgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDBcbiAgICAgICAgICAgIGQxID0gZTEuZHggPCAwOyAvLyB1c2UgeSArIDEgdG8gY29tcHV0ZSB4MVxuICAgICAgICBmb3IgKHZhciB5ID0geTA7IHkgPCB5MTsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgeDAgPSBtMCAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUwLmR5LCB5ICsgZDAgLSBlMC55MCkpICsgZTAueDAsXG4gICAgICAgICAgICAgICAgeDEgPSBtMSAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUxLmR5LCB5ICsgZDEgLSBlMS55MCkpICsgZTEueDA7XG4gICAgICAgICAgICBzY2FuTGluZShNYXRoLmZsb29yKHgxKSwgTWF0aC5jZWlsKHgwKSwgeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3pfb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChiICUgMzIpIC0gKGEgJSAzMik7XG4gICAgfSxcblxuICAgIF9jZW50ZXJPdXQ6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgdmFyIHRyID0gdGhpcy5tYXAudHJhbnNmb3JtO1xuICAgICAgICB2YXIgYVBvcyA9IFRpbGVDb29yZC5mcm9tSUQoYSk7XG4gICAgICAgIHZhciBiUG9zID0gVGlsZUNvb3JkLmZyb21JRChiKTtcbiAgICAgICAgdmFyIGMgPSBUaWxlQ29vcmQuem9vbVRvKHRyLmxvY2F0aW9uQ29vcmRpbmF0ZSh0ci5jZW50ZXIpLCBhUG9zLnopO1xuICAgICAgICB2YXIgY2VudGVyID0gbmV3IFBvaW50KGMuY29sdW1uIC0gMC41LCBjLnJvdyAtIDAuNSk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuZGlzdChhUG9zKSAtIGNlbnRlci5kaXN0KGJQb3MpO1xuICAgIH0sXG59KTtcblxudmFyIHNvdXJjZXMgPSB7XG4gICAgdmVjdG9yOiBTb3VyY2UsXG4gICAgcmFzdGVyOiBTb3VyY2UsXG4gICAgZ2VvanNvbjogcmVxdWlyZSgnLi9nZW9qc29uc291cmNlJyksXG4gICAgdmlkZW86IHJlcXVpcmUoJy4vdmlkZW9zb3VyY2UnKVxufTtcblxuU291cmNlLmNyZWF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgc291cmNlc1tzb3VyY2UudHlwZV0oc291cmNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG1hdHJpeCA9IHJlcXVpcmUoJy4uL2xpYi9nbG1hdHJpeC5qcycpLFxuICAgIG1hdDIgPSBnbG1hdHJpeC5tYXQyLFxuICAgIG1hdDQgPSBnbG1hdHJpeC5tYXQ0LFxuICAgIHZlYzIgPSBnbG1hdHJpeC52ZWMyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGU7XG5cbmZ1bmN0aW9uIFRpbGUoKSB7fVxuXG5UaWxlLnByb3RvdHlwZSA9IHtcbiAgICAvLyB0b2RvIHVuaGFyZGNvZGVcbiAgICB0aWxlRXh0ZW50OiA0MDk2LFxuXG4gICAgY2FsY3VsYXRlTWF0cmljZXM6IGZ1bmN0aW9uKHosIHgsIHksIHRyYW5zZm9ybSwgcGFpbnRlcikge1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgbW9kZWwtdmlldyBtYXRyaXggdGhhdCBjb252ZXJ0cyBmcm9tIHRoZSB0aWxlIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIHRvIHNjcmVlbiBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIHRpbGVTY2FsZSA9IE1hdGgucG93KDIsIHopO1xuICAgICAgICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0ud29ybGRTaXplIC8gdGlsZVNjYWxlO1xuXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIG1hdHJpeFxuICAgICAgICB0aGlzLnBvc01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCwgW3RyYW5zZm9ybS5jZW50ZXJQb2ludC54LCB0cmFuc2Zvcm0uY2VudGVyUG9pbnQueSwgMF0pO1xuICAgICAgICBtYXQ0LnJvdGF0ZVoodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCB0cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgsIFstdHJhbnNmb3JtLmNlbnRlclBvaW50LngsIC10cmFuc2Zvcm0uY2VudGVyUG9pbnQueSwgMF0pO1xuXG4gICAgICAgIHZhciBwaXhlbFggPSB0cmFuc2Zvcm0ud2lkdGggLyAyIC0gdHJhbnNmb3JtLngsXG4gICAgICAgICAgICBwaXhlbFkgPSB0cmFuc2Zvcm0uaGVpZ2h0IC8gMiAtIHRyYW5zZm9ybS55O1xuXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCwgW3BpeGVsWCArIHggKiBzY2FsZSwgcGl4ZWxZICsgeSAqIHNjYWxlLCAxXSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGludmVydGVkIG1hdHJpeCBmb3IgaW50ZXJhY3Rpb25cbiAgICAgICAgdGhpcy5pbnZQb3NNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0LmludmVydCh0aGlzLmludlBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgpO1xuXG4gICAgICAgIG1hdDQuc2NhbGUodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCBbIHNjYWxlIC8gdGhpcy50aWxlRXh0ZW50LCBzY2FsZSAvIHRoaXMudGlsZUV4dGVudCwgMSBdKTtcbiAgICAgICAgbWF0NC5tdWx0aXBseSh0aGlzLnBvc01hdHJpeCwgcGFpbnRlci5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnBvc01hdHJpeCk7XG5cbiAgICAgICAgLy8gVGhlIGV4dHJ1c2lvbiBtYXRyaXguXG4gICAgICAgIHRoaXMuZXhNYXRyaXggPSBtYXQ0LmNsb25lKHBhaW50ZXIucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgIG1hdDQucm90YXRlWih0aGlzLmV4TWF0cml4LCB0aGlzLmV4TWF0cml4LCB0cmFuc2Zvcm0uYW5nbGUpO1xuXG4gICAgICAgIC8vIDJ4MiBtYXRyaXggZm9yIHJvdGF0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICAgICAgbWF0Mi5yb3RhdGUodGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5yb3RhdGlvbk1hdHJpeCwgdHJhbnNmb3JtLmFuZ2xlKTtcbiAgICB9LFxuXG4gICAgcG9zaXRpb25BdDogZnVuY3Rpb24oaWQsIHBvaW50KSB7XG4gICAgICAgIC8vIHRpbGUgaGFzbid0IGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgICAgaWYgKCF0aGlzLmludlBvc01hdHJpeCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHBvcyA9IHZlYzIudHJhbnNmb3JtTWF0NChbXSwgW3BvaW50LngsIHBvaW50LnldLCB0aGlzLmludlBvc01hdHJpeCk7XG4gICAgICAgIHZlYzIuc2NhbGUocG9zLCBwb3MsIDQwOTYgLyB0aGlzLnNjYWxlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXSxcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvcywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNvdXJjZS5tYXAuZGlzcGF0Y2hlci5zZW5kKCdxdWVyeSBmZWF0dXJlcycsIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueSxcbiAgICAgICAgICAgIHNjYWxlOiBwb3Muc2NhbGUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLmlkLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSwgY2FsbGJhY2ssIHRoaXMud29ya2VySUQpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBUaWxlcyBhcmUgZ2VuZXJhbGx5IHJlcHJlc2VudGVkIGFzIHBhY2tlZCBpbnRlZ2VyIGlkcyBjb25zdHJ1Y3RlZCBieVxuICogYFRpbGVDb29yZC50b0lEKHgsIHksIHopYFxuICovXG5cbnZhciBUaWxlQ29vcmQgPSBleHBvcnRzO1xuXG5UaWxlQ29vcmQudG9JRCA9IGZ1bmN0aW9uKHosIHgsIHksIHcpIHtcbiAgICB3ID0gdyB8fCAwO1xuICAgIHcgKj0gMjtcbiAgICBpZiAodyA8IDApIHcgPSB3ICogLTEgLTE7XG4gICAgdmFyIGRpbSA9IDEgPDwgejtcbiAgICByZXR1cm4gKChkaW0gKiBkaW0gKiB3ICsgZGltICogeSArIHgpICogMzIpICsgejtcbn07XG5cblRpbGVDb29yZC5hc1N0cmluZyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuICAgIHJldHVybiBwb3MueiArIFwiL1wiICsgcG9zLnggKyBcIi9cIiArIHBvcy55O1xufTtcblxuLypcbiAqIFBhcnNlIGEgcGFja2VkIGludGVnZXIgaWQgaW50byBhbiBvYmplY3Qgd2l0aCB4LCB5LCBhbmQgeiBwcm9wZXJ0aWVzXG4gKi9cblRpbGVDb29yZC5mcm9tSUQgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciB6ID0gaWQgJSAzMiwgZGltID0gMSA8PCB6O1xuICAgIHZhciB4eSA9ICgoaWQgLSB6KSAvIDMyKTtcbiAgICB2YXIgeCA9IHh5ICUgZGltLCB5ID0gKCh4eSAtIHgpIC8gZGltKSAlIGRpbTtcbiAgICB2YXIgdyA9IE1hdGguZmxvb3IoeHkgLyAoZGltICogZGltKSk7XG4gICAgaWYgKHcgJSAyICE9PSAwKSB3ID0gdyAqIC0xIC0xO1xuICAgIHcgLz0gMjtcbiAgICByZXR1cm4geyB6OiB6LCB4OiB4LCB5OiB5LCB3OiB3IH07XG59O1xuXG4vKlxuICogR2l2ZW4gYSBwYWNrZWQgaW50ZWdlciBpZCwgcmV0dXJuIGl0cyB6b29tIGxldmVsXG4gKi9cblRpbGVDb29yZC56b29tID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gaWQgJSAzMjtcbn07XG5cbi8vIEdpdmVuIGFuIGlkIGFuZCBhIGxpc3Qgb2YgdXJscywgY2hvb3NlIGEgdXJsIHRlbXBsYXRlIGFuZCByZXR1cm4gYSB0aWxlIFVSTFxuVGlsZUNvb3JkLnVybCA9IGZ1bmN0aW9uKGlkLCB1cmxzKSB7XG4gICAgdmFyIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuXG4gICAgcmV0dXJuIHVybHNbKHBvcy54ICsgcG9zLnkpICUgdXJscy5sZW5ndGhdXG4gICAgICAgIC5yZXBsYWNlKCd7aH0nLCAocG9zLnggJSAxNikudG9TdHJpbmcoMTYpICsgKHBvcy55ICUgMTYpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t6fScsIHBvcy56KVxuICAgICAgICAucmVwbGFjZSgne3h9JywgcG9zLngpXG4gICAgICAgIC5yZXBsYWNlKCd7eX0nLCBwb3MueSk7XG59O1xuXG4vKlxuICogR2l2ZW4gYSBwYWNrZWQgaW50ZWdlciBpZCwgcmV0dXJuIHRoZSBpZCBvZiBpdHMgcGFyZW50IHRpbGVcbiAqL1xuVGlsZUNvb3JkLnBhcmVudCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuICAgIGlmIChwb3MueiA9PT0gMCkgcmV0dXJuIGlkO1xuICAgIGVsc2UgcmV0dXJuIFRpbGVDb29yZC50b0lEKHBvcy56IC0gMSwgTWF0aC5mbG9vcihwb3MueCAvIDIpLCBNYXRoLmZsb29yKHBvcy55IC8gMikpO1xufTtcblxuVGlsZUNvb3JkLnBhcmVudFdpdGhab29tID0gZnVuY3Rpb24oaWQsIHpvb20pIHtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG4gICAgd2hpbGUgKHBvcy56ID4gem9vbSkge1xuICAgICAgICBwb3Muei0tO1xuICAgICAgICBwb3MueCA9IE1hdGguZmxvb3IocG9zLnggLyAyKTtcbiAgICAgICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55IC8gMik7XG4gICAgfVxuICAgIHJldHVybiBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLngsIHBvcy55KTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIHBhY2tlZCBpbnRlZ2VyIGlkLCByZXR1cm4gYW4gYXJyYXkgb2YgaW50ZWdlciBpZHMgcmVwcmVzZW50aW5nXG4gKiBpdHMgZm91ciBjaGlsZHJlbi5cbiAqL1xuVGlsZUNvb3JkLmNoaWxkcmVuID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG4gICAgcG9zLnogKz0gMTtcbiAgICBwb3MueCAqPSAyO1xuICAgIHBvcy55ICo9IDI7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVGlsZUNvb3JkLnRvSUQocG9zLnosIHBvcy54LCBwb3MueSwgcG9zLncpLFxuICAgICAgICBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLnggKyAxLCBwb3MueSwgcG9zLncpLFxuICAgICAgICBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLngsIHBvcy55ICsgMSwgcG9zLncpLFxuICAgICAgICBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLnggKyAxLCBwb3MueSArIDEsIHBvcy53KVxuICAgIF07XG59O1xuXG5UaWxlQ29vcmQuem9vbVRvID0gZnVuY3Rpb24oYywgeikge1xuICAgIGMuY29sdW1uID0gYy5jb2x1bW4gKiBNYXRoLnBvdygyLCB6IC0gYy56b29tKTtcbiAgICBjLnJvdyA9IGMucm93ICogTWF0aC5wb3coMiwgeiAtIGMuem9vbSk7XG4gICAgYy56b29tID0gejtcbiAgICByZXR1cm4gYztcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJld2luZCA9IHJlcXVpcmUoJ2dlb2pzb24tcmV3aW5kJyk7XG5cbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVjb29yZC5qcycpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2dlby90cmFuc2Zvcm0uanMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbGVHZW9KU09OO1xuXG5mdW5jdGlvbiB0aWxlR2VvSlNPTihnZW9qc29uLCB6b29tKSB7XG4gICAgdmFyIHRpbGVzID0ge307XG4gICAgdmFyIHRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgdHJhbnNmb3JtLnpvb20gPSB6b29tO1xuXG4gICAgZ2VvanNvbiA9IHJld2luZChnZW9qc29uKTtcblxuICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aWxlRmVhdHVyZShnZW9qc29uLmZlYXR1cmVzW2ldLCB0cmFuc2Zvcm0sIHRpbGVzLCB0aWxlRXh0ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICB0aWxlRmVhdHVyZShnZW9qc29uLCB0cmFuc2Zvcm0sIHRpbGVzLCB0aWxlRXh0ZW50KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93KCdVbnJlY29nbml6ZWQgZ2VvanNvbiB0eXBlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbGVzO1xufVxuXG5mdW5jdGlvbiB0aWxlRmVhdHVyZShmZWF0dXJlLCB0cmFuc2Zvcm0sIHRpbGVzLCB0aWxlRXh0ZW50KSB7XG4gICAgdmFyIGNvb3JkcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG5cbiAgICB2YXIgdGlsZWQ7XG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgdGlsZWQgPSB0aWxlTGluZVN0cmluZyhbY29vcmRzXSwgdHJhbnNmb3JtLCB0aWxlRXh0ZW50KTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICB0aWxlZCA9IHRpbGVMaW5lU3RyaW5nKGNvb3JkcywgdHJhbnNmb3JtLCB0aWxlRXh0ZW50KTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIHRpbGVkID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGlsZWRfID0gdGlsZUxpbmVTdHJpbmcoY29vcmRzW2ldLCB0cmFuc2Zvcm0sIHRpbGVFeHRlbnQsIHR5cGUgPT09ICdQb2x5Z29uJyk7XG4gICAgICAgICAgICBmb3IgKHZhciB0aWxlSUQgaW4gdGlsZWRfKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aWxlZFt0aWxlSURdKSB0aWxlZFt0aWxlSURdID0gW107XG4gICAgICAgICAgICAgICAgdGlsZWRbdGlsZUlEXSA9ICh0aWxlZFt0aWxlSURdIHx8IFtdKS5jb25jYXQodGlsZWRfW3RpbGVJRF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHRocm93KFwidG9kb1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyhcInVucmVjb2duaXplZCBnZW9tZXRyeSB0eXBlXCIpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlkIGluIHRpbGVkKSB7XG4gICAgICAgIHRpbGVzW2lkXSA9IHRpbGVzW2lkXSB8fCBbXTtcbiAgICAgICAgdGlsZXNbaWRdLnB1c2goe1xuICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY29vcmRzOiB0aWxlZFtpZF0sXG4gICAgICAgICAgICB0eXBlOiBmZWF0dXJlLmdlb21ldHJ5LnR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0aWxlTGluZVN0cmluZyhjb29yZHMsIHRyYW5zZm9ybSwgdGlsZUV4dGVudCwgcmVqb2luKSB7XG5cbiAgICB2YXIgcGFkZGluZyA9IDAuMDE7XG4gICAgdmFyIHBhZGRlZEV4dGVudCA9IHRpbGVFeHRlbnQgKiAoMSArIDIgKiBwYWRkaW5nKTtcbiAgICB2YXIgY29vcmQgPSB0cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKG5ldyBMYXRMbmcoY29vcmRzWzBdWzFdLCBjb29yZHNbMF1bMF0pKTtcbiAgICB2YXIgcHJldkNvb3JkO1xuXG4gICAgdmFyIHRpbGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmV2Q29vcmQgPSBjb29yZDtcbiAgICAgICAgY29vcmQgPSB0cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKG5ldyBMYXRMbmcoY29vcmRzW2ldWzFdLCBjb29yZHNbaV1bMF0pKTtcblxuICAgICAgICB2YXIgZHggPSBjb29yZC5jb2x1bW4gLSBwcmV2Q29vcmQuY29sdW1uIHx8IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgICAgICBkeSA9IGNvb3JkLnJvdyAtIHByZXZDb29yZC5yb3cgfHwgTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgICAgIGRpclggPSBkeCAvIE1hdGguYWJzKGR4KSxcbiAgICAgICAgICAgIGRpclkgPSBkeSAvIE1hdGguYWJzKGR5KTtcblxuICAgICAgICAvLyBGaW5kIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3gsIGluIHRpbGVzLCBvZiB0aGUgcG9seWdvblxuICAgICAgICB2YXIgc3RhcnRUaWxlWCA9IE1hdGguZmxvb3IocHJldkNvb3JkLmNvbHVtbiAtIGRpclggKiBwYWRkaW5nKTtcbiAgICAgICAgdmFyIGVuZFRpbGVYID0gTWF0aC5mbG9vcihjb29yZC5jb2x1bW4gKyBkaXJYICogcGFkZGluZyk7XG4gICAgICAgIHZhciBzdGFydFRpbGVZID0gTWF0aC5mbG9vcihwcmV2Q29vcmQucm93IC0gZGlyWSAqIHBhZGRpbmcpO1xuICAgICAgICB2YXIgZW5kVGlsZVkgPSBNYXRoLmZsb29yKGNvb3JkLnJvdyArIGRpclkgKiBwYWRkaW5nKTtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIHRpbGVzIHRoZSBzZWdtZW50IG1pZ2h0IGludGVyc2VjdFxuICAgICAgICAvLyBhbmQgc3BsaXQgdGhlIHNlZ21lbnQgYWNyb3NzIHRob3NlIHRpbGVzXG4gICAgICAgIGZvciAodmFyIHggPSBzdGFydFRpbGVYOyAoeCAtIGVuZFRpbGVYKSAqIGRpclggPD0gMDsgeCArPSBkaXJYKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFggPSAoeCAtIHBhZGRpbmcgLSBwcmV2Q29vcmQuY29sdW1uKSAvIGR4O1xuICAgICAgICAgICAgdmFyIHJpZ2h0WCA9ICh4ICsgMSArIHBhZGRpbmcgLSBwcmV2Q29vcmQuY29sdW1uKSAvIGR4O1xuXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gc3RhcnRUaWxlWTsgKHkgLSBlbmRUaWxlWSkgKiBkaXJZIDw9IDA7IHkgKz0gZGlyWSkge1xuICAgICAgICAgICAgICAgIHZhciB0b3BZID0gKHkgLSBwYWRkaW5nIC0gcHJldkNvb3JkLnJvdykgLyBkeTtcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tWSA9ICh5ICsgMSArIHBhZGRpbmcgLSBwcmV2Q29vcmQucm93KSAvIGR5O1xuXG4gICAgICAgICAgICAgICAgLy8gZnJhY3Rpb24gb2YgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBzZWdtZW50IGF0IHdoaWNoIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgLy8gZW50ZXJzIG9yIGV4aXRzIHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgdmFyIGVudGVyID0gTWF0aC5tYXgoTWF0aC5taW4obGVmdFgsIHJpZ2h0WCksIE1hdGgubWluKHRvcFksIGJvdHRvbVkpKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhpdCA9IE1hdGgubWluKE1hdGgubWF4KGxlZnRYLCByaWdodFgpLCBNYXRoLm1heCh0b3BZLCBib3R0b21ZKSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlsZUlEID0gVGlsZUNvb3JkLnRvSUQodHJhbnNmb3JtLnRpbGVab29tLCB4LCB5KSxcbiAgICAgICAgICAgICAgICAgICAgdGlsZSA9IHRpbGVzW3RpbGVJRF0sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50O1xuXG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudHMgc3RhcnRzIG91dHNpZGUgdGhlIHRpbGUsIGFkZCBlbnRyeSBwb2ludFxuICAgICAgICAgICAgICAgIGlmICgwIDw9IGVudGVyICYmIGVudGVyIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICgocHJldkNvb3JkLmNvbHVtbiArIGVudGVyICogZHgpIC0geCkgKiB0aWxlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgKChwcmV2Q29vcmQucm93ICsgZW50ZXIgKiBkeSkgLSB5KSAqIHRpbGVFeHRlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LmNvbnRpbnVlcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlKSB0aWxlc1t0aWxlSURdID0gdGlsZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLnB1c2goW3BvaW50XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudHMgZW5kcyBvdXRzaWRlIHRoZSB0aWxlLCBhZGQgZXhpdCBwb2ludFxuICAgICAgICAgICAgICAgIGlmICgwIDw9IGV4aXQgJiYgZXhpdCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHByZXZDb29yZC5jb2x1bW4gKyBleGl0ICogZHgpIC0geCkgKiB0aWxlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgKChwcmV2Q29vcmQucm93ICsgZXhpdCAqIGR5KSAtIHkpICogdGlsZUV4dGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuY29udGludWVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0aWxlW3RpbGUubGVuZ3RoIC0gMV0ucHVzaChwb2ludCk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHBvaW50IGl0c2VsZlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvb3JkLmNvbHVtbiAtIHgpICogdGlsZUV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb29yZC5yb3cgLSB5KSAqIHRpbGVFeHRlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlsZSkgdGlsZXNbdGlsZUlEXSA9IHRpbGUgPSBbW3BvaW50XV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGlsZVt0aWxlLmxlbmd0aCAtIDFdLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWpvaW4pIHtcbiAgICAgICAgLy8gcmVhc3NlbWJsZSB0aGUgZGlzY29ubmVjdGVkIHNlZ21lbnRzIGludG8gYSBsaW5lc3RyaW5nXG4gICAgICAgIC8vIHNlY3Rpb25zIG9mIHRoZSBsaW5lc3RyaW5nIG91dHNpZGUgdGhlIHRpbGUgYXJlIHJlcGxhY2VkIHdpdGggc2VnbWVudHNcbiAgICAgICAgLy8gdGhhdCBmb2xsb3cgdGhlIHRpbGUncyBlZGdlXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRpbGVzKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHRpbGVzW2lkXTtcblxuICAgICAgICAgICAgaWYgKCFzZWdtZW50c1swXVswXS5jb250aW51ZXMgJiYgc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBzZWdtZW50IGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGpvaW4gaXQgd2l0aCB0aGUgbGFzdCBzbyB0aGF0IGFsbCBzZWdtZW50cyBzdGFydCBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQgYXQgdGlsZSBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShzZWdtZW50c1swXSwgbGFzdC5zbGljZSgwLCBsYXN0Lmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZWRnZURpc3Qoc2VnbWVudHNbMF1bMF0sIHRpbGVFeHRlbnQsIHBhZGRpbmcpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlZ21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFsbCB0aWxlIGNvcm5lcnMgYWxvbmcgdGhlIHBhdGggYmV0d2VlbiB0aGUgY3VycmVudCBzZWdtZW50J3MgZXhpdCBwb2ludFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgbmV4dCBzZWdtZW50J3MgZW50cnkgcG9pbnRcblxuICAgICAgICAgICAgICAgIHZhciB0aGlzRXhpdCA9IGVkZ2VEaXN0KHNlZ21lbnRzW2tdW3NlZ21lbnRzW2tdLmxlbmd0aCAtIDFdLCBwYWRkZWRFeHRlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0RW50cnkgPSBlZGdlRGlzdChzZWdtZW50c1soayArIDEpICUgc2VnbWVudHMubGVuZ3RoXVswXSwgcGFkZGVkRXh0ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydFRvRXhpdCA9ICh0aGlzRXhpdCAtIHN0YXJ0ICsgNCkgJSA0O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFRvTmV4dEVudHJ5ID0gKG5leHRFbnRyeSAtIHN0YXJ0ICsgNCkgJSA0O1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSAodGhpc0V4aXQgPT09IG5leHRFbnRyeSB8fCBzdGFydFRvRXhpdCA8IHN0YXJ0VG9OZXh0RW50cnkpID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHZhciByb3VuZEZuID0gZGlyZWN0aW9uID4gMCA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gcm91bmRGbih0aGlzRXhpdCkgJSA0OyBjICE9IHJvdW5kRm4obmV4dEVudHJ5KSAlIDQ7IGMgPSAoYyArIGRpcmVjdGlvbiArIDQpICUgNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29ybmVyID0gY29ybmVyc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNba10ucHVzaChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29ybmVyLnggKyAoY29ybmVyLnggLSAwLjUgPiAwID8gMSA6IC0xKSAqIHBhZGRpbmcpICogdGlsZUV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb3JuZXIueSArIChjb3JuZXIueSAtIDAuNSA+IDAgPyAxIDogLTEpICogcGFkZGluZykgKiB0aWxlRXh0ZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKb2luIGFsbCBzZWdtZW50c1xuICAgICAgICAgICAgdGlsZXNbaWRdID0gW0FycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHNlZ21lbnRzKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGlsZXM7XG5cbn1cblxudmFyIGNvcm5lcnMgPSBbXG4gICAgbmV3IFBvaW50KDAsIDApLFxuICAgIG5ldyBQb2ludCgxLCAwKSxcbiAgICBuZXcgUG9pbnQoMSwgMSksXG4gICAgbmV3IFBvaW50KDAsIDEpXTtcblxuLypcbiAqIENvbnZlcnRzIHRvIGEgcG9pbnQgdG8gdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBlZGdlIG9mIHRoZSB0aWxlIChvdXQgb2YgNCkuXG4gKlxuICogICAgICAgICAwLjVcbiAqICAgICAwIF9fX19fX18gMVxuICogICAgICB8ICAgICAgIHxcbiAqICAzLjUgfCAgICAgICB8IDEuNVxuICogICAgICB8ICAgICAgIHxcbiAqICAgICAgfF9fX19fX198XG4gKiAgICAgMyAgIDIuNSAgIDJcbiAqL1xuZnVuY3Rpb24gZWRnZURpc3QocG9pbnQsIGV4dGVudCkge1xuICAgIHZhciB4ID0gcG9pbnQueCAvIGV4dGVudDtcbiAgICB2YXIgeSA9IHBvaW50LnkgLyBleHRlbnQ7XG4gICAgdmFyIGQ7XG4gICAgaWYgKE1hdGguYWJzKHkgLSAwLjUpID49IE1hdGguYWJzKHggLSAwLjUpKSB7XG4gICAgICAgIGQgPSBNYXRoLnJvdW5kKHkpICogMiArICh5IDwgMC41ID8geCA6IDEgLSB4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkID0gTWF0aC5yb3VuZCgxIC0geCkgKiAyICsgKHggPiAwLjUgPyB5IDogMSAtIHkpICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZCAlIDQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlLmpzJyksXG4gICAgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlY29vcmQuanMnKSxcbiAgICBCdWZmZXJTZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlci9idWZmZXJzZXQuanMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XG5cbnZhciBjcmVhdGVCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2NyZWF0ZWJ1Y2tldC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGUoaWQsIHNvdXJjZSwgdXJsLCBjYWxsYmFjaykge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuem9vbSA9IFRpbGVDb29yZC5mcm9tSUQoaWQpLno7XG4gICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuICAgIHRoaXMub3B0aW9ucyA9IHNvdXJjZS5vcHRpb25zO1xuICAgIHRoaXMuaWQgPSB1dGlsLnVuaXF1ZUlkKCk7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgaWYgKHRoaXMuem9vbSA+PSBzb3VyY2UudGlsZUpTT04ubWF4em9vbSkge1xuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5tYXAub3B0aW9ucy5tYXhab29tIC0gdGhpcy56b29tO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAxO1xuICAgIH1cbiAgICB0aGlzLnVzZXMgPSAxO1xuICAgIHRoaXMuX2xvYWQoKTtcbn1cblxuVmVjdG9yVGlsZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoVGlsZSwge1xuXG4gICAgX2xvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGlsZSA9IHRoaXM7XG4gICAgICAgIHRoaXMud29ya2VySUQgPSB0aGlzLm1hcC5kaXNwYXRjaGVyLnNlbmQoJ2xvYWQgdGlsZScsIHtcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMuc291cmNlLnRpbGVKU09OLm1heHpvb20sXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy5vcHRpb25zLnRpbGVTaXplLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZS5pZCxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFlcnIgJiYgZGF0YSkge1xuICAgICAgICAgICAgICAgIHRpbGUub25UaWxlTG9hZChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbGUuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uVGlsZUxvYWQ6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAvLyBUaWxlIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gICAgICAgIGlmICghdGhpcy5tYXApIHJldHVybjtcblxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KGRhdGEuYnVmZmVycyk7XG5cbiAgICAgICAgdGhpcy5idWNrZXRzID0ge307XG4gICAgICAgIGZvciAodmFyIGIgaW4gZGF0YS5lbGVtZW50R3JvdXBzKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHNbYl0gPSBjcmVhdGVCdWNrZXQodGhpcy5tYXAuc3R5bGUuYnVja2V0c1tiXSwgdGhpcy5idWZmZXJzLCB1bmRlZmluZWQsIGRhdGEuZWxlbWVudEdyb3Vwc1tiXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcmV1c2UgcHJlcmVuZGVyZWQgdGV4dHVyZXNcbiAgICAgICAgZm9yICh2YXIgYnVja2V0IGluIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVja2V0c1tidWNrZXRdLnByZXJlbmRlcmVkKSB0aGlzLm1hcC5wYWludGVyLnNhdmVUZXh0dXJlKHRoaXMuYnVja2V0c1tidWNrZXRdLnByZXJlbmRlcmVkLnRleHR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXAuZGlzcGF0Y2hlci5zZW5kKCdyZW1vdmUgdGlsZScsIHsgaWQ6IHRoaXMuaWQsIHNvdXJjZTogdGhpcy5zb3VyY2UuaWQgfSwgbnVsbCwgdGhpcy53b3JrZXJJRCk7XG4gICAgICAgIHRoaXMubWFwLnBhaW50ZXIuZ2x5cGhBdGxhcy5yZW1vdmVHbHlwaHModGhpcy5pZCk7XG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5tYXAucGFpbnRlci5nbDtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgICAgIGlmIChidWZmZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiIGluIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJzW2JdLmRlc3Ryb3koZ2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hcDtcbiAgICB9LFxuXG4gICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1hcC5kaXNwYXRjaGVyLnNlbmQoJ2Fib3J0IHRpbGUnLCB7IGlkOiB0aGlzLmlkLCBzb3VyY2U6IHRoaXMuc291cmNlLmlkIH0sIG51bGwsIHRoaXMud29ya2VySUQpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZS5qcycpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZWNvb3JkLmpzJyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZy5qcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1NvdXJjZTtcblxuZnVuY3Rpb24gVmlkZW9Tb3VyY2Uob3B0aW9ucykge1xuXG4gICAgdGhpcy52aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgdGhpcy52aWRlby5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIHRoaXMudmlkZW8ubG9vcCA9IHRydWU7XG5cbiAgICB2YXIgdXJscyA9ICh0eXBlb2Ygb3B0aW9ucy51cmwgPT09ICdzdHJpbmcnKSA/IFtvcHRpb25zLnVybF0gOiBvcHRpb25zLnVybDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICAgICAgICBzLnNyYyA9IHVybHNbaV07XG4gICAgICAgIHRoaXMudmlkZW8uYXBwZW5kQ2hpbGQocyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb29yZGluYXRlcyA9IG9wdGlvbnMuY29vcmRpbmF0ZXM7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHZhciBsb29wSUQ7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgICAvLyBzdGFydCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RhcnRzIHBsYXlpbmdcbiAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9vcElEID0gc291cmNlLm1hcC5zdHlsZS5hbmltYXRpb25Mb29wLnNldChJbmZpbml0eSk7XG4gICAgICAgIHNvdXJjZS5tYXAuX3JlcmVuZGVyKCk7XG4gICAgfSk7XG5cbiAgICAvLyBzdG9wIHJlcGFpbnRpbmcgd2hlbiB2aWRlbyBzdG9wc1xuICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc291cmNlLm1hcC5zdHlsZS5hbmltYXRpb25Mb29wLmNhbmNlbChsb29wSUQpO1xuICAgIH0pO1xuXG59XG5cblZpZGVvU291cmNlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMudmlkZW8ucGxheSgpO1xuICAgIHRoaXMuY3JlYXRlVGlsZSgpO1xufTtcblxuVmlkZW9Tb3VyY2UucHJvdG90eXBlLmNyZWF0ZVRpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSB3aGljaCBtZXJjYXRvciB0aWxlIGlzIHN1aXRhYmxlIGZvciByZW5kZXJpbmcgdGhlIHZpZGVvIGluXG4gICAgICogYW5kIGNyZWF0ZSBhIGJ1ZmZlciB3aXRoIHRoZSBjb3JuZXIgY29vcmRpbmF0ZXMuIFRoZXNlIGNvb3JkaW5hdGVzXG4gICAgICogbWF5IGJlIG91dHNpZGUgdGhlIHRpbGUsIGJlY2F1c2UgcmFzdGVyIHRpbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gcmVuZGVyaW5nLlxuICAgICAqL1xuICAgIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgIHZhciBsb2MgPSBMYXRMbmcuY29udmVydChsYXRsbmcpO1xuICAgICAgICByZXR1cm4gVGlsZUNvb3JkLnpvb21UbyhtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShsb2MpLCAwKTtcbiAgICB9KTtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBjb29yZHNbaV0uY29sdW1uKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGNvb3Jkc1tpXS5yb3cpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBjb29yZHNbaV0ucm93KTtcbiAgICB9XG5cbiAgICB2YXIgZHggPSBtYXhYIC0gbWluWDtcbiAgICB2YXIgZHkgPSBtYXhZIC0gbWluWTtcbiAgICB2YXIgZE1heCA9IE1hdGgubWF4KGR4LCBkeSk7XG4gICAgdmFyIGNlbnRlciA9IFRpbGVDb29yZC56b29tVG8oe1xuICAgICAgICBjb2x1bW46IChtaW5YICsgbWF4WCkgLyAyLFxuICAgICAgICByb3c6IChtaW5ZICsgbWF4WSkgLyAyLFxuICAgICAgICB6b29tOiAwXG4gICAgfSwgTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xuXG4gICAgdmFyIHRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHZhciB0aWxlQ29vcmRzID0gY29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgem9vbWVkQ29vcmQgPSBUaWxlQ29vcmQuem9vbVRvKGNvb3JkLCBjZW50ZXIuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXIuY29sdW1uKSAqIHRpbGVFeHRlbnQpLFxuICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQucm93IC0gY2VudGVyLnJvdykgKiB0aWxlRXh0ZW50KSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZ2wgPSBtYXAucGFpbnRlci5nbDtcbiAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICB2YXIgYXJyYXkgPSBuZXcgSW50MTZBcnJheShbXG4gICAgICAgIHRpbGVDb29yZHNbMF0ueCwgdGlsZUNvb3Jkc1swXS55LCAwLCAwLFxuICAgICAgICB0aWxlQ29vcmRzWzFdLngsIHRpbGVDb29yZHNbMV0ueSwgbWF4SW50MTYsIDAsXG4gICAgICAgIHRpbGVDb29yZHNbM10ueCwgdGlsZUNvb3Jkc1szXS55LCAwLCBtYXhJbnQxNixcbiAgICAgICAgdGlsZUNvb3Jkc1syXS54LCB0aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNlxuICAgIF0pO1xuICAgIHRoaXMuYm91bmRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYm91bmRzQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMudGlsZSA9IG5ldyBUaWxlKCk7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG59O1xuXG5WaWRlb1NvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIG5vb3Bcbn07XG5cblZpZGVvU291cmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBub29wXG59O1xuXG5WaWRlb1NvdXJjZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy52aWRlby5yZWFkeVN0YXRlIDwgMikgcmV0dXJuOyAvLyBub3QgZW5vdWdoIGRhdGEgZm9yIGN1cnJlbnQgcG9zaXRpb25cblxuICAgIHZhciBsYXllciA9IGxheWVyc1swXTtcblxuICAgIHZhciBidWNrZXQgPSB7XG4gICAgICAgIHR5cGU6ICdyYXN0ZXInLFxuICAgICAgICB0aWxlOiB0aGlzLFxuICAgICAgICBib3VuZHNCdWZmZXI6IHRoaXMuYm91bmRzQnVmZmVyLFxuICAgICAgICBiaW5kOiB0aGlzLmJpbmQuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICB2YXIgYnVja2V0cyA9IHt9O1xuICAgIGJ1Y2tldHNbbGF5ZXIuYnVja2V0XSA9IGJ1Y2tldDtcblxuICAgIHZhciBjID0gdGhpcy5jZW50ZXI7XG4gICAgdGhpcy50aWxlLmNhbGN1bGF0ZU1hdHJpY2VzKGMuem9vbSwgYy5jb2x1bW4sIGMucm93LCB0aGlzLm1hcC50cmFuc2Zvcm0sIHRoaXMubWFwLnBhaW50ZXIpO1xuICAgIHRoaXMubWFwLnBhaW50ZXIudGlsZSA9IHRoaXMudGlsZTtcbiAgICB0aGlzLm1hcC5wYWludGVyLmFwcGx5U3R5bGUobGF5ZXIsIHRoaXMubWFwLnN0eWxlLCBidWNrZXRzLCB7fSk7XG59O1xuXG5WaWRlb1NvdXJjZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG5cbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcbiAgICB9XG5cbn07XG5cblxuVmlkZW9Tb3VyY2UucHJvdG90eXBlLmZlYXR1cmVzQXQgPSBmdW5jdGlvbihwb2ludCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE8gcmV0dXJuIHBpeGVsP1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0b3IgPSByZXF1aXJlKCcuLi91dGlsL2FjdG9yLmpzJyksXG4gICAgYnVja2V0RmlsdGVyID0gcmVxdWlyZSgnLi4vc3R5bGUvYnVja2V0ZmlsdGVyLmpzJyksXG4gICAgV29ya2VyVGlsZSA9IHJlcXVpcmUoJy4vd29ya2VydGlsZS5qcycpLFxuICAgIHRpbGVHZW9KU09OID0gcmVxdWlyZSgnLi90aWxlZ2VvanNvbi5qcycpLFxuICAgIFdyYXBwZXIgPSByZXF1aXJlKCcuL2dlb2pzb253cmFwcGVyLmpzJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxuICAgIHF1ZXVlID0gcmVxdWlyZSgncXVldWUtYXN5bmMnKSxcbiAgICBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV29ya2VyO1xuXG5mdW5jdGlvbiBXb3JrZXIoc2VsZikge1xuICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gICAgdGhpcy5hY3RvciA9IG5ldyBBY3RvcihzZWxmLCB0aGlzKTtcbn1cblxudXRpbC5leHRlbmQoV29ya2VyLnByb3RvdHlwZSwge1xuICAgIGFsZXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdhbGVydCBtZXNzYWdlJyxcbiAgICAgICAgICAgIGRhdGE6IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlcyB0aGUgc3R5bGUgdG8gdXNlIGZvciB0aGlzIG1hcC5cbiAgICAnc2V0IGJ1Y2tldHMnOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBidWNrZXRzID0gV29ya2VyVGlsZS5idWNrZXRzID0gZGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gYnVja2V0c1tpXTtcbiAgICAgICAgICAgIGJ1Y2tldC5jb21wYXJlID0gYnVja2V0RmlsdGVyKGJ1Y2tldC5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdzZXQgZ2x5cGhzJzogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBXb3JrZXJUaWxlLnByb3RvdHlwZS5nbHlwaHMgPSBkYXRhO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIExvYWQgYW5kIHBhcnNlIGEgdGlsZSBhdCBgdXJsYCwgYW5kIGNhbGwgYGNhbGxiYWNrYCB3aXRoXG4gICAgICogKGVyciwgcmVzcG9uc2UpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICAnbG9hZCB0aWxlJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBuZXcgV29ya2VyVGlsZShwYXJhbXMudXJsLCB1bmRlZmluZWQsIHBhcmFtcy5pZCwgcGFyYW1zLnpvb20sIHBhcmFtcy5tYXhab29tLCBwYXJhbXMudGlsZVNpemUsIHBhcmFtcy5zb3VyY2UsIHBhcmFtcy5kZXB0aCwgdGhpcy5hY3RvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEFib3J0IHRoZSByZXF1ZXN0IGtleWVkIHVuZGVyIGB1cmxgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICovXG4gICAgJ2Fib3J0IHRpbGUnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgV29ya2VyVGlsZS5jYW5jZWwocGFyYW1zLmlkLCBwYXJhbXMuc291cmNlKTtcbiAgICB9LFxuXG4gICAgJ3JlbW92ZSB0aWxlJzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpZCA9IHBhcmFtcy5pZDtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHBhcmFtcy5zb3VyY2U7XG4gICAgICAgIGlmIChXb3JrZXJUaWxlLmxvYWRlZFtzb3VyY2VdICYmIFdvcmtlclRpbGUubG9hZGVkW3NvdXJjZV1baWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXVtpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3BhcnNlIGdlb2pzb24nOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gcGFyYW1zLmRhdGEsXG4gICAgICAgICAgICB6b29tcyA9IHBhcmFtcy56b29tcyxcbiAgICAgICAgICAgIGxlbiA9IHpvb21zLmxlbmd0aCxcbiAgICAgICAgICAgIG1heFpvb20gPSB6b29tc1tsZW4gLSAxXSxcbiAgICAgICAgICAgIGFjdG9yID0gdGhpcy5hY3RvcixcbiAgICAgICAgICAgIHEgPSBxdWV1ZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHdvcmtlcihpZCwgdGlsZSwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG5ldyBXb3JrZXJUaWxlKHVuZGVmaW5lZCwgbmV3IFdyYXBwZXIodGlsZSksIGlkLCB6b29tLCBtYXhab29tLCBwYXJhbXMudGlsZVNpemUsIHBhcmFtcy5zb3VyY2UsIDQsIGFjdG9yLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICBkYXRhLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRpbGVEYXRhKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gem9vbXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRpbGVzID0gdGlsZUdlb0pTT04oZGF0YSwgem9vbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5kZWZlcih3b3JrZXIsIGlkLCB0aWxlc1tpZF0sIHpvb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEuYXdhaXRBbGwoY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgYWpheC5nZXRKU09OKGRhdGEsIHRpbGVEYXRhKTtcbiAgICAgICAgZWxzZSB0aWxlRGF0YShudWxsLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgJ3F1ZXJ5IGZlYXR1cmVzJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGlsZSA9IFdvcmtlclRpbGUubG9hZGVkW3BhcmFtcy5zb3VyY2VdICYmIFdvcmtlclRpbGUubG9hZGVkW3BhcmFtcy5zb3VyY2VdW3BhcmFtcy5pZF07XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aWxlLmZlYXR1cmVUcmVlLnF1ZXJ5KHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlVHJlZSA9IHJlcXVpcmUoJy4uL2RhdGEvZmVhdHVyZXRyZWUuanMnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xudmFyIHZ0ID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKTtcbnZhciBDb2xsaXNpb24gPSByZXF1aXJlKCcuLi9zeW1ib2wvY29sbGlzaW9uLmpzJyk7XG52YXIgZ2V0QXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKS5nZXRBcnJheUJ1ZmZlcjtcblxudmFyIEJ1ZmZlclNldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyL2J1ZmZlcnNldC5qcycpO1xudmFyIGNyZWF0ZUJ1Y2tldCA9IHJlcXVpcmUoJy4uL2RhdGEvY3JlYXRlYnVja2V0LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV29ya2VyVGlsZTtcbmZ1bmN0aW9uIFdvcmtlclRpbGUodXJsLCBkYXRhLCBpZCwgem9vbSwgbWF4Wm9vbSwgdGlsZVNpemUsIHNvdXJjZSwgZGVwdGgsIGFjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciB0aWxlID0gdGhpcztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLm1heFpvb20gPSBtYXhab29tO1xuICAgIHRoaXMudGlsZVNpemUgPSB0aWxlU2l6ZTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5idWZmZXJzID0gbmV3IEJ1ZmZlclNldCgpO1xuXG4gICAgZnVuY3Rpb24gbG9hZGVkKGRhdGEpIHtcbiAgICAgICAgV29ya2VyVGlsZS5sb2FkZWRbc291cmNlXSA9IFdvcmtlclRpbGUubG9hZGVkW3NvdXJjZV0gfHwge307XG4gICAgICAgIFdvcmtlclRpbGUubG9hZGVkW3NvdXJjZV1baWRdID0gdGlsZTtcbiAgICAgICAgdGlsZS5kYXRhID0gZGF0YTtcbiAgICAgICAgdGlsZS5wYXJzZShkYXRhLCBhY3RvciwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgICAgaWYgKFdvcmtlclRpbGUubG9hZGluZ1tzb3VyY2VdID09PSB1bmRlZmluZWQpIFdvcmtlclRpbGUubG9hZGluZ1tzb3VyY2VdID0ge307XG4gICAgICAgIFdvcmtlclRpbGUubG9hZGluZ1tzb3VyY2VdW2lkXSA9IGdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBkZWxldGUgV29ya2VyVGlsZS5sb2FkaW5nW3NvdXJjZV1baWRdO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvYWRlZChuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRlZChkYXRhKTtcbiAgICB9XG59XG5cbldvcmtlclRpbGUuY2FuY2VsID0gZnVuY3Rpb24oaWQsIHNvdXJjZUlEKSB7XG4gICAgdmFyIHNvdXJjZSA9IFdvcmtlclRpbGUubG9hZGluZ1tzb3VyY2VJRF07XG4gICAgaWYgKHNvdXJjZSAmJiBzb3VyY2VbaWRdKSB7XG4gICAgICAgIHNvdXJjZVtpZF0uYWJvcnQoKTtcbiAgICAgICAgZGVsZXRlIHNvdXJjZVtpZF07XG4gICAgfVxufTtcblxuLy8gU3RvcmVzIHRpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkaW5nLlxuV29ya2VyVGlsZS5sb2FkaW5nID0ge307XG5cbi8vIFN0b3JlcyB0aWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkLlxuV29ya2VyVGlsZS5sb2FkZWQgPSB7fTtcblxuLy8gU3RvcmVzIHRoZSBzdHlsZSBpbmZvcm1hdGlvbi5cbldvcmtlclRpbGUuYnVja2V0cyA9IFtdO1xuXG4vKlxuICogR2l2ZW4gdGlsZSBkYXRhLCBwYXJzZSByYXcgdmVydGljZXMgYW5kIGRhdGEsIGNyZWF0ZSBhIHZlY3RvclxuICogdGlsZSBhbmQgcGFyc2UgaXQgaW50byByZWFkeS10by1yZW5kZXIgdmVydGljZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc3BvbmRcbiAqL1xuV29ya2VyVGlsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBhY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGlsZSA9IHRoaXM7XG4gICAgdmFyIGJ1Y2tldEluZm8gPSBXb3JrZXJUaWxlLmJ1Y2tldHM7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgdmFyIHRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHRoaXMuY29sbGlzaW9uID0gbmV3IENvbGxpc2lvbih0aGlzLnpvb20sIHRpbGVFeHRlbnQsIHRoaXMudGlsZVNpemUsIHRoaXMuZGVwdGgpO1xuICAgIHRoaXMuZmVhdHVyZVRyZWUgPSBuZXcgRmVhdHVyZVRyZWUoZ2V0R2VvbWV0cnksIGdldFR5cGUpO1xuXG4gICAgdmFyIGJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHMgPSBzb3J0VGlsZUludG9CdWNrZXRzKHRoaXMsIGRhdGEsIGJ1Y2tldEluZm8pO1xuXG4gICAgdmFyIGtleSwgYnVja2V0O1xuICAgIHZhciBwcmV2UGxhY2VtZW50QnVja2V0O1xuXG4gICAgdmFyIHJlbWFpbmluZyA9IFdvcmtlclRpbGUuYnVja2V0cy5sZW5ndGg7XG5cbiAgICAvKlxuICAgICAqICBUaGUgYXN5bmMgcGFyc2luZyBoZXJlIGlzIGEgYml0IHRyaWNreS5cbiAgICAgKiAgU29tZSBidWNrZXRzIGRlcGVuZCBvbiByZXNvdXJjZXMgdGhhdCBtYXkgbmVlZCB0byBiZSBsb2FkZWQgYXN5bmMgKGdseXBocykuXG4gICAgICogIFNvbWUgYnVja2V0cyBuZWVkIHRvIGJlIHBhcnNlZCBpbiBvcmRlciAodG8gZ2V0IHBsYWNlbWVudCBwcmlvcml0aWVzIHJpZ2h0KS5cbiAgICAgKlxuICAgICAqICBEZXBlbmRlbmNpZXMgY2FsbHMgYXJlIGluaXRpYXRlZCBmaXJzdCB0byBnZXQgdGhvc2Ugcm9sbGluZy5cbiAgICAgKiAgQnVja2V0cyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgcGFyc2VkIGluIG9yZGVyLCBhcmVuJ3QgdG8gc2F2ZSB0aW1lLlxuICAgICAqL1xuXG4gICAgdmFyIG9yZGVyZWRCdWNrZXRzID0gV29ya2VyVGlsZS5idWNrZXRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZEJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0c1tvcmRlcmVkQnVja2V0c1tpXS5pZF07XG4gICAgICAgIGlmICghYnVja2V0KSB7XG4gICAgICAgICAgICByZW1haW5pbmctLTtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyByYXN0ZXIgYnVja2V0LCBldGNcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXIgPSBidWNrZXQuaW5mby5maWx0ZXI7XG4gICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLnNvdXJjZSAhPT0gdGhpcy5zb3VyY2UpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIExpbmsgYnVja2V0cyB0aGF0IG5lZWQgdG8gYmUgcGFyc2VkIGluIG9yZGVyXG4gICAgICAgIGlmIChidWNrZXQuY29sbGlzaW9uKSB7XG4gICAgICAgICAgICBpZiAocHJldlBsYWNlbWVudEJ1Y2tldCkge1xuICAgICAgICAgICAgICAgIHByZXZQbGFjZW1lbnRCdWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVja2V0LnByZXZpb3VzUGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQbGFjZW1lbnRCdWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVja2V0LmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgYnVja2V0LmdldERlcGVuZGVuY2llcyh0aGlzLCBhY3RvciwgZGVwZW5kZW5jaWVzRG9uZShidWNrZXQpKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gcGFyc2UgYnVja2V0cyB3aGVyZSBvcmRlciBkb2Vzbid0IG1hdHRlciBhbmQgbm8gZGVwZW5kZW5jaWVzXG4gICAgZm9yIChrZXkgaW4gYnVja2V0cykge1xuICAgICAgICBidWNrZXQgPSBidWNrZXRzW2tleV07XG4gICAgICAgIGlmICghYnVja2V0LmdldERlcGVuZGVuY2llcyAmJiAhYnVja2V0LmNvbGxpc2lvbikge1xuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcGVuZGVuY2llc0RvbmUoYnVja2V0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5kZXBlbmRlbmNpZXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0LCBlcnIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQnVja2V0KHRpbGUsIGJ1Y2tldCwgc2tpcCkge1xuICAgICAgICBpZiAoYnVja2V0LmdldERlcGVuZGVuY2llcyAmJiAhYnVja2V0LmRlcGVuZGVuY2llc0xvYWRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoYnVja2V0LmNvbGxpc2lvbiAmJiAhYnVja2V0LnByZXZpb3VzUGxhY2VkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChidWNrZXQudHlwZSAhPT0gJ3Jhc3RlcicpIGJ1Y2tldC5hZGRGZWF0dXJlcygpO1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0LmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gYnVja2V0LmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmZlYXR1cmVUcmVlLmluc2VydChmZWF0dXJlLmJib3goKSwgYnVja2V0Lm5hbWUsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1Y2tldFN0YXRzID0gc2VsZi5idWNrZXRTdGF0cyB8fCB7X3RvdGFsOiAwfTtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1Y2tldFN0YXRzLl90b3RhbCArPSB0aW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHNbYnVja2V0Lm5hbWVdID0gKHNlbGYuYnVja2V0U3RhdHNbYnVja2V0Lm5hbWVdIHx8IDApICsgdGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICBpZiAoIXJlbWFpbmluZykgcmV0dXJuIHRpbGUuZG9uZSgpO1xuXG4gICAgICAgIC8vIHRyeSBwYXJzaW5nIHRoZSBuZXh0IGJ1Y2tldCwgaWYgaXQgaXMgcmVhZHlcbiAgICAgICAgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBidWNrZXQubmV4dC5wcmV2aW91c1BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQubmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ29sbGVjdCBhbGwgYnVmZmVycyB0byBtYXJrIHRoZW0gYXMgdHJhbnNmZXJhYmxlIG9iamVjdC5cbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKHRoaXMuYnVmZmVyc1t0eXBlXS5hcnJheSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBidWNrZXRzIHRvIGEgdHJhbnNmZXJhYmxlIGZvcm1hdFxuICAgIHZhciBidWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgIHZhciBlbGVtZW50R3JvdXBzID0ge307XG4gICAgZm9yICh2YXIgYiBpbiBidWNrZXRzKSBlbGVtZW50R3JvdXBzW2JdID0gYnVja2V0c1tiXS5lbGVtZW50R3JvdXBzO1xuXG4gICAgdGhpcy5jYWxsYmFjayhudWxsLCB7XG4gICAgICAgIGVsZW1lbnRHcm91cHM6IGVsZW1lbnRHcm91cHMsXG4gICAgICAgIGJ1ZmZlcnM6IHRoaXMuYnVmZmVyc1xuICAgIH0sIGJ1ZmZlcnMpO1xuXG4gICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnl0aGluZyBleGNlcHQgZmVhdHVyZVRyZWUgYXQgdGhpcyBwb2ludCwgc28gd2UgbWFyayBpdCBmb3IgR0NcbiAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuY29sbGlzaW9uID0gbnVsbDtcbiAgICB0aGlzLmJ1Y2tldHMgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gc29ydFRpbGVJbnRvQnVja2V0cyh0aWxlLCBkYXRhLCBidWNrZXRJbmZvKSB7XG5cbiAgICB2YXIgc291cmNlTGF5ZXJzID0ge30sXG4gICAgICAgIGJ1Y2tldHMgPSB7fSxcbiAgICAgICAgbGF5ZXJOYW1lO1xuXG4gICAgLy8gRm9yIGVhY2ggc291cmNlIGxheWVyLCBmaW5kIGEgbGlzdCBvZiBidWNrZXRzIHRoYXQgdXNlIGRhdGEgZnJvbSBpdFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0SW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5mbyA9IGJ1Y2tldEluZm9baV07XG4gICAgICAgIHZhciBidWNrZXROYW1lID0gaW5mby5pZDtcblxuICAgICAgICB2YXIgbWluWm9vbSA9IGluZm9bJ21pbi16b29tJ107XG4gICAgICAgIHZhciBtYXhab29tID0gaW5mb1snbWF4LXpvb20nXTtcblxuICAgICAgICBpZiAoaW5mby5zb3VyY2UgIT09IHRpbGUuc291cmNlKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG1pblpvb20gJiYgdGlsZS56b29tIDwgbWluWm9vbSAmJiBtaW5ab29tIDwgdGlsZS5tYXhab29tKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG1heFpvb20gJiYgdGlsZS56b29tID49IG1heFpvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBidWNrZXQgPSBjcmVhdGVCdWNrZXQoaW5mbywgdGlsZS5idWZmZXJzLCB0aWxlLmNvbGxpc2lvbik7XG4gICAgICAgIGlmICghYnVja2V0KSBjb250aW51ZTtcbiAgICAgICAgYnVja2V0LmZlYXR1cmVzID0gW107XG4gICAgICAgIGJ1Y2tldC5uYW1lID0gYnVja2V0TmFtZTtcbiAgICAgICAgYnVja2V0c1tidWNrZXROYW1lXSA9IGJ1Y2tldDtcblxuICAgICAgICBpZiAoZGF0YS5sYXllcnMpIHtcbiAgICAgICAgICAgIC8vIHZlY3RvcnRpbGVcbiAgICAgICAgICAgIGxheWVyTmFtZSA9IGluZm9bJ3NvdXJjZS1sYXllciddO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VMYXllcnNbbGF5ZXJOYW1lXSkgc291cmNlTGF5ZXJzW2xheWVyTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyc1tsYXllck5hbWVdW2J1Y2tldE5hbWVdID0gaW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdlb2pzb24gdGlsZVxuICAgICAgICAgICAgc291cmNlTGF5ZXJzW2J1Y2tldE5hbWVdID0gaW5mbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlYWQgZWFjaCBsYXllciwgYW5kIHNvcnQgaXRzIGZlYXR1cmUncyBpbnRvIGJ1Y2tldHNcbiAgICBpZiAoZGF0YS5sYXllcnMpIHtcbiAgICAgICAgLy8gdmVjdG9ydGlsZVxuICAgICAgICBmb3IgKGxheWVyTmFtZSBpbiBzb3VyY2VMYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGRhdGEubGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSBjb250aW51ZTtcbiAgICAgICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGxheWVyLCBzb3VyY2VMYXllcnNbbGF5ZXJOYW1lXSwgYnVja2V0cyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZW9qc29uXG4gICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGRhdGEsIHNvdXJjZUxheWVycywgYnVja2V0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Y2tldHM7XG59XG5cbi8qXG4gKiBTb3J0cyBmZWF0dXJlcyBpbiBhIGxheWVyIGludG8gZGlmZmVyZW50IGJ1Y2tldHMsIGFjY29yZGluZyB0byB0aGUgbWFwaW5nXG4gKlxuICogTGF5ZXJzIGluIHZlY3RvciB0aWxlcyBjb250YWluIG1hbnkgZGlmZmVyZW50IGZlYXR1cmVzLCBhbmQgZmVhdHVyZSB0eXBlcyxcbiAqIGUuZy4gdGhlIGxhbmR1c2UgbGF5ZXIgaGFzIHBhcmtzLCBpbmR1c3RyaWFsIGJ1aWxkaW5ncywgZm9yZXN0cywgcGxheWdyb3VuZHNcbiAqIGV0Yy4gSG93ZXZlciwgd2hlbiBzdHlsaW5nLCB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZXNlIGZlYXR1cmVzIHNvIHRoYXQgd2UgY2FuXG4gKiByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IHdpdGggZGlmZmVyZW50IHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1ZlY3RvclRpbGVMYXllcn0gbGF5ZXJcbiAqIEBwYXJhbSB7TWFwcGluZ30gbWFwcGluZ1xuICovXG5mdW5jdGlvbiBzb3J0TGF5ZXJJbnRvQnVja2V0cyhsYXllciwgbWFwcGluZywgYnVja2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBsYXllci5mZWF0dXJlKGkpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgaWYgKG1hcHBpbmdba2V5XS5jb21wYXJlKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgYnVja2V0c1trZXldLmZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEdlb21ldHJ5KGZlYXR1cmUpIHtcbiAgICByZXR1cm4gZmVhdHVyZS5sb2FkR2VvbWV0cnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZShmZWF0dXJlKSB7XG4gICAgcmV0dXJuIHZ0LlZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uTG9vcDtcblxuZnVuY3Rpb24gQW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLm4gPSAwO1xuICAgIHRoaXMudGltZXMgPSBbXTtcbn1cblxuLy8gQXJlIGFsbCBhbmltYXRpb25zIGRvbmU/XG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5zdG9wcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lcyA9IHRoaXMudGltZXMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQudGltZSA+PSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiAhdGhpcy50aW1lcy5sZW5ndGg7XG59O1xuXG4vLyBBZGQgYSBuZXcgYW5pbWF0aW9uIHRoYXQgd2lsbCBydW4gdCBtaWxsaXNlY29uZHNcbi8vIFJldHVybnMgYW4gaWQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgaXQgbGF5ZXJcbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRpbWVzLnB1c2goeyBpZDogdGhpcy5uLCB0aW1lOiB0ICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9KTtcbiAgICByZXR1cm4gdGhpcy5uKys7XG59O1xuXG4vLyBDYW5jZWwgYW4gYW5pbWF0aW9uXG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy50aW1lcyA9IHRoaXMudGltZXMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQgIT0gbjtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJykuVmVjdG9yVGlsZUZlYXR1cmU7XG5cbmZ1bmN0aW9uIGluZml4KG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ICsgJyAnICsgb3BlcmF0b3IgKyAnICcgKyByaWdodDsgfTtcbn1cblxudmFyIGluZml4T3BlcmF0b3JzID0ge1xuICAgICc9PSc6IGluZml4KCc9PT0nKSxcbiAgICAnPic6IGluZml4KCc+JyksICckZ3QnOiBpbmZpeCgnPicpLFxuICAgICc8JzogaW5maXgoJzwnKSwgJyRsdCc6IGluZml4KCc8JyksXG4gICAgJzw9JzogaW5maXgoJzw9JyksICckbHRlJzogaW5maXgoJzw9JyksXG4gICAgJz49JzogaW5maXgoJz49JyksICckZ3RlJzogaW5maXgoJz49JyksXG4gICAgJyE9JzogaW5maXgoJyE9PScpLCAnJG5lJzogaW5maXgoJyE9PScpLFxuICAgICckZXhpc3RzJzogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSArICcgIT09IHVuZGVmaW5lZCc7IH1cbn07XG5cbmZ1bmN0aW9uIG9yKGl0ZW1zKSAgeyByZXR1cm4gJygnICsgaXRlbXMuam9pbignIHx8ICcpICsgJyknOyB9XG5mdW5jdGlvbiBhbmQoaXRlbXMpIHsgcmV0dXJuICcoJyArIGl0ZW1zLmpvaW4oJyAmJiAnKSArICcpJzsgfVxuZnVuY3Rpb24gbm90KGl0ZW0pICB7IHJldHVybiAnIScgKyBpdGVtOyB9XG5mdW5jdGlvbiBub3IoaXRlbXMpIHsgcmV0dXJuIG5vdChvcihpdGVtcykpOyB9XG5cbnZhciBhcnJheU9wZXJhdG9ycyA9IHtcbiAgICAnfHwnOiBvciwgJyRvcic6IG9yLFxuICAgICcmJic6IGFuZCwgJyRhbmQnOiBhbmQsXG4gICAgJyEnOiBub3IsICckbm9yJzogbm9yXG59O1xuXG52YXIgb2JqT3BlcmF0b3JzID0ge1xuICAgICchJzogbm90LCAnJG5vdCc6IG5vdFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgLy8gc2ltcGxlIGtleSAmIHZhbHVlIGNvbXBhcmlzb25cbiAgICBmdW5jdGlvbiB2YWx1ZUZpbHRlcihrZXksIHZhbHVlLCBvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gb3BlcmF0b3IoJ3BbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXScsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZXMga2V5ICYgdmFsdWUgb3Iga2V5ICYgb3IodmFsdWVzKVxuICAgIGZ1bmN0aW9uIHNpbXBsZUZpZWxkRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvcGVyYXRvckZuID0gaW5maXhPcGVyYXRvcnNbb3BlcmF0b3IgfHwgJz09J107XG4gICAgICAgIGlmICghb3BlcmF0b3JGbikgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9wZXJhdG9yOiAnICsgb3BlcmF0b3IpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yKHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZUZpbHRlcihrZXksIHYsIG9wZXJhdG9yRm4pO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIH0gZWxzZSByZXR1cm4gdmFsdWVGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3JGbik7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlcyBhbnkgZmlsdGVyIGtleS92YWx1ZSBwYWlyXG4gICAgZnVuY3Rpb24gZmllbGRGaWx0ZXIoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBhcnJheU9wZXJhdG9ycykgeyAvLyBoYW5kbGUgYW5kL29yIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheU9wZXJhdG9yc1trZXldKHZhbHVlLm1hcChmaWVsZHNGaWx0ZXIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIG5vdCBvcGVyYXRvclxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmpPcGVyYXRvcnMpIHJldHVybiBvYmpPcGVyYXRvcnNba2V5XShmaWVsZHNGaWx0ZXIodmFsdWUpKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIHtrZXk6IHtvcGVyYXRvcjogdmFsdWV9fSBub3RhdGlvblxuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHNpbXBsZUZpZWxkRmlsdGVyKGtleSwgdmFsdWVbb3BdLCBvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZChmaWx0ZXJzKTtcblxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBzaW1wbGUga2V5L3ZhbHVlIG9yIGtleS92YWx1ZXMgY29tcGFyaXNvblxuICAgICAgICByZXR1cm4gc2ltcGxlRmllbGRGaWx0ZXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHlwZUZpbHRlcih0eXBlKSB7XG4gICAgICAgIHJldHVybiAnZi50eXBlID09PSAnICsgVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMuaW5kZXhPZih0eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWVsZHNGaWx0ZXIob2JqKSB7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh0eXBlRmlsdGVyKG9ialtrZXldKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaChmaWVsZEZpbHRlcihrZXksIG9ialtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVycy5sZW5ndGggPyBhbmQoZmlsdGVycykgOiAndHJ1ZSc7XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlclN0ciA9ICd2YXIgcCA9IGYucHJvcGVydGllcyB8fCB7fTsgcmV0dXJuICcgKyBmaWVsZHNGaWx0ZXIoZmlsdGVyIHx8IHt9KSArICc7JztcblxuICAgIC8vIGpzaGludCBldmlsOiB0cnVlXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignZicsIGZpbHRlclN0cik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVmZXJlbmNlID0gcmVxdWlyZSgnbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL3Y0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbnJlZmVyZW5jZVsnY2xhc3MnXS5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBDYWxjdWxhdGVkID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgc3R5bGUgPSByZWZlcmVuY2VbY2xhc3NOYW1lXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZVtwcm9wXVsnZGVmYXVsdCddID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBDYWxjdWxhdGVkLnByb3RvdHlwZVtwcm9wXSA9IHN0eWxlW3Byb3BdWydkZWZhdWx0J107XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzW2NsYXNzTmFtZS5yZXBsYWNlKCdjbGFzc18nLCcnKV0gPSBDYWxjdWxhdGVkO1xufSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQuanMnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4LmpzJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlU3ByaXRlO1xuXG5mdW5jdGlvbiBJbWFnZVNwcml0ZShiYXNlKSB7XG5cbiAgICB2YXIgc3ByaXRlID0gdGhpcztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMucmV0aW5hID0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID4gMTtcblxuICAgIGJhc2UgPSBzcHJpdGUuYmFzZSArIChzcHJpdGUucmV0aW5hID8gJ0AyeCcgOiAnJyk7XG5cbiAgICBhamF4LmdldEpTT04oYmFzZSArICcuanNvbicsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAvLyBAVE9ETyBoYW5kbGUgZXJyb3JzIHZpYSBzcHJpdGUgZXZlbnQuXG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcbiAgICAgICAgc3ByaXRlLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAoc3ByaXRlLmltZykgc3ByaXRlLmZpcmUoJ2xvYWRlZCcpO1xuICAgIH0pO1xuXG4gICAgYWpheC5nZXRJbWFnZShiYXNlICsgJy5wbmcnLCBmdW5jdGlvbihlcnIsIGltZykge1xuICAgICAgICAvLyBAVE9ETyBoYW5kbGUgZXJyb3JzIHZpYSBzcHJpdGUgZXZlbnQuXG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgICAvLyBwcmVtdWx0aXBseSB0aGUgc3ByaXRlXG4gICAgICAgIHZhciBkYXRhID0gaW1nLmdldERhdGEoKTtcbiAgICAgICAgdmFyIG5ld2RhdGEgPSBpbWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSs9NCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gZGF0YVtpICsgM10gLyAyNTU7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAwXSA9IGRhdGFbaSArIDBdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ByaXRlLmltZyA9IGltZztcbiAgICAgICAgaWYgKHNwcml0ZS5kYXRhKSBzcHJpdGUuZmlyZSgnbG9hZGVkJyk7XG4gICAgfSk7XG59XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiYgdGhpcy5pbWcpO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdmFyIHNwcml0ZSA9IHRoaXM7XG4gICAgaWYgKGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgIT09IHNwcml0ZS5yZXRpbmEpIHtcblxuICAgICAgICB2YXIgbmV3U3ByaXRlID0gbmV3IEltYWdlU3ByaXRlKHNwcml0ZS5iYXNlKTtcbiAgICAgICAgbmV3U3ByaXRlLm9uKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgc3ByaXRlLmltZyA9IG5ld1Nwcml0ZS5pbWc7XG4gICAgICAgICAgICBzcHJpdGUuZGF0YSA9IG5ld1Nwcml0ZS5kYXRhO1xuICAgICAgICAgICAgc3ByaXRlLnJldGluYSA9IG5ld1Nwcml0ZS5yZXRpbmE7XG5cbiAgICAgICAgICAgIGlmIChzcHJpdGUudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoc3ByaXRlLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzcHJpdGUudGV4dHVyZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsLCBsaW5lYXIpIHtcbiAgICB2YXIgc3ByaXRlID0gdGhpcztcblxuICAgIGlmICghc3ByaXRlLmxvYWRlZCgpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAoIXNwcml0ZS50ZXh0dXJlKSB7XG4gICAgICAgIHNwcml0ZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzcHJpdGUudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgdmFyIGltZyA9IHNwcml0ZS5pbWc7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcuZGF0YSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzcHJpdGUudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlciA9IGxpbmVhciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgaWYgKGZpbHRlciAhPT0gc3ByaXRlLmZpbHRlcikge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcik7XG4gICAgfVxufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24obmFtZSwgcmVwZWF0aW5nKSB7XG5cbiAgICAvLyBgcmVwZWF0aW5nYCBpbmRpY2F0ZXMgdGhhdCB0aGUgaW1hZ2Ugd2lsbCBiZSB1c2VkIGluIGEgcmVwZWF0aW5nIHBhdHRlcm5cbiAgICAvLyByZXBlYXRpbmcgcGF0dGVybiBpbWFnZXMgYXJlIGFzc3VtZWQgdG8gaGF2ZSBhIDFweCBwYWRkaW5nIHRoYXQgbWlycm9ycyB0aGUgb3Bwb3NpdGUgZWRnZVxuICAgIC8vIHBvc2l0aW9ucyBmb3IgcmVwZWF0aW5nIGltYWdlcyBhcmUgYWRqdXN0ZWQgdG8gZXhjbHVkZSB0aGUgZWRnZVxuICAgIHJlcGVhdGluZyA9IHJlcGVhdGluZyA9PT0gdHJ1ZSA/IDEgOiAwO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuZGF0YSAmJiB0aGlzLmRhdGFbbmFtZV07XG4gICAgaWYgKHBvcyAmJiB0aGlzLmltZykge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmltZy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaW1nLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemU6IFtwb3Mud2lkdGggLyBwb3MucGl4ZWxSYXRpbywgcG9zLmhlaWdodCAvIHBvcy5waXhlbFJhdGlvXSxcbiAgICAgICAgICAgIHRsOiBbKHBvcy54ICsgcmVwZWF0aW5nKS8gd2lkdGgsIChwb3MueSArIHJlcGVhdGluZykgLyBoZWlnaHRdLFxuICAgICAgICAgICAgYnI6IFsocG9zLnggKyBwb3Mud2lkdGggLSAyICogcmVwZWF0aW5nKSAvIHdpZHRoLCAocG9zLnkgKyBwb3MuaGVpZ2h0IC0gMiAqIHJlcGVhdGluZykgLyBoZWlnaHRdXG4gICAgICAgIH07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92NCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5yZWZlcmVuY2UucmVuZGVyLmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIFByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBwIGluIHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gcHJvcHNbcF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSByZWZlcmVuY2VbY2xhc3NOYW1lXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXNbcHJvcF1bJ2RlZmF1bHQnXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgUHJvcGVydGllcy5wcm90b3R5cGVbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdWydkZWZhdWx0J107XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzW2NsYXNzTmFtZS5yZXBsYWNlKCdyZW5kZXJfJywnJyldID0gUHJvcGVydGllcztcbn0pO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkLmpzJyk7XG5cbnZhciBTdHlsZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3N0eWxldHJhbnNpdGlvbi5qcycpO1xudmFyIFN0eWxlRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL3N0eWxlZGVjbGFyYXRpb24uanMnKTtcbnZhciBTdHlsZUNvbnN0YW50ID0gcmVxdWlyZSgnLi9zdHlsZWNvbnN0YW50LmpzJyk7XG52YXIgQ2FsY3VsYXRlZFN0eWxlID0gcmVxdWlyZSgnLi9jYWxjdWxhdGVkc3R5bGUuanMnKTtcbnZhciBJbWFnZVNwcml0ZSA9IHJlcXVpcmUoJy4vaW1hZ2VzcHJpdGUuanMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZTtcblxuLypcbiAqIFRoZSBtYXAgc3R5bGUncyBjdXJyZW50IHN0YXRlXG4gKlxuICogVGhlIHN0eWxlc2hlZXQgb2JqZWN0IGlzIG5vdCBtb2RpZmllZC4gVG8gY2hhbmdlIHRoZSBzdHlsZSwganVzdCBjaGFuZ2VcbiAqIHRoZSB0aGUgc3R5bGVzaGVldCBvYmplY3QgYW5kIHRyaWdnZXIgYSBjYXNjYWRlLlxuICovXG5mdW5jdGlvbiBTdHlsZShzdHlsZXNoZWV0LCBhbmltYXRpb25Mb29wKSB7XG4gICAgaWYgKHN0eWxlc2hlZXQudmVyc2lvbiAhPT0gNCkgY29uc29sZS53YXJuKCdTdHlsZXNoZWV0IHZlcnNpb24gbXVzdCBiZSA0Jyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlc2hlZXQubGF5ZXJzKSkgY29uc29sZS53YXJuKCdTdHlsZXNoZWV0IG11c3QgaGF2ZSBsYXllcnMnKTtcblxuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIHRoaXMuc3R5bGVzaGVldCA9IHN0eWxlc2hlZXQ7XG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gYW5pbWF0aW9uTG9vcDtcblxuICAgIHRoaXMuYnVja2V0cyA9IHt9O1xuICAgIHRoaXMub3JkZXJlZEJ1Y2tldHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0ge307XG4gICAgdGhpcy5jb21wdXRlZCA9IHt9O1xuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgdGhpcy5jYXNjYWRlKHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xuXG4gICAgaWYgKHN0eWxlc2hlZXQuc3ByaXRlKSB0aGlzLnNldFNwcml0ZShzdHlsZXNoZWV0LnNwcml0ZSk7XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG5cbmZ1bmN0aW9uIHByZW11bHRpcGx5TGF5ZXIobGF5ZXIsIHR5cGUpIHtcbiAgICB2YXIgY29sb3JQcm9wID0gdHlwZSArICctY29sb3InLFxuICAgICAgICBoYWxvUHJvcCA9IHR5cGUgKyAnLWhhbG8tY29sb3InLFxuICAgICAgICBvdXRsaW5lUHJvcCA9IHR5cGUgKyAnLW91dGxpbmUtY29sb3InLFxuICAgICAgICBjb2xvciA9IGxheWVyW2NvbG9yUHJvcF0sXG4gICAgICAgIGhhbG9Db2xvciA9IGxheWVyW2hhbG9Qcm9wXSxcbiAgICAgICAgb3V0bGluZUNvbG9yID0gbGF5ZXJbb3V0bGluZVByb3BdLFxuICAgICAgICBvcGFjaXR5ID0gbGF5ZXJbdHlwZSArICctb3BhY2l0eSddO1xuXG4gICAgdmFyIGNvbG9yT3BhY2l0eSA9IGNvbG9yICYmIChvcGFjaXR5ICogY29sb3JbM10pO1xuICAgIHZhciBoYWxvT3BhY2l0eSA9IGhhbG9Db2xvciAmJiAob3BhY2l0eSAqIGhhbG9Db2xvclszXSk7XG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gb3V0bGluZUNvbG9yICYmIChvcGFjaXR5ICogb3V0bGluZUNvbG9yWzNdKTtcblxuICAgIGlmIChjb2xvck9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBjb2xvck9wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW2NvbG9yUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBjb2xvck9wYWNpdHldKTtcbiAgICB9XG4gICAgaWYgKGhhbG9PcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgaGFsb09wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW2hhbG9Qcm9wXSA9IHV0aWwucHJlbXVsdGlwbHkoW2hhbG9Db2xvclswXSwgaGFsb0NvbG9yWzFdLCBoYWxvQ29sb3JbMl0sIGhhbG9PcGFjaXR5XSk7XG4gICAgfVxuICAgIGlmIChvdXRsaW5lT3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG91dGxpbmVPcGFjaXR5IDwgMSkge1xuICAgICAgICBsYXllcltvdXRsaW5lUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eV0pO1xuICAgIH1cbn1cblxuLy8gRm9ybWVybHkga25vd24gYXMgem9vbWVkIHN0eWxlc1xuU3R5bGUucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24oeikge1xuICAgIGlmICh0eXBlb2YgeiAhPT0gJ251bWJlcicpIGNvbnNvbGUud2FybigncmVjYWxjdWxhdGUgZXhwZWN0cyB6b29tIGxldmVsJyk7XG5cbiAgICB2YXIgdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zO1xuICAgIHZhciBsYXllclZhbHVlcyA9IHt9O1xuXG4gICAgdGhpcy5zb3VyY2VzID0ge307XG5cbiAgICB0aGlzLnJhc3RlckZhZGVEdXJhdGlvbiA9IDMwMDtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdHJhbnNpdGlvbnNbbmFtZV0sXG4gICAgICAgICAgICBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbbGF5ZXIucmVmIHx8IG5hbWVdLFxuICAgICAgICAgICAgbGF5ZXJUeXBlID0gdGhpcy5sYXllcm1hcFtuYW1lXS50eXBlO1xuXG4gICAgICAgIGlmICghQ2FsY3VsYXRlZFN0eWxlW2xheWVyVHlwZV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndW5rbm93biBsYXllciB0eXBlICcgKyBsYXllclR5cGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFwcGxpZWRMYXllciA9IGxheWVyVmFsdWVzW25hbWVdID0gbmV3IENhbGN1bGF0ZWRTdHlsZVtsYXllclR5cGVdKCk7XG4gICAgICAgIGZvciAodmFyIHJ1bGUgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gbGF5ZXJbcnVsZV07XG4gICAgICAgICAgICBhcHBsaWVkTGF5ZXJbcnVsZV0gPSB0cmFuc2l0aW9uLmF0KHopO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGFwcGxpZWRMYXllci5oaWRkZW4gPVxuICAgICAgICAgICAgICAgIChhcHBsaWVkTGF5ZXJbJ3RleHQtb3BhY2l0eSddID09PSAwIHx8ICFidWNrZXQucmVuZGVyWyd0ZXh0LWZpZWxkJ10pICYmXG4gICAgICAgICAgICAgICAgKGFwcGxpZWRMYXllclsnaWNvbi1vcGFjaXR5J10gPT09IDAgfHwgIWJ1Y2tldC5yZW5kZXJbJ2ljb24taW1hZ2UnXSk7XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRMYXllci5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGFwcGxpZWRMYXllciwgJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGFwcGxpZWRMYXllciwgJ2ljb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGxpZWRMYXllci5oaWRkZW4gPSAoYXBwbGllZExheWVyW2xheWVyVHlwZSArICctb3BhY2l0eSddID09PSAwKTtcbiAgICAgICAgICAgIGlmICghYXBwbGllZExheWVyLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHByZW11bHRpcGx5TGF5ZXIoYXBwbGllZExheWVyLCBsYXllclR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIHNvdXJjZXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHVzZWRcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gYXV0b21hdGljYWxseSBlbmFibGUvZGlzYWJsZSB0aGVtIGFzIG5lZWRlZFxuICAgICAgICBpZiAoIWFwcGxpZWRMYXllci5oaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBidWNrZXQgJiYgYnVja2V0LnNvdXJjZTtcblxuICAgICAgICAgICAgLy8gbWFyayBzb3VyY2UgYXMgdXNlZCBzbyB0aGF0IHRpbGVzIGFyZSBkb3dubG9hZGVkXG4gICAgICAgICAgICBpZiAoc291cmNlKSB0aGlzLnNvdXJjZXNbc291cmNlXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXBwbGllZExheWVyWydyYXN0ZXItZmFkZSddKSB7XG4gICAgICAgICAgICB0aGlzLnJhc3RlckZhZGVEdXJhdGlvbiA9IE1hdGgubWF4KHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uLCBhcHBsaWVkTGF5ZXJbJ3Jhc3Rlci1mYWRlJ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wdXRlZCA9IGxheWVyVmFsdWVzO1xuXG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbn07XG5cblN0eWxlLnByb3RvdHlwZS5fc2ltcGxlTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBzaW1wbGUgPSB7fTtcbiAgICBzaW1wbGUuaWQgPSBsYXllci5pZDtcblxuICAgIHZhciBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICBpZiAoYnVja2V0KSBzaW1wbGUuYnVja2V0ID0gYnVja2V0LmlkO1xuICAgIGlmIChsYXllci50eXBlKSBzaW1wbGUudHlwZSA9IGxheWVyLnR5cGU7XG5cbiAgICBpZiAobGF5ZXIubGF5ZXJzKSB7XG4gICAgICAgIHNpbXBsZS5sYXllcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpbXBsZS5sYXllcnMucHVzaCh0aGlzLl9zaW1wbGVMYXllcihsYXllci5sYXllcnNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlO1xufTtcblxuLy8gU3BsaXQgdGhlIGxheWVycyBpbnRvIGdyb3VwcyBvZiBjb25zZWN1dGl2ZSBsYXllcnMgd2l0aCB0aGUgc2FtZSBkYXRhc291cmNlXG5TdHlsZS5wcm90b3R5cGUuX2dyb3VwTGF5ZXJzID0gZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgdmFyIGcgPSAwO1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICB2YXIgZ3JvdXA7XG5cbiAgICAvLyBsb29wIG92ZXIgbGF5ZXJzIHRvcCBkb3duXG4gICAgZm9yICh2YXIgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgICAgdmFyIGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgICAgICB2YXIgc291cmNlID0gYnVja2V0ICYmIGJ1Y2tldC5zb3VyY2U7XG5cbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGF5ZXIgaXMgaW4gYSBkaWZmZXJlbnQgc291cmNlXG4gICAgICAgIGlmIChncm91cCAmJiBzb3VyY2UgIT09IGdyb3VwLnNvdXJjZSkgZysrO1xuXG4gICAgICAgIGlmICghZ3JvdXBzW2ddKSB7XG4gICAgICAgICAgICBncm91cCA9IFtdO1xuICAgICAgICAgICAgZ3JvdXAuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgZ3JvdXBzW2ddID0gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5wdXNoKHRoaXMuX3NpbXBsZUxheWVyKGxheWVyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3Vwcztcbn07XG5cbi8qXG4gKiBUYWtlIGFsbCB0aGUgcnVsZXMgYW5kIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBzdHlsZXNoZWV0LFxuICogYW5kIGZpZ3VyZSBvdXQgd2hpY2ggYXBwbHkgY3VycmVudGx5XG4gKi9cblN0eWxlLnByb3RvdHlwZS5jYXNjYWRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICB2YXIgYSwgYjtcbiAgICB2YXIgaWQ7XG4gICAgdmFyIHByb3A7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciBjbGFzc05hbWU7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIHN0eWxlVHJhbnM7XG4gICAgdmFyIGNvbnN0YW50cyA9IHRoaXMuc3R5bGVzaGVldC5jb25zdGFudHM7XG5cbiAgICAvLyBkZXJpdmUgYnVja2V0cyBmcm9tIGxheWVyc1xuICAgIHRoaXMub3JkZXJlZEJ1Y2tldHMgPSBbXTtcbiAgICB0aGlzLmJ1Y2tldHMgPSBnZXRidWNrZXRzKHt9LCB0aGlzLm9yZGVyZWRCdWNrZXRzLCB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcbiAgICBmdW5jdGlvbiBnZXRidWNrZXRzKGJ1Y2tldHMsIG9yZGVyZWQsIGxheWVycykge1xuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGxheWVycy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2FdO1xuICAgICAgICAgICAgaWYgKGxheWVyLmxheWVycykge1xuICAgICAgICAgICAgICAgIGJ1Y2tldHMgPSBnZXRidWNrZXRzKGJ1Y2tldHMsIG9yZGVyZWQsIGxheWVyLmxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxheWVyLnNvdXJjZSB8fCAhbGF5ZXIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IHsgaWQ6IGxheWVyLmlkIH07XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgvXnN0eWxlLykudGVzdChwcm9wKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgYnVja2V0W3Byb3BdID0gbGF5ZXJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWNrZXQucmVuZGVyID0gU3R5bGVDb25zdGFudC5yZXNvbHZlKGJ1Y2tldC5yZW5kZXIsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBidWNrZXRzW2xheWVyLmlkXSA9IGJ1Y2tldDtcbiAgICAgICAgICAgIG9yZGVyZWQucHVzaChidWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWNrZXRzO1xuICAgIH1cblxuICAgIC8vIHN0eWxlIGNsYXNzIGtleXNcbiAgICB2YXIgc3R5bGVOYW1lcyA9IFsnc3R5bGUnXTtcbiAgICBmb3IgKGNsYXNzTmFtZSBpbiB0aGlzLmNsYXNzZXMpIHN0eWxlTmFtZXMucHVzaCgnc3R5bGUuJyArIGNsYXNzTmFtZSk7XG5cbiAgICAvLyBhcHBseSBsYXllciBncm91cCBpbmhlcml0YW5jZSByZXN1bHRpbmcgaW4gYSBmbGF0dGVuZWQgYXJyYXlcbiAgICB2YXIgZmxhdHRlbmVkID0gZmxhdHRlbkxheWVycyh0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcblxuICAgIC8vIG1hcCBsYXllciBpZHMgdG8gbGF5ZXIgZGVmaW5pdGlvbnMgZm9yIHJlc29sdmluZyByZWZzXG4gICAgdmFyIGxheWVybWFwID0gdGhpcy5sYXllcm1hcCA9IHt9O1xuICAgIGZvciAoYSA9IDA7IGEgPCBmbGF0dGVuZWQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgbGF5ZXIgPSBmbGF0dGVuZWRbYV07XG5cbiAgICAgICAgdmFyIG5ld0xheWVyID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAnbGF5ZXJzJykgY29udGludWU7XG4gICAgICAgICAgICBuZXdMYXllcltrXSA9IGxheWVyW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5ZXJtYXBbbGF5ZXIuaWRdID0gbmV3TGF5ZXI7XG4gICAgICAgIGZsYXR0ZW5lZFthXSA9IG5ld0xheWVyO1xuICAgIH1cblxuICAgIGZvciAoYSA9IDA7IGEgPCBmbGF0dGVuZWQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgZmxhdHRlbmVkW2FdID0gcmVzb2x2ZUxheWVyKGxheWVybWFwLCBmbGF0dGVuZWRbYV0pO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgbGF5ZXIgcmVmZXJlbmNlcy5cbiAgICBmdW5jdGlvbiByZXNvbHZlTGF5ZXIobGF5ZXJtYXAsIGxheWVyKSB7XG4gICAgICAgIGlmICghbGF5ZXIucmVmIHx8ICFsYXllcm1hcFtsYXllci5yZWZdKSByZXR1cm4gbGF5ZXI7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHJlc29sdmVMYXllcihsYXllcm1hcCwgbGF5ZXJtYXBbbGF5ZXIucmVmXSk7XG4gICAgICAgIGxheWVyLnJlbmRlciA9IHBhcmVudC5yZW5kZXI7XG4gICAgICAgIGxheWVyLnR5cGUgPSBwYXJlbnQudHlwZTtcbiAgICAgICAgbGF5ZXIuZmlsdGVyID0gcGFyZW50LmZpbHRlcjtcbiAgICAgICAgbGF5ZXIuc291cmNlID0gcGFyZW50LnNvdXJjZTtcbiAgICAgICAgbGF5ZXJbJ3NvdXJjZS1sYXllciddID0gcGFyZW50Wydzb3VyY2UtbGF5ZXInXTtcbiAgICAgICAgbGF5ZXJbJ21pbi16b29tJ10gPSBwYXJlbnRbJ21pbi16b29tJ107XG4gICAgICAgIGxheWVyWydtYXgtem9vbSddID0gcGFyZW50WydtYXgtem9vbSddO1xuXG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cbiAgICAvLyBGbGF0dGVuIGNvbXBvc2l0ZSBsYXllciBzdHJ1Y3R1cmVzLlxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5MYXllcnMobGF5ZXJzKSB7XG4gICAgICAgIHZhciBmbGF0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmbGF0LnB1c2gobGF5ZXJzW2ldKTtcbiAgICAgICAgICAgIGlmIChsYXllcnNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgZmxhdC5wdXNoLmFwcGx5KGZsYXQsIGZsYXR0ZW5MYXllcnMobGF5ZXJzW2ldLmxheWVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0O1xuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9ucyA9IHt9O1xuICAgIHZhciBnbG9iYWxUcmFucyA9IHRoaXMuc3R5bGVzaGVldC50cmFuc2l0aW9uO1xuXG4gICAgZm9yIChhIGluIGZsYXR0ZW5lZCkge1xuICAgICAgICBsYXllciA9IGZsYXR0ZW5lZFthXTtcblxuICAgICAgICBpZCA9IGxheWVyLmlkO1xuICAgICAgICBzdHlsZSA9IHt9O1xuICAgICAgICBzdHlsZVRyYW5zID0ge307XG5cbiAgICAgICAgLy8gYmFzaWMgY2FzY2FkaW5nIG9mIHN0eWxlc1xuICAgICAgICBmb3IgKGIgPSAwOyBiIDwgc3R5bGVOYW1lcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVOYW1lc1tiXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXJbc3R5bGVOYW1lXSkgY29udGludWU7XG4gICAgICAgICAgICAvLyBzZXQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yIChwcm9wIGluIGxheWVyW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKCd0cmFuc2l0aW9uLScpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVtwcm9wXSA9IGxheWVyW3N0eWxlTmFtZV1bcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUcmFuc1twcm9wLnJlcGxhY2UoJ3RyYW5zaXRpb24tJywgJycpXSA9IGxheWVyW3N0eWxlTmFtZV1bcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUgPSBTdHlsZUNvbnN0YW50LnJlc29sdmUoc3R5bGUsIGNvbnN0YW50cyk7XG5cbiAgICAgICAgdmFyIHJlbmRlclR5cGUgPSBsYXllci50eXBlO1xuICAgICAgICB0cmFuc2l0aW9uc1tpZF0gPSB7fTtcblxuICAgICAgICBmb3IgKHByb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWNsYXJhdGlvbiA9IG5ldyBTdHlsZURlY2xhcmF0aW9uKHJlbmRlclR5cGUsIHByb3AsIHN0eWxlW3Byb3BdKTtcbiAgICAgICAgICAgIHZhciBvbGRUcmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uc1tpZF0gJiYgdGhpcy50cmFuc2l0aW9uc1tpZF1bcHJvcF07XG4gICAgICAgICAgICB2YXIgbmV3U3R5bGVUcmFucyA9IHt9O1xuICAgICAgICAgICAgbmV3U3R5bGVUcmFucy5kdXJhdGlvbiA9IHN0eWxlVHJhbnNbcHJvcF0gJiYgc3R5bGVUcmFuc1twcm9wXS5kdXJhdGlvbiA/IHN0eWxlVHJhbnNbcHJvcF0uZHVyYXRpb24gOiBnbG9iYWxUcmFucyAmJiBnbG9iYWxUcmFucy5kdXJhdGlvbiA/IGdsb2JhbFRyYW5zLmR1cmF0aW9uIDogMzAwO1xuICAgICAgICAgICAgbmV3U3R5bGVUcmFucy5kZWxheSA9IHN0eWxlVHJhbnNbcHJvcF0gJiYgc3R5bGVUcmFuc1twcm9wXS5kZWxheSA/IHN0eWxlVHJhbnNbcHJvcF0uZGVsYXkgOiBnbG9iYWxUcmFucyAmJiBnbG9iYWxUcmFucy5kZWxheSA/IGdsb2JhbFRyYW5zLmRlbGF5IDogMDtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZVRyYW5zLmR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZVRyYW5zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBjcmVhdGUgYSBuZXcgdHJhbnNpdGlvbiBpZiB0aGUgZGVjbGFyYXRpb24gY2hhbmdlZFxuICAgICAgICAgICAgaWYgKCFvbGRUcmFuc2l0aW9uIHx8IG9sZFRyYW5zaXRpb24uZGVjbGFyYXRpb24uanNvbiAhPT0gbmV3RGVjbGFyYXRpb24uanNvbikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdUcmFuc2l0aW9uID0gbmV3IFN0eWxlVHJhbnNpdGlvbihuZXdEZWNsYXJhdGlvbiwgb2xkVHJhbnNpdGlvbiwgbmV3U3R5bGVUcmFucyk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnNbaWRdW3Byb3BdID0gbmV3VHJhbnNpdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgYW5pbWF0aW9uIGxvb3AgdW50aWwgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIGlmICghbmV3VHJhbnNpdGlvbi5pbnN0YW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNpdGlvbi5sb29wSUQgPSB0aGlzLmFuaW1hdGlvbkxvb3Auc2V0KG5ld1RyYW5zaXRpb24uZW5kVGltZSAtIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvbGRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5jYW5jZWwob2xkVHJhbnNpdGlvbi5sb29wSUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnNbaWRdW3Byb3BdID0gb2xkVHJhbnNpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgICB0aGlzLmxheWVyR3JvdXBzID0gdGhpcy5fZ3JvdXBMYXllcnModGhpcy5zdHlsZXNoZWV0LmxheWVycyk7XG5cbiAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xufTtcblxuLyogVGhpcyBzaG91bGQgYmUgbW92ZWQgZWxzZXdoZXJlLiBMb2NhbGl6aW5nIHJlc291cmNlcyBkb2Vzbid0IGJlbG9uZyBoZXJlICovXG5TdHlsZS5wcm90b3R5cGUuc2V0U3ByaXRlID0gZnVuY3Rpb24oc3ByaXRlKSB7XG4gICAgdGhpcy5zcHJpdGUgPSBuZXcgSW1hZ2VTcHJpdGUoc3ByaXRlKTtcbiAgICB0aGlzLnNwcml0ZS5vbignbG9hZGVkJywgdGhpcy5maXJlLmJpbmQodGhpcywgJ2NoYW5nZScpKTtcbn07XG5cbi8vIE1vZGlmeSBjbGFzc2VzXG5TdHlsZS5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbihuLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuY2xhc3Nlc1tuXSkgcmV0dXJuOyAvLyBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25cbiAgICB0aGlzLmNsYXNzZXNbbl0gPSB0cnVlO1xuICAgIHRoaXMuY2FzY2FkZShvcHRpb25zKTtcbn07XG5cblN0eWxlLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKG4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2xhc3Nlc1tuXSkgcmV0dXJuOyAvLyBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25cbiAgICBkZWxldGUgdGhpcy5jbGFzc2VzW25dO1xuICAgIHRoaXMuY2FzY2FkZShvcHRpb25zKTtcbn07XG5cblN0eWxlLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gISF0aGlzLmNsYXNzZXNbbl07XG59O1xuXG5TdHlsZS5wcm90b3R5cGUuc2V0Q2xhc3NMaXN0ID0gZnVuY3Rpb24obCwgb3B0aW9ucykge1xuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmNsYXNzZXNbbFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNhc2NhZGUob3B0aW9ucyk7XG59O1xuXG5TdHlsZS5wcm90b3R5cGUuZ2V0Q2xhc3NMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY2xhc3Nlcyk7XG59O1xuXG5TdHlsZS5wcm90b3R5cGUuZ2V0TGF5ZXIgPSBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLmxheWVybWFwW2lkXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbiAocHJvcGVydGllcywgY29uc3RhbnRzKSB7XG4gICAgaWYgKCFjb25zdGFudHMpXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuXG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnID8gY29uc3RhbnRzW3ZhbHVlXSA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmUocHJvcGVydGllc1trZXldKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldIGluIGNvbnN0YW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlc29sdmUodmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5zdG9wcykge1xuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLmV4dGVuZCh7fSwgdmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUuc3RvcHMgPSB2YWx1ZS5zdG9wcy5zbGljZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3RvcHNbaV1bMV0gaW4gY29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnN0b3BzW2ldID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wc1tpXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUuc3RvcHNbaV1bMV0pXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcbiAgICByZWZlcmVuY2UgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvdjQnKSxcbiAgICBwYXJzZUNTU0NvbG9yID0gcmVxdWlyZSgnY3NzY29sb3JwYXJzZXInKS5wYXJzZUNTU0NvbG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlRGVjbGFyYXRpb247XG5cbi8qXG4gKiBBIHBhcnNlZCByZXByZXNlbnRhdGlvbiBvZiBhIHByb3BlcnR5OnZhbHVlIHBhaXJcbiAqL1xuZnVuY3Rpb24gU3R5bGVEZWNsYXJhdGlvbihyZW5kZXJUeXBlLCBwcm9wLCB2YWx1ZSkge1xuICAgIHZhciBjbGFzc05hbWUgPSAnY2xhc3NfJyArIHJlbmRlclR5cGU7XG4gICAgdmFyIHByb3BSZWZlcmVuY2UgPSByZWZlcmVuY2VbY2xhc3NOYW1lXSAmJiByZWZlcmVuY2VbY2xhc3NOYW1lXVtwcm9wXTtcbiAgICBpZiAoIXByb3BSZWZlcmVuY2UpIHJldHVybjtcblxuICAgIHRoaXMudmFsdWUgPSB0aGlzLnBhcnNlVmFsdWUodmFsdWUsIHByb3BSZWZlcmVuY2UudHlwZSwgcHJvcFJlZmVyZW5jZS52YWx1ZXMpO1xuICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgdGhpcy50eXBlID0gcHJvcFJlZmVyZW5jZS50eXBlO1xuXG4gICAgLy8gaW1tdWF0YWJsZSByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZS4gdXNlZCBmb3IgY29tcGFyaXNvblxuICAgIHRoaXMuanNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblxufVxuXG5TdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbih6KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAnZnVuY3Rpb24nID8gdGhpcy52YWx1ZSh6KSA6IHRoaXMudmFsdWU7XG59O1xuXG5TdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5wYXJzZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIHZhbHVlcykge1xuICAgIGlmICh0eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNvbG9yKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXJBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZW51bScgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih0eXBlICsgJyBpcyBub3QgYSBzdXBwb3J0ZWQgcHJvcGVydHkgdHlwZScpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKG51bSkge1xuICAgIGlmIChudW0uc3RvcHMpIG51bSA9IHN0b3BzRm4obnVtKTtcbiAgICB2YXIgdmFsdWUgPSArbnVtO1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUpID8gdmFsdWUgOiBudW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyQXJyYXkoYXJyYXkpIHtcbiAgICB2YXIgd2lkdGhzID0gYXJyYXkubWFwKHBhcnNlTnVtYmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGVvZiB3aWR0aHNbaV0gPT09ICdmdW5jdGlvbicgPyB3aWR0aHNbaV0oeikgOiB3aWR0aHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxudmFyIGNvbG9yQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gcGFyc2VDb2xvcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5zdG9wcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgcGFyc2VkIGNvbG9yIGFzIHRoZSAzcmQgZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhbHVlLnN0b3BzW2ldWzJdID0gcGFyc2VDU1NDb2xvcih2YWx1ZS5zdG9wc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3BzRm4odmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChjb2xvckNhY2hlW3ZhbHVlXSkge1xuICAgICAgICByZXR1cm4gY29sb3JDYWNoZVt2YWx1ZV07XG4gICAgfVxuICAgIHZhciBjb2xvciA9IHByZXBhcmVDb2xvcihwYXJzZUNTU0NvbG9yKHZhbHVlKSk7XG4gICAgY29sb3JDYWNoZVt2YWx1ZV0gPSBjb2xvcjtcbiAgICByZXR1cm4gY29sb3I7XG59XG5cbmZ1bmN0aW9uIHN0b3BzRm4ocGFyYW1zLCBjb2xvcikge1xuICAgIHZhciBzdG9wcyA9IHBhcmFtcy5zdG9wcztcbiAgICB2YXIgYmFzZSA9IHBhcmFtcy5iYXNlIHx8IHJlZmVyZW5jZS5mdW5jdGlvbi5iYXNlLmRlZmF1bHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHR3byBzdG9wcyB3aGljaCB0aGUgY3VycmVudCB6IGlzIGJldHdlZW5cbiAgICAgICAgdmFyIGxvdyA9IG51bGw7XG4gICAgICAgIHZhciBoaWdoID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgIGlmIChzdG9wWzBdIDw9IHopIGxvdyA9IHN0b3A7XG4gICAgICAgICAgICBpZiAoc3RvcFswXSA+IHopIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gc3RvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb3cgJiYgaGlnaCkge1xuICAgICAgICAgICAgdmFyIHpvb21EaWZmID0gaGlnaFswXSAtIGxvd1swXTtcbiAgICAgICAgICAgIHZhciB6b29tUHJvZ3Jlc3MgPSB6IC0gbG93WzBdO1xuICAgICAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICAgICAgaWYgKGJhc2UgPT0gMSkge1xuICAgICAgICAgICAgICAgIHQgPSB6b29tUHJvZ3Jlc3MgLyB6b29tRGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9IChNYXRoLnBvdyhiYXNlLCB6b29tUHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgem9vbURpZmYpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sb3IpIHJldHVybiBwcmVwYXJlQ29sb3IoaW50ZXJwQ29sb3IobG93WzJdLCBoaWdoWzJdLCB0KSk7XG4gICAgICAgICAgICBlbHNlIHJldHVybiB1dGlsLmludGVycChsb3dbMV0sIGhpZ2hbMV0sIHQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobG93KSB7XG4gICAgICAgICAgICBpZiAoY29sb3IpIHJldHVybiBwcmVwYXJlQ29sb3IobG93WzJdKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGxvd1sxXTtcblxuICAgICAgICB9IGVsc2UgaWYgKGhpZ2gpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcikgcmV0dXJuIHByZXBhcmVDb2xvcihoaWdoWzJdKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGhpZ2hbMV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb2xvcikgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29sb3IoYykge1xuICAgIHJldHVybiBbY1swXSAvIDI1NSwgY1sxXSAvIDI1NSwgY1syXSAvIDI1NSwgY1szXSAvIDFdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBDb2xvcihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgdXRpbC5pbnRlcnAoZnJvbVsxXSwgdG9bMV0sIHQpLFxuICAgICAgICB1dGlsLmludGVycChmcm9tWzJdLCB0b1syXSwgdCksXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bM10sIHRvWzNdLCB0KVxuICAgIF07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVUcmFuc2l0aW9uO1xuXG4vKlxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gZGVjbGFyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIFN0eWxlVHJhbnNpdGlvbihkZWNsYXJhdGlvbiwgb2xkVHJhbnNpdGlvbiwgdmFsdWUpIHtcblxuICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuZW5kVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICB2YXIgdHlwZSA9IGRlY2xhcmF0aW9uLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gdXRpbC5pbnRlcnA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwQ29sb3I7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwTnVtYmVyQXJyYXk7XG4gICAgfVxuXG4gICAgdGhpcy5vbGRUcmFuc2l0aW9uID0gb2xkVHJhbnNpdGlvbjtcbiAgICB0aGlzLmR1cmF0aW9uID0gdmFsdWUuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLmRlbGF5ID0gdmFsdWUuZGVsYXkgfHwgMDtcblxuICAgIGlmICghdGhpcy5pbnN0YW50KCkpIHtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWUgKyB0aGlzLmR1cmF0aW9uICsgdGhpcy5kZWxheTtcbiAgICAgICAgdGhpcy5lYXNlID0gdXRpbC5lYXNlQ3ViaWNJbk91dDtcbiAgICB9XG5cbiAgICBpZiAob2xkVHJhbnNpdGlvbiAmJiBvbGRUcmFuc2l0aW9uLmVuZFRpbWUgPD0gdGhpcy5zdGFydFRpbWUpIHtcbiAgICAgICAgLy8gT2xkIHRyYW5zaXRpb24gaXMgZG9uZSBydW5uaW5nLCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gZGVsZXRlIGl0cyByZWZlcmVuY2UgdG8gaXRzIG9sZCB0cmFuc2l0aW9uLlxuXG4gICAgICAgIGRlbGV0ZSBvbGRUcmFuc2l0aW9uLm9sZFRyYW5zaXRpb247XG4gICAgfVxufVxuXG5TdHlsZVRyYW5zaXRpb24ucHJvdG90eXBlLmluc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMub2xkVHJhbnNpdGlvbiB8fCAhdGhpcy5pbnRlcnAgfHwgKHRoaXMuZHVyYXRpb24gPT09IDAgJiYgdGhpcy5kZWxheSA9PT0gMCk7XG59O1xuXG4vKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgdHJhbnNpdGlvbmluZyBwcm9wZXJ0eSBhdCB6b29tIGxldmVsIGB6YCBhbmQgb3B0aW9uYWwgdGltZSBgdGBcbiAqL1xuU3R5bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKHosIHQpIHtcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZGVjbGFyYXRpb24uY2FsY3VsYXRlKHopO1xuXG4gICAgaWYgKHRoaXMuaW5zdGFudCgpKSByZXR1cm4gdmFsdWU7XG5cbiAgICB0ID0gdCB8fCBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHQgPCB0aGlzLmVuZFRpbWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5vbGRUcmFuc2l0aW9uLmF0KHosIHRoaXMuc3RhcnRUaW1lKTtcbiAgICAgICAgdmFyIGVhc2VkID0gdGhpcy5lYXNlKCh0IC0gdGhpcy5zdGFydFRpbWUgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJwKG9sZFZhbHVlLCB2YWx1ZSwgZWFzZWQpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcblxufTtcblxuZnVuY3Rpb24gaW50ZXJwTnVtYmVyQXJyYXkoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gdXRpbC5pbnRlcnAoZCwgdG9baV0sIHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBDb2xvcihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgdXRpbC5pbnRlcnAoZnJvbVsxXSwgdG9bMV0sIHQpLFxuICAgICAgICB1dGlsLmludGVycChmcm9tWzJdLCB0b1syXSwgdCksXG4gICAgICAgIHV0aWwuaW50ZXJwKGZyb21bM10sIHRvWzNdLCB0KVxuICAgIF07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yO1xuXG5mdW5jdGlvbiBBbmNob3IoeCwgeSwgYW5nbGUsIHNjYWxlLCBzZWdtZW50KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAoc2VnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxufVxuXG5BbmNob3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb2ludC5wcm90b3R5cGUpO1xuXG5BbmNob3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcy54LCB0aGlzLnksIHRoaXMuYW5nbGUsIHRoaXMuc2NhbGUsIHRoaXMuc2VnbWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpblBhY2s7XG5mdW5jdGlvbiBCaW5QYWNrKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5mcmVlID0gW3sgeDogMCwgeTogMCwgdzogd2lkdGgsIGg6IGhlaWdodCB9XTtcbn1cblxuQmluUGFjay5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAvLyBTaW1wbGUgYWxnb3JpdGhtIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBuZXdseSByZWxlYXNlZCBjZWxsIHdpdGggaXRzXG4gICAgLy8gbmVpZ2hib3IuIFRoaXMgZG9lc24ndCBtZXJnZSBtb3JlIHRoYW4gdHdvIGNlbGxzIGF0IGEgdGltZSwgYW5kIGZhaWxzXG4gICAgLy8gZm9yIGNvbXBsaWNhdGVkIG1lcmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJlZSA9IHRoaXMuZnJlZVtpXTtcbiAgICAgICAgaWYgKGZyZWUueSA9PSByZWN0LnkgJiYgZnJlZS5oID09IHJlY3QuaCAmJiBmcmVlLnggKyBmcmVlLncgPT0gcmVjdC54KSB7XG4gICAgICAgICAgICBmcmVlLncgKz0gcmVjdC53O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyZWUueCA9PSByZWN0LnggJiYgZnJlZS53ID09IHJlY3QudyAmJiBmcmVlLnkgKyBmcmVlLmggPT0gcmVjdC55KSB7XG4gICAgICAgICAgICBmcmVlLmggKz0gcmVjdC5oO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlY3QueSA9PSBmcmVlLnkgJiYgcmVjdC5oID09IGZyZWUuaCAmJiByZWN0LnggKyByZWN0LncgPT0gZnJlZS54KSB7XG4gICAgICAgICAgICBmcmVlLnggPSByZWN0Lng7XG4gICAgICAgICAgICBmcmVlLncgKz0gcmVjdC53O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlY3QueCA9PSBmcmVlLnggJiYgcmVjdC53ID09IGZyZWUudyAmJiByZWN0LnkgKyByZWN0LmggPT0gZnJlZS55KSB7XG4gICAgICAgICAgICBmcmVlLnkgPSByZWN0Lnk7XG4gICAgICAgICAgICBmcmVlLmggKz0gcmVjdC5oO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyZWUuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnJlbGVhc2UoZnJlZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgIH1cbiAgICB0aGlzLmZyZWUucHVzaChyZWN0KTtcbn07XG5cbkJpblBhY2sucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGZyZWUgcmVjdCBhbmdsZVxuICAgIHZhciByZWN0ID0geyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHc6IEluZmluaXR5LCBoOiBJbmZpbml0eSB9O1xuICAgIHZhciBzbWFsbGVzdCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmZyZWVbaV07XG4gICAgICAgIGlmICh3aWR0aCA8PSByZWYudyAmJiBoZWlnaHQgPD0gcmVmLmggJiYgcmVmLnkgPD0gcmVjdC55ICYmIHJlZi54IDw9IHJlY3QueCkge1xuICAgICAgICAgICAgcmVjdCA9IHJlZjtcbiAgICAgICAgICAgIHNtYWxsZXN0ID0gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzbWFsbGVzdCA8IDApIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBzcGFjZSBsZWZ0IGZvciB0aGlzIGNoYXIuXG4gICAgICAgIHJldHVybiB7IHg6IC0xLCB5OiAtMSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJlZS5zcGxpY2Uoc21hbGxlc3QsIDEpO1xuXG4gICAgICAgIC8vIFNob3J0ZXIvTG9uZ2VyIEF4aXMgU3BsaXQgUnVsZSAoU0FTKVxuICAgICAgICAvLyBodHRwOi8vY2xiLmRlbW9uLmZpL2ZpbGVzL1JlY3RhbmdsZUJpblBhY2sucGRmIHAuIDE1XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZGltZW5zaW9uIG9mIFIgYW5kIGp1c3Qgc3BsaXQgbG9uZyB0aGUgc2hvcnRlciBkaW1lbnNpb25cbiAgICAgICAgLy8gU2VlIEFsc286IGh0dHA6Ly93d3cuY3MucHJpbmNldG9uLmVkdS9+Y2hhemVsbGUvcHVicy9ibGJpbnBhY2tpbmcucGRmXG4gICAgICAgIGlmIChyZWN0LncgPCByZWN0LmgpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IGhvcml6b250YWxseVxuICAgICAgICAgICAgLy8gKy0tKy0tLStcbiAgICAgICAgICAgIC8vIHxfX3xfX198ICA8LS0gYjFcbiAgICAgICAgICAgIC8vICstLS0tLS0rICA8LS0gYjJcbiAgICAgICAgICAgIGlmIChyZWN0LncgPiB3aWR0aCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LnggKyB3aWR0aCwgeTogcmVjdC55LCB3OiByZWN0LncgLSB3aWR0aCwgaDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgaWYgKHJlY3QuaCA+IGhlaWdodCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LngsIHk6IHJlY3QueSArIGhlaWdodCwgdzogcmVjdC53LCBoOiByZWN0LmggLSBoZWlnaHQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAvLyArLS0rLS0tK1xuICAgICAgICAgICAgLy8gfF9ffCAgIHwgPC0tIGIxXG4gICAgICAgICAgICAvLyArLS18LS0tKyA8LS0gYjJcbiAgICAgICAgICAgIGlmIChyZWN0LncgPiB3aWR0aCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LnggKyB3aWR0aCwgeTogcmVjdC55LCB3OiByZWN0LncgLSB3aWR0aCwgaDogcmVjdC5oIH0pO1xuICAgICAgICAgICAgaWYgKHJlY3QuaCA+IGhlaWdodCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LngsIHk6IHJlY3QueSArIGhlaWdodCwgdzogd2lkdGgsIGg6IHJlY3QuaCAtIGhlaWdodCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHg6IHJlY3QueCwgeTogcmVjdC55LCB3OiB3aWR0aCwgaDogaGVpZ2h0IH07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJidXNoID0gcmVxdWlyZSgncmJ1c2gnKSxcbiAgICByb3RhdGlvblJhbmdlID0gcmVxdWlyZSgnLi9yb3RhdGlvbnJhbmdlLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbjtcblxuZnVuY3Rpb24gQ29sbGlzaW9uKHpvb20sIHRpbGVFeHRlbnQsIHRpbGVTaXplLCBwbGFjZW1lbnREZXB0aCkge1xuICAgIHRoaXMuaFRyZWUgPSByYnVzaCgpOyAvLyB0cmVlIGZvciBob3Jpem9udGFsIGxhYmVsc1xuICAgIHRoaXMuY1RyZWUgPSByYnVzaCgpOyAvLyB0cmVlIGZvciBnbHlwaHMgZnJvbSBjdXJ2ZWQgbGFiZWxzXG5cbiAgICAvLyB0aWxlIHBpeGVscyBwZXIgc2NyZWVuIHBpeGVscyBhdCB0aGUgdGlsZSdzIHpvb20gbGV2ZWxcbiAgICB0aGlzLnRpbGVQaXhlbFJhdGlvID0gdGlsZUV4dGVudCAvIHRpbGVTaXplO1xuXG4gICAgdGhpcy56b29tID0gem9vbTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBzY2FsZSB3ZSBjYW4gZ28gZG93biBpbiBvdXIgZmFrZS0zZCBydHJlZSBzbyB0aGF0XG4gICAgLy8gcGxhY2VtZW50IHN0aWxsIG1ha2VzIHNlbnNlLiBUaGlzIGlzIGNhbGN1bGF0ZWQgc28gdGhhdCB0aGUgbWluaW11bVxuICAgIC8vIHBsYWNlbWVudCB6b29tIGNhbiBiZSBhdCBtb3N0IDI1LjUgKHdlIHVzZSBhbiB1bnNpZ25lZCBpbnRlZ2VyIHgxMCB0b1xuICAgIC8vIHN0b3JlIHRoZSBtaW5pbXVtIHpvb20pLlxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBwbGFjZSBsYWJlbHMgYWxsIHRoZSB3YXkgdG8gMjUuNS4gVGhpcyBsZXRzIHRvbyBtYW55XG4gICAgLy8gZ2x5cGhzIGJlIHBsYWNlZCwgc2xvd2luZyBkb3duIGNvbGxpc2lvbiBjaGVja2luZy4gT25seSBwbGFjZSBsYWJlbHMgaWZcbiAgICAvLyB0aGV5IHdpbGwgc2hvdyB1cCB3aXRoaW4gdGhlIGludGVuZGVkIHpvb20gcmFuZ2Ugb2YgdGhlIHRpbGUuXG4gICAgcGxhY2VtZW50RGVwdGggPSBNYXRoLm1pbigzLCBwbGFjZW1lbnREZXB0aCB8fCAxLCAyNS41IC0gdGhpcy56b29tKTtcbiAgICB0aGlzLm1heFBsYWNlbWVudFNjYWxlID0gTWF0aC5leHAoTWF0aC5MTjIgKiBwbGFjZW1lbnREZXB0aCk7XG5cbiAgICB2YXIgbSA9IDQwOTY7XG4gICAgdmFyIGVkZ2UgPSBtICogdGhpcy50aWxlUGl4ZWxSYXRpbyAqIDI7XG5cbiAgICB2YXIgZnVsbFJhbmdlID0gW01hdGguUEkgKiAyLCAwXTtcblxuICAgIHRoaXMubGVmdCA9IHtcbiAgICAgICAgYW5jaG9yOiBuZXcgUG9pbnQoMCwgMCksXG4gICAgICAgIGJveDogeyB4MTogLWVkZ2UsIHkxOiAtZWRnZSwgeDI6IDAsIHkyOiBlZGdlIH0sXG4gICAgICAgIHBsYWNlbWVudFJhbmdlOiBmdWxsUmFuZ2UsXG4gICAgICAgIHBsYWNlbWVudFNjYWxlOiAwLjUsXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG5cbiAgICB0aGlzLnRvcCA9IHtcbiAgICAgICAgYW5jaG9yOiBuZXcgUG9pbnQoMCwgMCksXG4gICAgICAgIGJveDogeyB4MTogLWVkZ2UsIHkxOiAtZWRnZSwgeDI6IGVkZ2UsIHkyOiAwIH0sXG4gICAgICAgIHBsYWNlbWVudFJhbmdlOiBmdWxsUmFuZ2UsXG4gICAgICAgIHBsYWNlbWVudFNjYWxlOiAwLjUsXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG5cbiAgICB0aGlzLmJvdHRvbSA9IHtcbiAgICAgICAgYW5jaG9yOiBuZXcgUG9pbnQobSwgbSksXG4gICAgICAgIGJveDogeyB4MTogLWVkZ2UsIHkxOiAwLCB4MjogZWRnZSwgeTI6IGVkZ2UgfSxcbiAgICAgICAgcGxhY2VtZW50UmFuZ2U6IGZ1bGxSYW5nZSxcbiAgICAgICAgcGxhY2VtZW50U2NhbGU6IDAuNSxcbiAgICAgICAgbWF4U2NhbGU6IEluZmluaXR5LFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcblxuICAgIHRoaXMucmlnaHQgPSB7XG4gICAgICAgIGFuY2hvcjogbmV3IFBvaW50KG0sIG0pLFxuICAgICAgICBib3g6IHsgeDE6IDAsIHkxOiAtZWRnZSwgeDI6IGVkZ2UsIHkyOiBlZGdlIH0sXG4gICAgICAgIHBsYWNlbWVudFJhbmdlOiBmdWxsUmFuZ2UsXG4gICAgICAgIHBsYWNlbWVudFNjYWxlOiAwLjUsXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG5cbn1cblxuQ29sbGlzaW9uLnByb3RvdHlwZS5nZXRQbGFjZW1lbnRTY2FsZSA9IGZ1bmN0aW9uKGdseXBocywgbWluUGxhY2VtZW50U2NhbGUsIGF2b2lkRWRnZXMpIHtcblxuICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgdmFyIHRvcCA9IHRoaXMudG9wO1xuICAgIHZhciBib3R0b20gPSB0aGlzLmJvdHRvbTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ2x5cGhzLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2tdO1xuICAgICAgICB2YXIgYm94ID0gZ2x5cGguYm94O1xuICAgICAgICB2YXIgYmJveCA9IGdseXBoLmhCb3ggfHwgYm94O1xuICAgICAgICB2YXIgYW5jaG9yID0gZ2x5cGguYW5jaG9yO1xuICAgICAgICB2YXIgcGFkID0gZ2x5cGgucGFkZGluZztcblxuICAgICAgICB2YXIgbWluU2NhbGUgPSBNYXRoLm1heChtaW5QbGFjZW1lbnRTY2FsZSwgZ2x5cGgubWluU2NhbGUpO1xuICAgICAgICB2YXIgbWF4U2NhbGUgPSBnbHlwaC5tYXhTY2FsZSB8fCBJbmZpbml0eTtcblxuICAgICAgICBpZiAobWluU2NhbGUgPj0gbWF4U2NhbGUpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHNjYWxlZCBib3VuZGluZyBib3ggb2YgdGhlIHVucm90YXRlZCBnbHlwaFxuICAgICAgICB2YXIgc2VhcmNoQm94ID0gdGhpcy5nZXRCb3goYW5jaG9yLCBiYm94LCBtaW5TY2FsZSwgbWF4U2NhbGUpO1xuXG4gICAgICAgIHZhciBibG9ja2luZyA9IHRoaXMuaFRyZWUuc2VhcmNoKHNlYXJjaEJveCkuY29uY2F0KHRoaXMuY1RyZWUuc2VhcmNoKHNlYXJjaEJveCkpO1xuXG4gICAgICAgIGlmIChhdm9pZEVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoQm94WzBdIDwgMCkgYmxvY2tpbmcucHVzaChsZWZ0KTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hCb3hbMV0gPCAwKSBibG9ja2luZy5wdXNoKHRvcCk7XG4gICAgICAgICAgICBpZiAoc2VhcmNoQm94WzJdID49IDQwOTYpIGJsb2NraW5nLnB1c2gocmlnaHQpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaEJveFszXSA+PSA0MDk2KSBibG9ja2luZy5wdXNoKGJvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2tpbmcubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHZhciBuYSA9IGFuY2hvcjsgLy8gbmV3IGFuY2hvclxuICAgICAgICAgICAgdmFyIG5iID0gYm94OyAvLyBuZXcgYm94XG5cbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYmxvY2tpbmcubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2EgPSBibG9ja2luZ1tsXS5hbmNob3I7IC8vIG9sZCBhbmNob3JcbiAgICAgICAgICAgICAgICB2YXIgb2IgPSBibG9ja2luZ1tsXS5ib3g7IC8vIG9sZCBib3hcblxuICAgICAgICAgICAgICAgIC8vIElmIGFuY2hvcnMgYXJlIGlkZW50aWNhbCwgd2UncmUgZ29pbmcgdG8gc2tpcCB0aGUgbGFiZWwuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogdGhpcyBpc24ndCByaWdodCBiZWNhdXNlIHRoZXJlIGNhbiBiZSBnbHlwaHMgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzYW1lIGFuY2hvciBidXQgZGlmZmVyaW5nIGJveCBvZmZzZXRzLlxuICAgICAgICAgICAgICAgIGlmIChuYS5lcXVhbHMob2EpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRvZG86IHVuaGFyZGNvZGUgdGhlIDggPSB0aWxlRXh0ZW50L3RpbGVTaXplXG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBNYXRoLm1heChwYWQsIGJsb2NraW5nW2xdLnBhZGRpbmcpICogODtcblxuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGFsZ29yaXRobTpcbiAgICAgICAgICAgICAgICB2YXIgczEgPSAob2IueDEgLSBuYi54MiAtIHBhZGRpbmcpIC8gKG5hLnggLSBvYS54KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgbGVmdCBvZiBvbGQgYm94XG4gICAgICAgICAgICAgICAgdmFyIHMyID0gKG9iLngyIC0gbmIueDEgKyBwYWRkaW5nKSAvIChuYS54IC0gb2EueCk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIHJpZ2h0IG9mIG9sZCBib3hcbiAgICAgICAgICAgICAgICB2YXIgczMgPSAob2IueTEgLSBuYi55MiAtIHBhZGRpbmcpIC8gKG5hLnkgLSBvYS55KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgdG9wIG9mIG9sZCBib3hcbiAgICAgICAgICAgICAgICB2YXIgczQgPSAob2IueTIgLSBuYi55MSArIHBhZGRpbmcpIC8gKG5hLnkgLSBvYS55KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgYm90dG9tIG9mIG9sZCBib3hcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTihzMSkgfHwgaXNOYU4oczIpKSBzMSA9IHMyID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oczMpIHx8IGlzTmFOKHM0KSkgczMgPSBzNCA9IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uRnJlZVNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgoczEsIHMyKSwgTWF0aC5tYXgoczMsIHM0KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBsYWJlbCdzIG1pbiBzY2FsZSBpZiB0aGUgZ2x5cGggd2FzIHJlc3RyaWN0ZWQgYnkgYSBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gbWluUGxhY2VtZW50U2NhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlID4gbWluU2NhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlIDwgbWF4U2NhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlIDwgYmxvY2tpbmdbbF0ubWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluUGxhY2VtZW50U2NhbGUgPSBjb2xsaXNpb25GcmVlU2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1pblBsYWNlbWVudFNjYWxlID4gdGhpcy5tYXhQbGFjZW1lbnRTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbn07XG5cbkNvbGxpc2lvbi5wcm90b3R5cGUuZ2V0UGxhY2VtZW50UmFuZ2UgPSBmdW5jdGlvbihnbHlwaHMsIHBsYWNlbWVudFNjYWxlLCBob3Jpem9udGFsKSB7XG5cbiAgICB2YXIgcGxhY2VtZW50UmFuZ2UgPSBbMipNYXRoLlBJLCAwXTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ2x5cGhzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1trXTtcbiAgICAgICAgdmFyIGJib3ggPSBnbHlwaC5oQm94IHx8IGdseXBoLmJveDtcbiAgICAgICAgdmFyIGFuY2hvciA9IGdseXBoLmFuY2hvcjtcblxuICAgICAgICB2YXIgbWluUGxhY2VkWCA9IGFuY2hvci54ICsgYmJveC54MSAvIHBsYWNlbWVudFNjYWxlO1xuICAgICAgICB2YXIgbWluUGxhY2VkWSA9IGFuY2hvci55ICsgYmJveC55MSAvIHBsYWNlbWVudFNjYWxlO1xuICAgICAgICB2YXIgbWF4UGxhY2VkWCA9IGFuY2hvci54ICsgYmJveC54MiAvIHBsYWNlbWVudFNjYWxlO1xuICAgICAgICB2YXIgbWF4UGxhY2VkWSA9IGFuY2hvci55ICsgYmJveC55MiAvIHBsYWNlbWVudFNjYWxlO1xuXG4gICAgICAgIHZhciBzZWFyY2hCb3ggPSBbbWluUGxhY2VkWCwgbWluUGxhY2VkWSwgbWF4UGxhY2VkWCwgbWF4UGxhY2VkWV07XG5cbiAgICAgICAgdmFyIGJsb2NraW5nID0gdGhpcy5oVHJlZS5zZWFyY2goc2VhcmNoQm94KTtcblxuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgYmxvY2tpbmcgPSBibG9ja2luZy5jb25jYXQodGhpcy5jVHJlZS5zZWFyY2goc2VhcmNoQm94KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGJsb2NraW5nLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IGJsb2NraW5nW2xdO1xuICAgICAgICAgICAgdmFyIGJib3gyID0gYi5oQm94IHx8IGIuYm94O1xuXG4gICAgICAgICAgICB2YXIgeDEsIHgyLCB5MSwgeTIsIGludGVyc2VjdFgsIGludGVyc2VjdFk7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBhbmQgY29tcGFyZSBiYm94ZXMgdG8gc2VlIGlmIHRoZSBnbHlwaHMgbWlnaHQgaW50ZXJzZWN0XG4gICAgICAgICAgICBpZiAocGxhY2VtZW50U2NhbGUgPiBiLnBsYWNlbWVudFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgeDEgPSBiLmFuY2hvci54ICsgYmJveDIueDEgLyBwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB5MSA9IGIuYW5jaG9yLnkgKyBiYm94Mi55MSAvIHBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIHgyID0gYi5hbmNob3IueCArIGJib3gyLngyIC8gcGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICAgICAgeTIgPSBiLmFuY2hvci55ICsgYmJveDIueTIgLyBwbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RYID0geDEgPCBtYXhQbGFjZWRYICYmIHgyID4gbWluUGxhY2VkWDtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RZID0geTEgPCBtYXhQbGFjZWRZICYmIHkyID4gbWluUGxhY2VkWTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeDEgPSBhbmNob3IueCArIGJib3gueDEgLyBiLnBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIHkxID0gYW5jaG9yLnkgKyBiYm94LnkxIC8gYi5wbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB4MiA9IGFuY2hvci54ICsgYmJveC54MiAvIGIucGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICAgICAgeTIgPSBhbmNob3IueSArIGJib3gueTIgLyBiLnBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdFggPSB4MSA8IGJbMl0gJiYgeDIgPiBiWzBdO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdFkgPSB5MSA8IGJbM10gJiYgeTIgPiBiWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGV5IGNhbid0IGludGVyc2VjdCwgc2tpcCBtb3JlIGV4cGVuc2l2ZSByb3RhdGlvbiBjYWxjdWxhdGlvblxuICAgICAgICAgICAgaWYgKCEoaW50ZXJzZWN0WCAmJiBpbnRlcnNlY3RZKSkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KHBsYWNlbWVudFNjYWxlLCBiLnBsYWNlbWVudFNjYWxlKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHJvdGF0aW9uUmFuZ2Uucm90YXRpb25SYW5nZShnbHlwaCwgYiwgc2NhbGUpO1xuXG4gICAgICAgICAgICBwbGFjZW1lbnRSYW5nZVswXSA9IE1hdGgubWluKHBsYWNlbWVudFJhbmdlWzBdLCByYW5nZVswXSk7XG4gICAgICAgICAgICBwbGFjZW1lbnRSYW5nZVsxXSA9IE1hdGgubWF4KHBsYWNlbWVudFJhbmdlWzFdLCByYW5nZVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGxhY2VtZW50UmFuZ2U7XG5cbn07XG5cbi8vIEluc2VydCBnbHlwaCBwbGFjZW1lbnRzIGludG8gcnRyZWUuXG5Db2xsaXNpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGdseXBocywgYW5jaG9yLCBwbGFjZW1lbnRTY2FsZSwgcGxhY2VtZW50UmFuZ2UsIGhvcml6b250YWwpIHtcblxuICAgIHZhciBhbGxCb3VuZHMgPSBbXTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ2x5cGhzLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2tdO1xuICAgICAgICB2YXIgYmJveCA9IGdseXBoLmhCb3ggfHwgZ2x5cGguYm94O1xuXG4gICAgICAgIHZhciBtaW5TY2FsZSA9IE1hdGgubWF4KHBsYWNlbWVudFNjYWxlLCBnbHlwaC5taW5TY2FsZSk7XG4gICAgICAgIHZhciBtYXhTY2FsZSA9IGdseXBoLm1heFNjYWxlIHx8IEluZmluaXR5O1xuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJveChhbmNob3IsIGJib3gsIG1pblNjYWxlLCBtYXhTY2FsZSk7XG5cbiAgICAgICAgYm91bmRzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgYm91bmRzLmJveCA9IGdseXBoLmJveDtcbiAgICAgICAgaWYgKGdseXBoLmhCb3gpIGJvdW5kcy5oQm94ID0gYmJveDtcbiAgICAgICAgYm91bmRzLnBsYWNlbWVudFJhbmdlID0gcGxhY2VtZW50UmFuZ2U7XG4gICAgICAgIGJvdW5kcy5wbGFjZW1lbnRTY2FsZSA9IG1pblNjYWxlO1xuICAgICAgICBib3VuZHMubWF4U2NhbGUgPSBtYXhTY2FsZTtcbiAgICAgICAgYm91bmRzLnBhZGRpbmcgPSBnbHlwaC5wYWRkaW5nO1xuXG4gICAgICAgIGFsbEJvdW5kcy5wdXNoKGJvdW5kcyk7XG4gICAgfVxuXG4gICAgKGhvcml6b250YWwgPyB0aGlzLmhUcmVlIDogdGhpcy5jVHJlZSkubG9hZChhbGxCb3VuZHMpO1xufTtcblxuQ29sbGlzaW9uLnByb3RvdHlwZS5nZXRCb3ggPSBmdW5jdGlvbihhbmNob3IsIGJib3gsIG1pblNjYWxlLCBtYXhTY2FsZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGFuY2hvci54ICsgTWF0aC5taW4oYmJveC54MSAvIG1pblNjYWxlLCBiYm94LngxIC8gbWF4U2NhbGUpLFxuICAgICAgICBhbmNob3IueSArIE1hdGgubWluKGJib3gueTEgLyBtaW5TY2FsZSwgYmJveC55MSAvIG1heFNjYWxlKSxcbiAgICAgICAgYW5jaG9yLnggKyBNYXRoLm1heChiYm94LngyIC8gbWluU2NhbGUsIGJib3gueDIgLyBtYXhTY2FsZSksXG4gICAgICAgIGFuY2hvci55ICsgTWF0aC5tYXgoYmJveC55MiAvIG1pblNjYWxlLCBiYm94LnkyIC8gbWF4U2NhbGUpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCaW5QYWNrID0gcmVxdWlyZSgnLi9iaW5wYWNrLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhBdGxhcztcbmZ1bmN0aW9uIEdseXBoQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuYmluID0gbmV3IEJpblBhY2sod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5pbmRleCA9IHt9O1xuICAgIHRoaXMuaWRzID0ge307XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xufVxuXG5HbHlwaEF0bGFzLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgZGVidWcoKSB7XG4gICAgICAgIHJldHVybiAnY2FudmFzJyBpbiB0aGlzO1xuICAgIH0sXG4gICAgc2V0IGRlYnVnKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jdHg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5nZXRHbHlwaHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2x5cGhzID0ge30sXG4gICAgICAgIHNwbGl0LFxuICAgICAgICBuYW1lLFxuICAgICAgICBpZDtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmlkcykge1xuICAgICAgICBzcGxpdCA9IGtleS5zcGxpdCgnIycpO1xuICAgICAgICBuYW1lID0gc3BsaXRbMF07XG4gICAgICAgIGlkID0gc3BsaXRbMV07XG5cbiAgICAgICAgaWYgKCFnbHlwaHNbbmFtZV0pIGdseXBoc1tuYW1lXSA9IFtdO1xuICAgICAgICBnbHlwaHNbbmFtZV0ucHVzaChpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBocztcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmdldFJlY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlY3RzID0ge30sXG4gICAgICAgIHNwbGl0LFxuICAgICAgICBuYW1lLFxuICAgICAgICBpZDtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmlkcykge1xuICAgICAgICBzcGxpdCA9IGtleS5zcGxpdCgnIycpO1xuICAgICAgICBuYW1lID0gc3BsaXRbMF07XG4gICAgICAgIGlkID0gc3BsaXRbMV07XG5cbiAgICAgICAgaWYgKCFyZWN0c1tuYW1lXSkgcmVjdHNbbmFtZV0gPSB7fTtcbiAgICAgICAgcmVjdHNbbmFtZV1baWRdID0gdGhpcy5pbmRleFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiByZWN0cztcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLnJlbW92ZUdseXBocyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG5cbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuaWRzW2tleV07XG5cbiAgICAgICAgdmFyIHBvcyA9IGlkcy5pbmRleE9mKGlkKTtcbiAgICAgICAgaWYgKHBvcyA+PSAwKSBpZHMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgIHRoaXMuaWRzW2tleV0gPSBpZHM7XG5cbiAgICAgICAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuaW5kZXhba2V5XTtcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcmVjdC5oOyB5KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSB0aGlzLndpZHRoICogKHJlY3QueSArIHkpICsgcmVjdC54O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcmVjdC53OyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3kxICsgeF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuYmluLnJlbGVhc2UocmVjdCk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4W2tleV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pZHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdGhpcy51cGRhdGVUZXh0dXJlKHRoaXMuZ2wpO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuYWRkR2x5cGggPSBmdW5jdGlvbihpZCwgbmFtZSwgZ2x5cGgsIGJ1ZmZlcikge1xuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdtaXNzaW5nIGdseXBoJywgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIga2V5ID0gbmFtZSArIFwiI1wiICsgZ2x5cGguaWQ7XG5cbiAgICAvLyBUaGUgZ2x5cGggaXMgYWxyZWFkeSBpbiB0aGlzIHRleHR1cmUuXG4gICAgaWYgKHRoaXMuaW5kZXhba2V5XSkge1xuICAgICAgICBpZiAodGhpcy5pZHNba2V5XS5pbmRleE9mKGlkKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuaWRzW2tleV0ucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhba2V5XTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZ2x5cGggYml0bWFwIGhhcyB6ZXJvIHdpZHRoLlxuICAgIGlmICghZ2x5cGguYml0bWFwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJlZF93aWR0aCA9IGdseXBoLndpZHRoICsgYnVmZmVyICogMjtcbiAgICB2YXIgYnVmZmVyZWRfaGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciBwYWNrX3dpZHRoID0gYnVmZmVyZWRfd2lkdGg7XG4gICAgdmFyIHBhY2tfaGVpZ2h0ID0gYnVmZmVyZWRfaGVpZ2h0O1xuXG4gICAgLy8gSW5jcmVhc2UgdG8gbmV4dCBudW1iZXIgZGl2aXNpYmxlIGJ5IDQsIGJ1dCBhdCBsZWFzdCAxLlxuICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIHNjYWxlIGRvd24gdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHBhY2sgdGhlbVxuICAgIC8vIGludG8gMiBieXRlcyByYXRoZXIgdGhhbiA0IGJ5dGVzLlxuICAgIHBhY2tfd2lkdGggKz0gKDQgLSBwYWNrX3dpZHRoICUgNCk7XG4gICAgcGFja19oZWlnaHQgKz0gKDQgLSBwYWNrX2hlaWdodCAlIDQpO1xuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmJpbi5hbGxvY2F0ZShwYWNrX3dpZHRoLCBwYWNrX2hlaWdodCk7XG4gICAgaWYgKHJlY3QueCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdnbHlwaCBiaXRtYXAgb3ZlcmZsb3cnKTtcbiAgICAgICAgcmV0dXJuIHsgZ2x5cGg6IGdseXBoLCByZWN0OiBudWxsIH07XG4gICAgfVxuXG4gICAgLy8gQWRkIGxlZnQgYW5kIHRvcCBnbHlwaCBvZmZzZXRzIHRvIHJlY3QuXG4gICAgcmVjdC5sID0gZ2x5cGgubGVmdDtcbiAgICByZWN0LnQgPSBnbHlwaC50b3A7XG5cbiAgICB0aGlzLmluZGV4W2tleV0gPSByZWN0O1xuICAgIHRoaXMuaWRzW2tleV0gPSBbaWRdO1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgc291cmNlID0gZ2x5cGguYml0bWFwO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYnVmZmVyZWRfaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIHkxID0gdGhpcy53aWR0aCAqIChyZWN0LnkgKyB5KSArIHJlY3QueDtcbiAgICAgICAgdmFyIHkyID0gYnVmZmVyZWRfd2lkdGggKiB5O1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlcmVkX3dpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHRhcmdldFt5MSArIHhdID0gc291cmNlW3kyICsgeF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuQUxQSEEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIH1cbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuYmluZChnbCk7XG4gICAgaWYgKHRoaXMuZGlydHkpIHtcblxuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcblxuICAgICAgICAvLyBERUJVR1xuICAgICAgICBpZiAodGhpcy5jdHgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKywgaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2pdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqKzFdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqKzJdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqKzNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmJpbi5mcmVlLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLmJpbi5mcmVlW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoZnJlZS54LCBmcmVlLnksIGZyZWUudywgZnJlZS5oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgREVCVUdcblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4LmpzJykuZ2V0QXJyYXlCdWZmZXI7XG52YXIgR2x5cGhzID0gcmVxdWlyZSgnLi4vdXRpbC9nbHlwaHMuanMnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoU291cmNlO1xuXG5mdW5jdGlvbiBHbHlwaFNvdXJjZSh1cmwsIGdseXBoQXRsYXMpIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmdseXBoQXRsYXMgPSBnbHlwaEF0bGFzO1xuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRSZWN0cyA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgZ2x5cGhJRHMsIHRpbGVJRCwgY2FsbGJhY2spIHtcblxuICAgIGlmICh0aGlzLnN0YWNrc1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHRoaXMuc3RhY2tzW2ZvbnRzdGFja10gPSB7fTtcblxuICAgIHZhciByZWN0cyA9IHt9O1xuICAgIHZhciBnbHlwaHMgPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0geyByZWN0czogcmVjdHMsIGdseXBoczogZ2x5cGhzIH07XG5cbiAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdO1xuICAgIHZhciBnbHlwaEF0bGFzID0gdGhpcy5nbHlwaEF0bGFzO1xuXG4gICAgdmFyIG1pc3NpbmcgPSB7fTtcbiAgICB2YXIgcmVtYWluaW5nID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoSUQgPSBnbHlwaElEc1tpXTtcbiAgICAgICAgdmFyIHJhbmdlID0gTWF0aC5mbG9vcihnbHlwaElEIC8gMjU2KTtcblxuICAgICAgICBpZiAoc3RhY2tbcmFuZ2VdKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBzdGFja1tyYW5nZV0uZ2x5cGhzW2dseXBoSURdO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IDM7XG4gICAgICAgICAgICByZWN0c1tnbHlwaElEXSA9IGdseXBoQXRsYXMuYWRkR2x5cGgodGlsZUlELCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBzaW1wbGVHbHlwaChnbHlwaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1tyYW5nZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdID0gW107XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXNzaW5nW3JhbmdlXS5wdXNoKGdseXBoSUQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KTtcblxuICAgIHZhciBnbHlwaFNvdXJjZSA9IHRoaXM7XG4gICAgZm9yICh2YXIgciBpbiBtaXNzaW5nKSB7XG4gICAgICAgIHRoaXMubG9hZFJhbmdlKGZvbnRzdGFjaywgciwgb25SYW5nZUxvYWRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SYW5nZUxvYWRlZChlcnIsIHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIC8vIFRPRE8gbm90IGJlIHNpbGVudCBhYm91dCBlcnJvcnNcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGdseXBoU291cmNlLnN0YWNrc1tmb250c3RhY2tdW3JhbmdlXSA9IGRhdGEuc3RhY2tzW2ZvbnRzdGFja107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pc3NpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoSUQgPSBtaXNzaW5nW3JhbmdlXVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBzdGFjay5nbHlwaHNbZ2x5cGhJRF07XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IDM7XG4gICAgICAgICAgICAgICAgcmVjdHNbZ2x5cGhJRF0gPSBnbHlwaEF0bGFzLmFkZEdseXBoKHRpbGVJRCwgZm9udHN0YWNrLCBnbHlwaCwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGgpIGdseXBoc1tnbHlwaElEXSA9IHNpbXBsZUdseXBoKGdseXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1haW5pbmctLTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzaW1wbGVHbHlwaChnbHlwaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkdmFuY2U6IGdseXBoLmFkdmFuY2UsXG4gICAgICAgIGxlZnQ6IGdseXBoLmxlZnQsXG4gICAgICAgIHRvcDogZ2x5cGgudG9wXG4gICAgfTtcbn1cblxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmxvYWRSYW5nZSA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgcmFuZ2UsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAocmFuZ2UgKiAyNTYgPj0gNjUyODApIHJldHVybiBjYWxsYmFjaygnZ3lwaHMgPiA2NTI4MCBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAodGhpcy5sb2FkaW5nW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkgdGhpcy5sb2FkaW5nW2ZvbnRzdGFja10gPSB7fTtcbiAgICB2YXIgbG9hZGluZyA9IHRoaXMubG9hZGluZ1tmb250c3RhY2tdO1xuXG4gICAgaWYgKGxvYWRpbmdbcmFuZ2VdKSB7XG4gICAgICAgIGxvYWRpbmdbcmFuZ2VdLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRpbmdbcmFuZ2VdID0gW2NhbGxiYWNrXTtcblxuICAgICAgICB2YXIgcmFuZ2VOYW1lID0gKHJhbmdlICogMjU2KSArICctJyArIChyYW5nZSAqIDI1NiArIDI1NSk7XG4gICAgICAgIHZhciB1cmwgPSBnbHlwaFVybChmb250c3RhY2ssIHJhbmdlTmFtZSwgdGhpcy51cmwpO1xuXG4gICAgICAgIGdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gIWVyciAmJiBuZXcgR2x5cGhzKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2FkaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdbcmFuZ2VdW2ldKGVyciwgcmFuZ2UsIGdseXBocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbG9hZGluZ1tyYW5nZV07XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGdseXBoVXJsKGZvbnRzdGFjaywgcmFuZ2UsIHVybCwgc3ViZG9tYWlucykge1xuICAgIHN1YmRvbWFpbnMgPSBzdWJkb21haW5zIHx8ICdhYmMnO1xuXG4gICAgcmV0dXJuIHVybFxuICAgICAgICAucmVwbGFjZSgne3N9Jywgc3ViZG9tYWluc1tmb250c3RhY2subGVuZ3RoICUgc3ViZG9tYWlucy5sZW5ndGhdKVxuICAgICAgICAucmVwbGFjZSgne2ZvbnRzdGFja30nLCBmb250c3RhY2spXG4gICAgICAgIC5yZXBsYWNlKCd7cmFuZ2V9JywgcmFuZ2UpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpLFxuICAgIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3IuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZTtcblxudmFyIG1pblNjYWxlID0gMC41O1xudmFyIG1pblNjYWxlQXJyYXlzID0ge1xuICAgIDE6IFttaW5TY2FsZV0sXG4gICAgMjogW21pblNjYWxlLCAyXSxcbiAgICA0OiBbbWluU2NhbGUsIDQsIDIsIDRdLFxuICAgIDg6IFttaW5TY2FsZSwgOCwgNCwgOCwgMiwgOCwgNCwgOF1cbn07XG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodmVydGljZXMsIHNwYWNpbmcsIG1pblNjYWxlLCBtYXhTY2FsZSwgdGlsZVBpeGVsUmF0aW8sIHN0YXJ0KSB7XG5cbiAgICBpZiAobWluU2NhbGUgPT09IHVuZGVmaW5lZCkgbWluU2NhbGUgPSAwO1xuXG4gICAgbWF4U2NhbGUgPSBNYXRoLnJvdW5kKE1hdGgubWF4KE1hdGgubWluKDgsIG1heFNjYWxlIC8gMiksIDEpKTtcbiAgICBzcGFjaW5nICo9IHRpbGVQaXhlbFJhdGlvIC8gbWF4U2NhbGU7XG4gICAgdmFyIG1pblNjYWxlcyA9IG1pblNjYWxlQXJyYXlzW21heFNjYWxlXTtcbiAgICB2YXIgbGVuID0gbWluU2NhbGVzLmxlbmd0aDtcblxuICAgIHZhciBkaXN0YW5jZSA9IDAsXG4gICAgICAgIG1hcmtlZERpc3RhbmNlID0gMCxcbiAgICAgICAgYWRkZWQgPSBzdGFydCB8fCAwO1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLSAxOyBpKyspIHtcblxuICAgICAgICB2YXIgYSA9IHZlcnRpY2VzW2ldLFxuICAgICAgICAgICAgYiA9IHZlcnRpY2VzW2kgKyAxXTtcblxuICAgICAgICB2YXIgc2VnbWVudERpc3QgPSBhLmRpc3QoYiksXG4gICAgICAgICAgICBhbmdsZSA9IGIuYW5nbGVUbyhhKTtcblxuICAgICAgICB3aGlsZSAobWFya2VkRGlzdGFuY2UgKyBzcGFjaW5nIDwgZGlzdGFuY2UgKyBzZWdtZW50RGlzdCkge1xuICAgICAgICAgICAgbWFya2VkRGlzdGFuY2UgKz0gc3BhY2luZztcblxuICAgICAgICAgICAgdmFyIHQgPSAobWFya2VkRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBzZWdtZW50RGlzdCxcbiAgICAgICAgICAgICAgICB4ID0gdXRpbC5pbnRlcnAoYS54LCBiLngsIHQpLFxuICAgICAgICAgICAgICAgIHkgPSB1dGlsLmludGVycChhLnksIGIueSwgdCksXG4gICAgICAgICAgICAgICAgcyA9IG1pblNjYWxlc1thZGRlZCAlIGxlbl07XG5cbiAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8IDQwOTYgJiYgeSA+PSAwICYmIHkgPCA0MDk2KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgcywgaSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRlZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzdGFuY2UgKz0gc2VnbWVudERpc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0SWNvbjogZ2V0SWNvbixcbiAgICBnZXRHbHlwaHM6IGdldEdseXBoc1xufTtcblxudmFyIG1pblNjYWxlID0gMC41OyAvLyB1bmRlcnNjYWxlIGJ5IDEgem9vbSBsZXZlbFxuXG5mdW5jdGlvbiBnZXRJY29uKGFuY2hvciwgaW1hZ2UsIGJveFNjYWxlLCBsaW5lLCBwcm9wcykge1xuXG4gICAgdmFyIHggPSBpbWFnZS53aWR0aCAvIDIgLyBpbWFnZS5waXhlbFJhdGlvO1xuICAgIHZhciB5ID0gaW1hZ2UuaGVpZ2h0IC8gMiAvIGltYWdlLnBpeGVsUmF0aW87XG5cbiAgICB2YXIgZHggPSBwcm9wc1snaWNvbi1vZmZzZXQnXVswXTtcbiAgICB2YXIgZHkgPSBwcm9wc1snaWNvbi1vZmZzZXQnXVsxXTtcbiAgICB2YXIgeDEgPSAoZHggLSB4KTtcbiAgICB2YXIgeDIgPSAoZHggKyB4KTtcbiAgICB2YXIgeTEgPSAoZHkgLSB5KTtcbiAgICB2YXIgeTIgPSAoZHkgKyB5KTtcblxuICAgIHZhciB0bCA9IG5ldyBQb2ludCh4MSwgeTEpO1xuICAgIHZhciB0ciA9IG5ldyBQb2ludCh4MiwgeTEpO1xuICAgIHZhciBiciA9IG5ldyBQb2ludCh4MiwgeTIpO1xuICAgIHZhciBibCA9IG5ldyBQb2ludCh4MSwgeTIpO1xuXG4gICAgdmFyIGFuZ2xlID0gcHJvcHNbJ2ljb24tcm90YXRlJ10gKiBNYXRoLlBJIC8gMTgwO1xuICAgIGlmIChhbmNob3Iuc2VnbWVudCAhPT0gdW5kZWZpbmVkICYmIHByb3BzWydpY29uLXJvdGF0aW9uLWFsaWdubWVudCddICE9PSAndmlld3BvcnQnKSB7XG4gICAgICAgIHZhciBuZXh0ID0gbGluZVthbmNob3Iuc2VnbWVudF07XG4gICAgICAgIGFuZ2xlICs9IC1NYXRoLmF0YW4yKG5leHQueCAtIGFuY2hvci54LCBuZXh0LnkgLSBhbmNob3IueSkgKyBNYXRoLlBJIC8gMjtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcblxuICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIGJsID0gYmwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcblxuICAgICAgICB4MSA9IE1hdGgubWluKHRsLngsIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICB4MiA9IE1hdGgubWF4KHRsLngsIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICB5MSA9IE1hdGgubWluKHRsLnksIHRyLnksIGJsLnksIGJyLnkpO1xuICAgICAgICB5MiA9IE1hdGgubWF4KHRsLnksIHRyLnksIGJsLnksIGJyLnkpO1xuICAgIH1cbiAgICB2YXIgYm94ID0ge1xuICAgICAgICB4MTogeDEgKiBib3hTY2FsZSxcbiAgICAgICAgeDI6IHgyICogYm94U2NhbGUsXG4gICAgICAgIHkxOiB5MSAqIGJveFNjYWxlLFxuICAgICAgICB5MjogeTIgKiBib3hTY2FsZVxuICAgIH07XG5cbiAgICB2YXIgaWNvbkJveCA9IHtcbiAgICAgICAgYm94OiBib3gsXG4gICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICBtaW5TY2FsZTogbWluU2NhbGUsXG4gICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgcGFkZGluZzogcHJvcHNbJ2ljb24tcGFkZGluZyddXG4gICAgfTtcblxuICAgIHZhciBpY29uID0ge1xuICAgICAgICB0bDogdGwsXG4gICAgICAgIHRyOiB0cixcbiAgICAgICAgYnI6IGJyLFxuICAgICAgICBibDogYmwsXG4gICAgICAgIHRleDogaW1hZ2UsXG4gICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgICAgbWluU2NhbGU6IG1pblNjYWxlLFxuICAgICAgICBtYXhTY2FsZTogSW5maW5pdHlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hhcGVzOiBbaWNvbl0sXG4gICAgICAgIGJveGVzOiBbaWNvbkJveF0sXG4gICAgICAgIG1pblNjYWxlOiBhbmNob3Iuc2NhbGVcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRHbHlwaHMoYW5jaG9yLCBvcmlnaW4sIHNoYXBpbmcsIGZhY2VzLCBib3hTY2FsZSwgaG9yaXpvbnRhbCwgbGluZSwgcHJvcHMpIHtcblxuICAgIHZhciBtYXhBbmdsZURlbHRhID0gcHJvcHNbJ3RleHQtbWF4LWFuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciByb3RhdGUgPSBwcm9wc1sndGV4dC1yb3RhdGUnXSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHBhZGRpbmcgPSBwcm9wc1sndGV4dC1wYWRkaW5nJ107XG4gICAgdmFyIGFsb25nTGluZSA9IHByb3BzWyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddICE9PSAndmlld3BvcnQnO1xuICAgIHZhciBrZWVwVXByaWdodCA9IHByb3BzWyd0ZXh0LWtlZXAtdXByaWdodCddO1xuXG4gICAgdmFyIGdseXBocyA9IFtdLFxuICAgICAgICBib3hlcyA9IFtdO1xuXG4gICAgdmFyIGJ1ZmZlciA9IDM7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYXBpbmcubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGluZ1trXTtcbiAgICAgICAgdmFyIGZvbnRzdGFjayA9IGZhY2VzW3NoYXBlLmZvbnRzdGFja107XG4gICAgICAgIHZhciBnbHlwaCA9IGZvbnRzdGFjay5nbHlwaHNbc2hhcGUuZ2x5cGhdO1xuICAgICAgICB2YXIgcmVjdCA9IGZvbnRzdGFjay5yZWN0c1tzaGFwZS5nbHlwaF07XG5cbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKCEocmVjdCAmJiByZWN0LncgPiAwICYmIHJlY3QuaCA+IDApKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgeCA9IChvcmlnaW4ueCArIHNoYXBlLnggKyBnbHlwaC5sZWZ0IC0gYnVmZmVyICsgcmVjdC53IC8gMikgKiBib3hTY2FsZTtcblxuICAgICAgICB2YXIgZ2x5cGhJbnN0YW5jZXM7XG4gICAgICAgIGlmIChhbmNob3Iuc2VnbWVudCAhPT0gdW5kZWZpbmVkICYmIGFsb25nTGluZSkge1xuICAgICAgICAgICAgZ2x5cGhJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhJbnN0YW5jZXMsIGFuY2hvciwgeCwgbGluZSwgYW5jaG9yLnNlZ21lbnQsIDEsIG1heEFuZ2xlRGVsdGEpO1xuICAgICAgICAgICAgaWYgKGtlZXBVcHJpZ2h0KSBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIHgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCAtMSwgbWF4QW5nbGVEZWx0YSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW3tcbiAgICAgICAgICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgICAgICAgICAgbWF4U2NhbGU6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1pblNjYWxlOiBtaW5TY2FsZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDEgPSBvcmlnaW4ueCArIHNoYXBlLnggKyBnbHlwaC5sZWZ0IC0gYnVmZmVyLFxuICAgICAgICAgICAgeTEgPSBvcmlnaW4ueSArIHNoYXBlLnkgLSBnbHlwaC50b3AgLSBidWZmZXIsXG4gICAgICAgICAgICB4MiA9IHgxICsgcmVjdC53LFxuICAgICAgICAgICAgeTIgPSB5MSArIHJlY3QuaCxcblxuICAgICAgICAgICAgb3RsID0gbmV3IFBvaW50KHgxLCB5MSksXG4gICAgICAgICAgICBvdHIgPSBuZXcgUG9pbnQoeDIsIHkxKSxcbiAgICAgICAgICAgIG9ibCA9IG5ldyBQb2ludCh4MSwgeTIpLFxuICAgICAgICAgICAgb2JyID0gbmV3IFBvaW50KHgyLCB5Mik7XG5cbiAgICAgICAgdmFyIG9ib3ggPSB7XG4gICAgICAgICAgICAgICAgeDE6IGJveFNjYWxlICogeDEsXG4gICAgICAgICAgICAgICAgeTE6IGJveFNjYWxlICogeTEsXG4gICAgICAgICAgICAgICAgeDI6IGJveFNjYWxlICogeDIsXG4gICAgICAgICAgICAgICAgeTI6IGJveFNjYWxlICogeTJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBnbHlwaEluc3RhbmNlc1tpXSxcblxuICAgICAgICAgICAgICAgIHRsID0gb3RsLFxuICAgICAgICAgICAgICAgIHRyID0gb3RyLFxuICAgICAgICAgICAgICAgIGJsID0gb2JsLFxuICAgICAgICAgICAgICAgIGJyID0gb2JyLFxuICAgICAgICAgICAgICAgIGJveCA9IG9ib3gsXG5cbiAgICAgICAgICAgICAgICAvLyBDbGFtcCB0byAtOTAvKzkwIGRlZ3JlZXNcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGluc3RhbmNlLmFuZ2xlICsgcm90YXRlO1xuXG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICB0ciA9IHRyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCBsYWJlbCBmcm9tIGV4dGVuZGluZyBwYXN0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIHZhciBnbHlwaE1pblNjYWxlID0gTWF0aC5tYXgoaW5zdGFuY2UubWluU2NhbGUsIGFuY2hvci5zY2FsZSk7XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBnbHlwaCBmb3IgbGF0ZXIgaW5zZXJ0aW9uLlxuICAgICAgICAgICAgZ2x5cGhzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRsOiB0bCxcbiAgICAgICAgICAgICAgICB0cjogdHIsXG4gICAgICAgICAgICAgICAgYmw6IGJsLFxuICAgICAgICAgICAgICAgIGJyOiBicixcbiAgICAgICAgICAgICAgICB0ZXg6IHJlY3QsXG4gICAgICAgICAgICAgICAgYW5nbGU6IChhbmNob3IuYW5nbGUgKyByb3RhdGUgKyBpbnN0YW5jZS5vZmZzZXQgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogaW5zdGFuY2UuYW5jaG9yLFxuICAgICAgICAgICAgICAgIG1pblNjYWxlOiBnbHlwaE1pblNjYWxlLFxuICAgICAgICAgICAgICAgIG1heFNjYWxlOiBpbnN0YW5jZS5tYXhTY2FsZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghaW5zdGFuY2Uub2Zmc2V0KSB7IC8vIG5vdCBhIGZsaXBwZWQgZ2x5cGhcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByb3RhdGVkIGdseXBoJ3MgYm91bmRpbmcgYm94IG9mZnNldHMgZnJvbSB0aGUgYW5jaG9yIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICBib3ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogYm94U2NhbGUgKiBNYXRoLm1pbih0bC54LCB0ci54LCBibC54LCBici54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBib3hTY2FsZSAqIE1hdGgubWluKHRsLnksIHRyLnksIGJsLnksIGJyLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IGJveFNjYWxlICogTWF0aC5tYXgodGwueCwgdHIueCwgYmwueCwgYnIueCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5MjogYm94U2NhbGUgKiBNYXRoLm1heCh0bC55LCB0ci55LCBibC55LCBici55KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYm94OiBib3gsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcjogaW5zdGFuY2UuYW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICBtaW5TY2FsZTogZ2x5cGhNaW5TY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbWF4U2NhbGU6IGluc3RhbmNlLm1heFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIGF2b2lkIGNyZWF0aW5nIHRoZSBib3hlcyBpbiB0aGUgZmlyc3QgcGxhY2U/XG4gICAgaWYgKGhvcml6b250YWwpIGJveGVzID0gW2dldE1lcmdlZEJveGVzKGJveGVzLCBhbmNob3IpXTtcblxuICAgIHZhciBtaW5QbGFjZW1lbnRTY2FsZSA9IGFuY2hvci5zY2FsZTtcbiAgICB2YXIgbWluR2x5cGhTY2FsZSA9IEluZmluaXR5O1xuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgYm94ZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgbWluR2x5cGhTY2FsZSA9IE1hdGgubWluKG1pbkdseXBoU2NhbGUsIGJveGVzW21dLm1pblNjYWxlKTtcbiAgICB9XG4gICAgbWluR2x5cGhTY2FsZSA9IE1hdGgubWF4KG1pblBsYWNlbWVudFNjYWxlLCBtaW5TY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBib3hlczogYm94ZXMsXG4gICAgICAgIHNoYXBlczogZ2x5cGhzLFxuICAgICAgICBtaW5TY2FsZTogbWluR2x5cGhTY2FsZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhzLCBhbmNob3IsIG9mZnNldCwgbGluZSwgc2VnbWVudCwgZGlyZWN0aW9uLCBtYXhBbmdsZURlbHRhKSB7XG4gICAgdmFyIHVwc2lkZURvd24gPSBkaXJlY3Rpb24gPCAwO1xuXG4gICAgaWYgKG9mZnNldCA8IDApICBkaXJlY3Rpb24gKj0gLTE7XG5cbiAgICBpZiAoZGlyZWN0aW9uID4gMCkgc2VnbWVudCsrO1xuXG4gICAgdmFyIG5ld0FuY2hvciA9IGFuY2hvcjtcbiAgICB2YXIgZW5kID0gbGluZVtzZWdtZW50XTtcbiAgICB2YXIgcHJldnNjYWxlID0gSW5maW5pdHk7XG4gICAgdmFyIHByZXZBbmdsZTtcblxuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG5cbiAgICB2YXIgcGxhY2VtZW50U2NhbGUgPSBhbmNob3Iuc2NhbGU7XG5cbiAgICBzZWdtZW50X2xvb3A6XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRpc3QgPSBuZXdBbmNob3IuZGlzdChlbmQpO1xuICAgICAgICB2YXIgc2NhbGUgPSBvZmZzZXQvZGlzdDtcbiAgICAgICAgdmFyIGFuZ2xlID0gLU1hdGguYXRhbjIoZW5kLnggLSBuZXdBbmNob3IueCwgZW5kLnkgLSBuZXdBbmNob3IueSkgKyBkaXJlY3Rpb24gKiBNYXRoLlBJIC8gMjtcbiAgICAgICAgaWYgKHVwc2lkZURvd24pIGFuZ2xlICs9IE1hdGguUEk7XG5cbiAgICAgICAgLy8gRG9uJ3QgcGxhY2UgYXJvdW5kIHNoYXJwIGNvcm5lcnNcbiAgICAgICAgdmFyIGFuZ2xlRGlmZiA9IChhbmdsZSAtIHByZXZBbmdsZSkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICBpZiAocHJldkFuZ2xlICYmIE1hdGguYWJzKGFuZ2xlRGlmZikgPiBtYXhBbmdsZURlbHRhKSB7XG4gICAgICAgICAgICBhbmNob3Iuc2NhbGUgPSBwcmV2c2NhbGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBocy5wdXNoKHtcbiAgICAgICAgICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgICAgICAgICAgb2Zmc2V0OiB1cHNpZGVEb3duID8gTWF0aC5QSSA6IDAsXG4gICAgICAgICAgICBtaW5TY2FsZTogc2NhbGUsXG4gICAgICAgICAgICBtYXhTY2FsZTogcHJldnNjYWxlLFxuICAgICAgICAgICAgYW5nbGU6IChhbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNjYWxlIDw9IHBsYWNlbWVudFNjYWxlKSBicmVhaztcblxuICAgICAgICBuZXdBbmNob3IgPSBlbmQ7XG5cbiAgICAgICAgLy8gc2tpcCBkdXBsaWNhdGUgbm9kZXNcbiAgICAgICAgd2hpbGUgKG5ld0FuY2hvci5lcXVhbHMoZW5kKSkge1xuICAgICAgICAgICAgc2VnbWVudCArPSBkaXJlY3Rpb247XG4gICAgICAgICAgICBlbmQgPSBsaW5lW3NlZ21lbnRdO1xuXG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIGFuY2hvci5zY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgICAgIGJyZWFrIHNlZ21lbnRfbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0ID0gZW5kLnN1YihuZXdBbmNob3IpLl91bml0KCk7XG4gICAgICAgIG5ld0FuY2hvciA9IG5ld0FuY2hvci5zdWIodW5pdC5fbXVsdChkaXN0KSk7XG5cbiAgICAgICAgcHJldnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHByZXZBbmdsZSA9IGFuZ2xlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VkQm94ZXMoZ2x5cGhzLCBhbmNob3IpIHtcbiAgICAgIC8vIENvbGxpc2lvbiBjaGVja3MgYmV0d2VlbiByb3RhdGluZyBhbmQgZml4ZWQgbGFiZWxzIGFyZSByZWxhdGl2ZWx5IGV4cGVuc2l2ZSxcbiAgICAgIC8vIHNvIHdlIHVzZSBvbmUgYm94IHBlciBsYWJlbCwgbm90IHBlciBnbHlwaCBmb3IgaG9yaXpvbnRhbCBsYWJlbHMuXG5cbiAgICB2YXIgbWVyZ2VkZ2x5cGhzID0ge1xuICAgICAgICBib3g6IHsgeDE6IEluZmluaXR5LCB5MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfSxcbiAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgIG1pblNjYWxlOiAwLFxuICAgICAgICBwYWRkaW5nOiAtSW5maW5pdHlcbiAgICB9O1xuXG4gICAgdmFyIGJveCA9IG1lcmdlZGdseXBocy5ib3g7XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IGdseXBocy5sZW5ndGg7IG0rKykge1xuICAgICAgICB2YXIgZ2JveCA9IGdseXBoc1ttXS5ib3g7XG4gICAgICAgIGJveC54MSA9IE1hdGgubWluKGJveC54MSwgZ2JveC54MSk7XG4gICAgICAgIGJveC55MSA9IE1hdGgubWluKGJveC55MSwgZ2JveC55MSk7XG4gICAgICAgIGJveC54MiA9IE1hdGgubWF4KGJveC54MiwgZ2JveC54Mik7XG4gICAgICAgIGJveC55MiA9IE1hdGgubWF4KGJveC55MiwgZ2JveC55Mik7XG4gICAgICAgIG1lcmdlZGdseXBocy5taW5TY2FsZSA9IE1hdGgubWF4KG1lcmdlZGdseXBocy5taW5TY2FsZSwgZ2x5cGhzW21dLm1pblNjYWxlKTtcbiAgICAgICAgbWVyZ2VkZ2x5cGhzLnBhZGRpbmcgPSBNYXRoLm1heChtZXJnZWRnbHlwaHMucGFkZGluZywgZ2x5cGhzW21dLnBhZGRpbmcpO1xuICAgIH1cbiAgICAvLyBmb3IgYWxsIGhvcml6b250YWwgbGFiZWxzLCBjYWxjdWxhdGUgYmJveCBjb3ZlcmluZyBhbGwgcm90YXRlZCBwb3NpdGlvbnNcbiAgICB2YXIgeDEyID0gYm94LngxICogYm94LngxLFxuICAgICAgICB5MTIgPSBib3gueTEgKiBib3gueTEsXG4gICAgICAgIHgyMiA9IGJveC54MiAqIGJveC54MixcbiAgICAgICAgeTIyID0gYm94LnkyICogYm94LnkyLFxuICAgICAgICBkaWFnID0gTWF0aC5zcXJ0KE1hdGgubWF4KHgxMiArIHkxMiwgeDEyICsgeTIyLCB4MjIgKyB5MTIsIHgyMiArIHkyMikpO1xuXG4gICAgbWVyZ2VkZ2x5cGhzLmhCb3ggPSB7XG4gICAgICAgIHgxOiAtZGlhZyxcbiAgICAgICAgeTE6IC1kaWFnLFxuICAgICAgICB4MjogZGlhZyxcbiAgICAgICAgeTI6IGRpYWdcbiAgICB9O1xuXG4gICAgcmV0dXJuIG1lcmdlZGdseXBocztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi91dGlsL3Rva2VuLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVRleHQ7XG5cbi8vIEZvciBhbiBhcnJheSBvZiBmZWF0dXJlcyBkZXRlcm1pbmUgd2hhdCBnbHlwaCByYW5nZXMgbmVlZCB0byBiZSBsb2FkZWRcbi8vIGFuZCBhcHBseSBhbnkgdGV4dCBwcmVwcm9jZXNzaW5nLiBUaGUgcmVtYWluaW5nIHVzZXJzIG9mIHRleHQgc2hvdWxkXG4vLyB1c2UgdGhlIGB0ZXh0RmVhdHVyZXNgIGtleSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIGFjY2Vzc2luZ1xuLy8gZmVhdHVyZSB0ZXh0IGRpcmVjdGx5LlxuZnVuY3Rpb24gcmVzb2x2ZVRleHQoZmVhdHVyZXMsIGluZm8sIGdseXBocykge1xuICAgIHZhciB0ZXh0RmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgY29kZXBvaW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZsID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgZmw7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgaW5mb1sndGV4dC1maWVsZCddKTtcbiAgICAgICAgdmFyIGhhc3RleHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0ZXh0KSBjb250aW51ZTtcbiAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gaW5mb1sndGV4dC10cmFuc2Zvcm0nXTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAnbG93ZXJjYXNlJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IHRleHQubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA8PSA2NTUzMykge1xuICAgICAgICAgICAgICAgIGNvZGVwb2ludHMucHVzaCh0ZXh0LmNoYXJDb2RlQXQoaikpO1xuICAgICAgICAgICAgICAgIGhhc3RleHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWNrIGluZGV4ZXMgb2YgZmVhdHVyZXMgd2l0aCB0ZXh0LlxuICAgICAgICBpZiAoaGFzdGV4dCkge1xuICAgICAgICAgICAgdGV4dEZlYXR1cmVzW2ldID0gdGV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldCBhIGxpc3Qgb2YgdW5pcXVlIGNvZGVwb2ludHMgd2UgYXJlIG1pc3NpbmdcbiAgICBjb2RlcG9pbnRzID0gdW5pcShjb2RlcG9pbnRzLCBnbHlwaHMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dEZlYXR1cmVzOiB0ZXh0RmVhdHVyZXMsXG4gICAgICAgIGNvZGVwb2ludHM6IGNvZGVwb2ludHNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB1bmlxKGlkcywgYWxyZWFkeUhhdmUpIHtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBsYXN0O1xuICAgIGlkcy5zb3J0KHNvcnROdW1iZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWRzW2ldICE9PSBsYXN0KSB7XG4gICAgICAgICAgICBsYXN0ID0gaWRzW2ldO1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5SGF2ZVtsYXN0XSkgdS5wdXNoKGlkc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5cbmZ1bmN0aW9uIHNvcnROdW1iZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJvdGF0aW9uUmFuZ2U6IHJvdGF0aW9uUmFuZ2UsXG4gICAgbWVyZ2VDb2xsaXNpb25zOiBtZXJnZUNvbGxpc2lvbnMsXG5cbiAgICByb3RhdGluZ0ZpeGVkQ29sbGlzaW9uczogcm90YXRpbmdGaXhlZENvbGxpc2lvbnMsXG4gICAgcm90YXRpbmdSb3RhdGluZ0NvbGxpc2lvbnM6IHJvdGF0aW5nUm90YXRpbmdDb2xsaXNpb25zLFxuXG4gICAgY29ybmVyQm94Q29sbGlzaW9uczogY29ybmVyQm94Q29sbGlzaW9ucyxcbiAgICBjaXJjbGVFZGdlQ29sbGlzaW9uczogY2lyY2xlRWRnZUNvbGxpc2lvbnMsXG5cbiAgICBnZXRDb3JuZXJzOiBnZXRDb3JuZXJzLFxufTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgcmFuZ2UgYSBib3ggY29uZmxpY3RzIHdpdGggYSBzZWNvbmQgYm94XG4gKi9cbmZ1bmN0aW9uIHJvdGF0aW9uUmFuZ2UoaW5zZXJ0aW5nLCBibG9ja2VyLCBzY2FsZSkge1xuXG4gICAgdmFyIGNvbGxpc2lvbnMsIGJveDtcblxuICAgIHZhciBhID0gaW5zZXJ0aW5nO1xuICAgIHZhciBiID0gYmxvY2tlcjtcblxuICAgIC8vIEluc3RlYWQgb2Ygc2NhbGluZyB0aGUgYm94ZXMsIHdlIG1vdmUgdGhlIGFuY2hvcnNcbiAgICB2YXIgcmVsYXRpdmVBbmNob3IgPSBuZXcgUG9pbnQoXG4gICAgICAgIChiLmFuY2hvci54IC0gYS5hbmNob3IueCkgKiBzY2FsZSxcbiAgICAgICAgKGIuYW5jaG9yLnkgLSBhLmFuY2hvci55KSAqIHNjYWxlKTtcblxuICAgIC8vIEdlbmVyYXRlIGEgbGlzdCBvZiBjb2xsaXNpb24gaW50ZXJ2YWxcbiAgICBpZiAoYS5oQm94ICYmIGIuaEJveCkge1xuICAgICAgICBjb2xsaXNpb25zID0gcm90YXRpbmdSb3RhdGluZ0NvbGxpc2lvbnMoYS5ib3gsIGIuYm94LCByZWxhdGl2ZUFuY2hvcik7XG5cbiAgICB9IGVsc2UgaWYgKGEuaEJveCkge1xuICAgICAgICBib3ggPSB7XG4gICAgICAgICAgICB4MTogYi5ib3gueDEgKyByZWxhdGl2ZUFuY2hvci54LFxuICAgICAgICAgICAgeTE6IGIuYm94LnkxICsgcmVsYXRpdmVBbmNob3IueSxcbiAgICAgICAgICAgIHgyOiBiLmJveC54MiArIHJlbGF0aXZlQW5jaG9yLngsXG4gICAgICAgICAgICB5MjogYi5ib3gueTIgKyByZWxhdGl2ZUFuY2hvci55XG4gICAgICAgIH07XG4gICAgICAgIGNvbGxpc2lvbnMgPSByb3RhdGluZ0ZpeGVkQ29sbGlzaW9ucyhhLmJveCwgYm94KTtcblxuXG4gICAgfSBlbHNlIGlmIChiLmhCb3gpIHtcbiAgICAgICAgYm94ID0ge1xuICAgICAgICAgICAgeDE6IGEuYm94LngxIC0gcmVsYXRpdmVBbmNob3IueCxcbiAgICAgICAgICAgIHkxOiBhLmJveC55MSAtIHJlbGF0aXZlQW5jaG9yLnksXG4gICAgICAgICAgICB4MjogYS5ib3gueDIgLSByZWxhdGl2ZUFuY2hvci54LFxuICAgICAgICAgICAgeTI6IGEuYm94LnkyIC0gcmVsYXRpdmVBbmNob3IueVxuICAgICAgICB9O1xuICAgICAgICBjb2xsaXNpb25zID0gcm90YXRpbmdGaXhlZENvbGxpc2lvbnMoYi5ib3gsIGJveCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsaXNpb25zID0gW107XG4gICAgfVxuXG4gICAgLy8gRmluZCBhbmQgcmV0dXJuIHRoZSBjb250aW5vdXMgYXJlIGFyb3VuZCAwIHdoZXJlIHRoZXJlIGFyZSBubyBjb2xsaXNpb25zXG4gICAgcmV0dXJuIG1lcmdlQ29sbGlzaW9ucyhjb2xsaXNpb25zLCBibG9ja2VyLnBsYWNlbWVudFJhbmdlKTtcbn1cblxuLypcbiAqIENvbWJpbmUgYW4gYXJyYXkgb2YgY29sbGlzaW9uIHJhbmdlcyB0byBmb3JtIGEgY29udGludW91c1xuICogcmFuZ2UgdGhhdCBpbmNsdWRlcyAwLiBDb2xsaXNpb25zIHdpdGhpbiB0aGUgaWdub3JlUmFuZ2UgYXJlIGlnbm9yZWRcbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb2xsaXNpb25zKGNvbGxpc2lvbnMsIGlnbm9yZVJhbmdlKSB7XG5cbiAgICAvLyBmaW5kIGNvbnRpbnVvdXMgaW50ZXJ2YWwgaW5jbHVkaW5nIDAgdGhhdCBkb2Vzbid0IGhhdmUgYW55IGNvbGxpc2lvbnNcbiAgICB2YXIgbWluID0gMiAqIE1hdGguUEk7XG4gICAgdmFyIG1heCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxpc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XG5cbiAgICAgICAgdmFyIGVudHJ5T3V0c2lkZSA9IGlnbm9yZVJhbmdlWzBdIDw9IGNvbGxpc2lvblswXSAmJiBjb2xsaXNpb25bMF0gPD0gaWdub3JlUmFuZ2VbMV07XG4gICAgICAgIHZhciBleGl0T3V0c2lkZSA9IGlnbm9yZVJhbmdlWzBdIDw9IGNvbGxpc2lvblsxXSAmJiBjb2xsaXNpb25bMV0gPD0gaWdub3JlUmFuZ2VbMV07XG5cbiAgICAgICAgaWYgKGVudHJ5T3V0c2lkZSAmJiBleGl0T3V0c2lkZSkge1xuICAgICAgICAgICAgLy8gbm8gY29sbGlzaW9uLCBzaW5jZSBibG9ja2VyIGlzIG91dCBvZiByYW5nZVxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5T3V0c2lkZSkge1xuICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBpZ25vcmVSYW5nZVsxXSk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGNvbGxpc2lvblsxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhpdE91dHNpZGUpIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgY29sbGlzaW9uWzBdKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgaWdub3JlUmFuZ2VbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBjb2xsaXNpb25bMF0pO1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBjb2xsaXNpb25bMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbi8qXG4gKiAgQ2FsY3VsYXRlIGNvbGxpc2lvbiByYW5nZXMgZm9yIHR3byByb3RhdGluZyBib3hlcy5cbiAqL1xuXG52YXIgaG9yaXpvbnRhbCA9IG5ldyBQb2ludCgxLCAwKTtcblxuZnVuY3Rpb24gcm90YXRpbmdSb3RhdGluZ0NvbGxpc2lvbnMoYSwgYiwgYW5jaG9yVG9BbmNob3IpIHtcbiAgICB2YXIgZCA9IGFuY2hvclRvQW5jaG9yLm1hZygpO1xuXG4gICAgdmFyIGFuZ2xlQmV0d2VlbkFuY2hvcnMgPSBhbmNob3JUb0FuY2hvci5hbmdsZVdpdGgoaG9yaXpvbnRhbCk7XG5cbiAgICB2YXIgYyA9IFtdLFxuICAgICAgICBjb2xsaXNpb25zID0gW10sXG4gICAgICAgIGs7XG5cbiAgICAvLyBDYWxjdWxhdGUgYW5nbGVzIGF0IHdoaWNoIGNvbGxpc2lvbnMgbWF5IG9jY3VyXG4gICAgLy8gdG9wL2JvdHRvbVxuICAgIGNbMF0gPSBNYXRoLmFzaW4oKGEueTIgLSBiLnkxKSAvIGQpO1xuICAgIGNbMV0gPSBNYXRoLmFzaW4oKGEueTIgLSBiLnkxKSAvIGQpICsgTWF0aC5QSTtcbiAgICBjWzJdID0gMiAqIE1hdGguUEkgLSBNYXRoLmFzaW4oKC1hLnkxICsgYi55MikgLyBkKTtcbiAgICBjWzNdID0gTWF0aC5QSSAtIE1hdGguYXNpbigoLWEueTEgKyBiLnkyKSAvIGQpO1xuXG4gICAgLy8gbGVmdC9yaWdodFxuICAgIGNbNF0gPSAyICogTWF0aC5QSSAtIE1hdGguYWNvcygoYS54MiAtIGIueDEpIC8gZCk7XG4gICAgY1s1XSA9IE1hdGguYWNvcygoYS54MiAtIGIueDEpIC8gZCk7XG4gICAgY1s2XSA9IE1hdGguUEkgLSBNYXRoLmFjb3MoKC1hLngxICsgYi54MikgLyBkKTtcbiAgICBjWzddID0gTWF0aC5QSSArIE1hdGguYWNvcygoLWEueDEgKyBiLngyKSAvIGQpO1xuXG4gICAgdmFyIHJsID0gYS54MiAtIGIueDE7XG4gICAgdmFyIGxyID0gLWEueDEgKyBiLngyO1xuICAgIHZhciB0YiA9IGEueTIgLSBiLnkxO1xuICAgIHZhciBidCA9IC1hLnkxICsgYi55MjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugc3F1YXJlZCBvZiB0aGUgZGlhZ29uYWwgd2hpY2ggd2lsbCBiZSB1c2VkXG4gICAgLy8gdG8gY2hlY2sgaWYgdGhlIGJveGVzIGFyZSBjbG9zZSBlbm91Z2ggZm9yIGNvbGxpc2lvbnMgdG8gb2NjdXIgYXQgZWFjaCBhbmdsZVxuICAgIC8vIHRvZG8sIHRyaXBsZSBjaGVjayB0aGVzZVxuICAgIHZhciBlID0gW107XG4gICAgLy8gdG9wL2JvdHRvbVxuICAgIGVbMF0gPSBybCAqIHJsICsgdGIgKiB0YjtcbiAgICBlWzFdID0gbHIgKiBsciArIHRiICogdGI7XG4gICAgZVsyXSA9IHJsICogcmwgKyBidCAqIGJ0O1xuICAgIGVbM10gPSBsciAqIGxyICsgYnQgKiBidDtcbiAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgZVs0XSA9IHJsICogcmwgKyB0YiAqIHRiO1xuICAgIGVbNV0gPSBybCAqIHJsICsgYnQgKiBidDtcbiAgICBlWzZdID0gbHIgKiBsciArIGJ0ICogYnQ7XG4gICAgZVs3XSA9IGxyICogbHIgKyB0YiAqIHRiO1xuXG5cbiAgICBjID0gYy5maWx0ZXIoZnVuY3Rpb24oeCwgaSkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGV5IGFyZSBjbG9zZSBlbm91Z2ggdG8gY29sbGlkZVxuICAgICAgICByZXR1cm4gIWlzTmFOKHgpICYmIGQgKiBkIDw9IGVbaV07XG4gICAgfSkubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgLy8gU28gZmFyLCBhbmdsZXMgaGF2ZSBiZWVuIGNhbHVsYXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgdmVjdG9yIGJldHdlZW4gYW5jaG9ycy5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgYW5nbGVzIHRvIGFuZ2xlcyBmcm9tIG5vcnRoLlxuICAgICAgICByZXR1cm4gKHggKyBhbmdsZUJldHdlZW5BbmNob3JzICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICB9KTtcblxuICAgIC8vIEdyb3VwIHRoZSBjb2xsaXNpb24gYW5nbGVzIGJ5IHR3b1xuICAgIC8vIGVhY2ggZ3JvdXAgcmVwcmVzZW50cyBhIHJhbmdlIHdoZXJlIHRoZSB0d28gYm94ZXMgY29sbGlkZVxuICAgIGMuc29ydCgpO1xuICAgIGZvciAoayA9IDA7IGsgPCBjLmxlbmd0aDsgays9Mikge1xuICAgICAgICBjb2xsaXNpb25zLnB1c2goW2Nba10sIGNbaysxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsaXNpb25zO1xuXG59XG5cbi8qXG4gKiAgQ2FsY3VsYXRlIGNvbGxpc2lvbiByYW5nZXMgZm9yIGEgcm90YXRpbmcgYm94IGFuZCBhIGZpeGVkIGJveDtcbiAqL1xuZnVuY3Rpb24gcm90YXRpbmdGaXhlZENvbGxpc2lvbnMocm90YXRpbmcsIGZpeGVkKSB7XG5cbiAgICB2YXIgY29ybmVyc1IgPSBnZXRDb3JuZXJzKHJvdGF0aW5nKTtcbiAgICB2YXIgY29ybmVyc0YgPSBnZXRDb3JuZXJzKGZpeGVkKTtcblxuICAgIC8vIEEgY29sbGlzaW9uIG9jY3VycyB3aGVuLCBhbmQgb25seSBhdCBsZWFzdCBvbmUgY29ybmVyIGZyb20gb25lIG9mIHRoZSBib3hlc1xuICAgIC8vIGlzIHdpdGhpbiB0aGUgb3RoZXIgYm94LiBDYWxjdWxhdGUgdGhlc2UgcmFuZ2VzIGZvciBlYWNoIGNvcm5lci5cblxuICAgIHZhciBjb2xsaXNpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKyApIHtcbiAgICAgICAgY29ybmVyQm94Q29sbGlzaW9ucyhjb2xsaXNpb25zLCBjb3JuZXJzUltpXSwgY29ybmVyc0YpO1xuICAgICAgICBjb3JuZXJCb3hDb2xsaXNpb25zKGNvbGxpc2lvbnMsIGNvcm5lcnNGW2ldLCBjb3JuZXJzUiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxpc2lvbnM7XG59XG5cblxuLypcbiAqICBDYWxjdWxhdGUgdGhlIHJhbmdlcyBmb3Igd2hpY2ggdGhlIGNvcm5lcixcbiAqICByb3RhdGF0ZWQgYXJvdW5kIHRoZSBhbmNob3IsIGlzIHdpdGhpbiB0aGUgYm94O1xuICovXG5mdW5jdGlvbiBjb3JuZXJCb3hDb2xsaXNpb25zKGNvbGxpc2lvbnMsIGNvcm5lciwgYm94Q29ybmVycywgZmxpcCkge1xuICAgIHZhciByYWRpdXMgPSBjb3JuZXIubWFnKCksXG4gICAgICAgIGFuZ2xlcyA9IFtdO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2ludHMgYXQgd2hpY2ggdGhlIGNvcm5lcnMgaW50ZXJzZWN0IHdpdGggdGhlIGVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAzOyBpIDwgNDsgaiA9IGkrKykge1xuICAgICAgICBjaXJjbGVFZGdlQ29sbGlzaW9ucyhhbmdsZXMsIGNvcm5lciwgcmFkaXVzLCBib3hDb3JuZXJzW2pdLCBib3hDb3JuZXJzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGVzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgLy8gVE9ETyBmaXhcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBnZXQgaGl0IHdoZW4gYSBwb2ludCBpbnRlcnNlY3RzIHZlcnkgY2xvc2UgdG8gYSBjb3JuZXJcbiAgICAgICAgLy8gYW5kIGZsb2F0aW5nIHBvaW50IGlzc3VlcyBjYXVzZSBvbmx5IG9uZSBvZiB0aGUgZW50cnkgb3IgZXhpdCB0byBiZSBjb3VudGVkXG4gICAgICAgIHRocm93KCdleHBlY3RpbmcgYW4gZXZlbiBudW1iZXIgb2YgaW50ZXJzZWN0aW9ucycpO1xuICAgIH1cblxuICAgIGFuZ2xlcy5zb3J0KCk7XG5cbiAgICAvLyBHcm91cCBieSBwYWlycywgd2hlcmUgZWFjaCByZXByZXNlbnRzIGEgcmFuZ2Ugd2hlcmUgYSBjb2xsaXNpb24gb2NjdXJzXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBhbmdsZXMubGVuZ3RoOyBrKz0yKSB7XG4gICAgICAgIGNvbGxpc2lvbnNbay8yXSA9IGZsaXAgP1xuICAgICAgICAgICAgWzIgKiBNYXRoLlBJIC0gYW5nbGVzW2srMV0sIDIgKiBNYXRoLlBJIC0gYW5nbGVzW2tdXSA6IC8vIHJlZmxlY3QgYW4gYW5nbGUgYXJvdW5kIDAgZGVncmVlc1xuICAgICAgICAgICAgW2FuZ2xlc1trXSwgYW5nbGVzW2srMV1dO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsaXNpb25zO1xufVxuXG4vKlxuICogUmV0dXJuIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIG9mIGEgY2lyY2xlIGFuZCBhIGxpbmUgc2VnbWVudDtcbiAqL1xuZnVuY3Rpb24gY2lyY2xlRWRnZUNvbGxpc2lvbnMoYW5nbGVzLCBjb3JuZXIsIHJhZGl1cywgcDEsIHAyKSB7XG5cbiAgICB2YXIgZWRnZVggPSBwMi54IC0gcDEueDtcbiAgICB2YXIgZWRnZVkgPSBwMi55IC0gcDEueTtcblxuICAgIHZhciBhID0gZWRnZVggKiBlZGdlWCArIGVkZ2VZICogZWRnZVk7XG4gICAgdmFyIGIgPSAoZWRnZVggKiBwMS54ICsgZWRnZVkgKiBwMS55KSAqIDI7XG4gICAgdmFyIGMgPSBwMS54ICogcDEueCArIHAxLnkgKiBwMS55IC0gcmFkaXVzICogcmFkaXVzO1xuXG4gICAgdmFyIGRpc2NyaW1pbmFudCA9IGIqYiAtIDQqYSpjO1xuXG4gICAgLy8gYSBjb2xsaXNpb24gZXhpc3RzIG9ubHkgaWYgbGluZSBpbnRlcnNlY3RzIGNpcmNsZSBhdCB0d28gcG9pbnRzXG4gICAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICAgICAgdmFyIHgxID0gKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICAgICAgdmFyIHgyID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcblxuICAgICAgICAvLyBvbmx5IGFkZCBwb2ludHMgaWYgd2l0aGluIGxpbmUgc2VnbWVudFxuICAgICAgICAvLyBoYWNrIHRvIGhhbmRsZSBmbG9hdGluZyBwb2ludCByZXByZXNlbnRhdGlvbnMgb2YgMCBhbmQgMVxuICAgICAgICBpZiAoMCA8IHgxICYmIHgxIDwgMSkge1xuICAgICAgICAgICAgYW5nbGVzLnB1c2goZ2V0QW5nbGUocDEsIHAyLCB4MSwgY29ybmVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoMCA8IHgyICYmIHgyIDwgMSkge1xuICAgICAgICAgICAgYW5nbGVzLnB1c2goZ2V0QW5nbGUocDEsIHAyLCB4MiwgY29ybmVyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIGQsIGNvcm5lcikge1xuICAgIHJldHVybiAoLWNvcm5lci5hbmdsZVdpdGhTZXAoXG4gICAgICAgIHV0aWwuaW50ZXJwKHAxLngsIHAyLngsIGQpLFxuICAgICAgICB1dGlsLmludGVycChwMS55LCBwMi55LCBkKSkgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xufVxuXG5mdW5jdGlvbiBnZXRDb3JuZXJzKGEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUG9pbnQoYS54MSwgYS55MSksXG4gICAgICAgIG5ldyBQb2ludChhLngxLCBhLnkyKSxcbiAgICAgICAgbmV3IFBvaW50KGEueDIsIGEueTIpLFxuICAgICAgICBuZXcgUG9pbnQoYS54MiwgYS55MSlcbiAgICBdO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaGFwZTogc2hhcGVcbn07XG5cbmZ1bmN0aW9uIHNoYXBlKHRleHQsIG5hbWUsIHN0YWNrcywgbWF4V2lkdGgsIGxpbmVIZWlnaHQsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgc3BhY2luZywgdHJhbnNsYXRlKSB7XG4gICAgdmFyIGdseXBocyA9IHN0YWNrc1tuYW1lXS5nbHlwaHM7XG4gICAgdmFyIGdseXBoO1xuXG4gICAgdmFyIHNoYXBpbmcgPSBbXTtcblxuICAgIHZhciB4ID0gdHJhbnNsYXRlWzBdO1xuICAgIHZhciB5ID0gdHJhbnNsYXRlWzFdO1xuICAgIHZhciBpZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaWRdO1xuXG4gICAgICAgIGlmIChpZCA9PT0gMCB8fCAhZ2x5cGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHNoYXBpbmcucHVzaCh7XG4gICAgICAgICAgICBmb250c3RhY2s6IG5hbWUsXG4gICAgICAgICAgICBnbHlwaDogaWQsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9KTtcblxuICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2UgKyBzcGFjaW5nO1xuICAgIH1cblxuICAgIGlmICghc2hhcGluZy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIHNoYXBpbmcgPSBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnkpO1xuXG4gICAgcmV0dXJuIHNoYXBpbmc7XG59XG5cbnZhciBicmVha2FibGUgPSB7IDMyOiB0cnVlIH07IC8vIEN1cnJlbnRseSBvbmx5IGJyZWFrcyBhdCByZWd1bGFyIHNwYWNlc1xuXG5mdW5jdGlvbiBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnkpIHtcbiAgICB2YXIgbGFzdFNhZmVCcmVhayA9IG51bGw7XG5cbiAgICB2YXIgbGVuZ3RoQmVmb3JlQ3VycmVudExpbmUgPSAwO1xuICAgIHZhciBsaW5lU3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmUgPSAwO1xuXG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuXG4gICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGluZ1tpXTtcblxuICAgICAgICAgICAgc2hhcGUueCAtPSBsZW5ndGhCZWZvcmVDdXJyZW50TGluZTtcbiAgICAgICAgICAgIHNoYXBlLnkgKz0gbGluZUhlaWdodCAqIGxpbmU7XG5cbiAgICAgICAgICAgIGlmIChzaGFwZS54ID4gbWF4V2lkdGggJiYgbGFzdFNhZmVCcmVhayAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBzaGFwaW5nW2xhc3RTYWZlQnJlYWsgKyAxXS54O1xuICAgICAgICAgICAgICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChsaW5lTGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBsYXN0U2FmZUJyZWFrICsgMTsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGluZ1trXS55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBpbmdba10ueCAtPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlMaW5lKHNoYXBpbmcsIGdseXBocywgbGluZVN0YXJ0SW5kZXgsIGxhc3RTYWZlQnJlYWsgLSAxLCBqdXN0aWZ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRJbmRleCA9IGxhc3RTYWZlQnJlYWsgKyAxO1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lICs9IGxpbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnJlYWthYmxlW3NoYXBlLmdseXBoXSkge1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWF4TGluZUxlbmd0aCA9IG1heExpbmVMZW5ndGggfHwgc2hhcGluZ1tzaGFwaW5nLmxlbmd0aCAtIDFdLng7XG5cbiAgICBqdXN0aWZ5TGluZShzaGFwaW5nLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBzaGFwaW5nLmxlbmd0aCAtIDEsIGp1c3RpZnkpO1xuICAgIGFsaWduKHNoYXBpbmcsIGp1c3RpZnksIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbWF4TGluZUxlbmd0aCwgbGluZUhlaWdodCwgbGluZSk7XG4gICAgcmV0dXJuIHNoYXBpbmc7XG59XG5cbmZ1bmN0aW9uIGp1c3RpZnlMaW5lKHNoYXBpbmcsIGdseXBocywgc3RhcnQsIGVuZCwganVzdGlmeSkge1xuICAgIHZhciBsYXN0QWR2YW5jZSA9IGdseXBoc1tzaGFwaW5nW2VuZF0uZ2x5cGhdLmFkdmFuY2U7XG4gICAgdmFyIGxpbmVJbmRlbnQgPSAoc2hhcGluZ1tlbmRdLnggKyBsYXN0QWR2YW5jZSkgKiBqdXN0aWZ5O1xuXG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgIHNoYXBpbmdbal0ueCAtPSBsaW5lSW5kZW50O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBhbGlnbihzaGFwaW5nLCBqdXN0aWZ5LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIG1heExpbmVMZW5ndGgsIGxpbmVIZWlnaHQsIGxpbmUpIHtcbiAgICB2YXIgc2hpZnRYID0gKGp1c3RpZnkgLSBob3Jpem9udGFsQWxpZ24pICogbWF4TGluZUxlbmd0aDtcbiAgICB2YXIgc2hpZnRZID0gKC12ZXJ0aWNhbEFsaWduICogKGxpbmUgKyAxKSArIDAuNSkgKiBsaW5lSGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFwaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNoYXBpbmdbal0ueCArPSBzaGlmdFg7XG4gICAgICAgIHNoYXBpbmdbal0ueSArPSBzaGlmdFk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbC5qcycpLFxuICAgIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tLmpzJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0aW9uO1xuXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbigpIHt9XG5cbkF0dHJpYnV0aW9uLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChDb250cm9sLCB7XG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwtYXR0cmliJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgbWFwLmNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIG1hcC5vbignc291cmNlLmFkZCcsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlRWRpdExpbmsuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWFwLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9tYXAuc291cmNlc1tpZF07XG4gICAgICAgICAgICBpZiAoc291cmNlLnRpbGVKU09OICYmIHNvdXJjZS50aWxlSlNPTi5hdHRyaWJ1dGlvbikge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9ucy5wdXNoKHNvdXJjZS50aWxlSlNPTi5hdHRyaWJ1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGF0dHJpYnV0aW9ucy5qb2luKCcgfCAnKTtcbiAgICAgICAgdGhpcy5fZWRpdExpbmsgPSB0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFwYm94LWltcHJvdmUtbWFwJylbMF07XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVFZGl0TGluazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0TGluaykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRMaW5rLmhyZWYgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXAtZmVlZGJhY2svIy8nICtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLmxuZyArICcvJyArIGNlbnRlci5sYXQgKyAnLycgKyBNYXRoLnJvdW5kKHRoaXMuX21hcC5nZXRab29tKCkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2w7XG5cbmZ1bmN0aW9uIENvbnRyb2woKSB7fVxuXG5Db250cm9sLnByb3RvdHlwZSA9IHtcblx0YWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHRpZiAodGhpcy5vblJlbW92ZSkgdGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xuXHRcdHRoaXMuX21hcCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sLmpzJyksXG4gICAgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20uanMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdGlvbjtcblxuZnVuY3Rpb24gTmF2aWdhdGlvbigpIHt9XG5cbk5hdmlnYXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1uYXYnO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIG1hcC5jb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX3pvb21JbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLXpvb20taW4nLCBtYXAuem9vbUluLmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy16b29tLW91dCcsIG1hcC56b29tT3V0LmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX2NvbXBhc3MgPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1jb21wYXNzJywgbWFwLnJlc2V0Tm9ydGguYmluZChtYXApKTtcblxuICAgICAgICB2YXIgY29tcGFzc0NhbnZhcyA9IHRoaXMuX2NvbXBhc3NDYW52YXMgPSBET00uY3JlYXRlKCdjYW52YXMnLCBjbGFzc05hbWUgKyAnLWNvbXBhc3MtY2FudmFzJywgdGhpcy5fY29tcGFzcyk7XG4gICAgICAgIGNvbXBhc3NDYW52YXMuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDoyNnB4OyBoZWlnaHQ6MjZweDsnO1xuICAgICAgICBjb21wYXNzQ2FudmFzLndpZHRoID0gMjYgKiAyO1xuICAgICAgICBjb21wYXNzQ2FudmFzLmhlaWdodCA9IDI2ICogMjtcblxuICAgICAgICB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uQ29tcGFzc0Rvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc01vdmUgPSB0aGlzLl9vbkNvbXBhc3NNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc1VwID0gdGhpcy5fb25Db21wYXNzVXAuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzQ3R4ID0gY29tcGFzc0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIG1hcC5vbigncm90YXRlJywgdGhpcy5fZHJhd05vcnRoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kcmF3Tm9ydGgoKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc01vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHggPSBlLnNjcmVlblgsXG4gICAgICAgICAgICBkID0geCA8IDIgPyAtNSA6IC8vIGxlZnQgZWRnZSBvZiB0aGUgc2NyZWVuLCBjb250aW51ZSByb3RhdGluZ1xuICAgICAgICAgICAgICAgIHggPiB3aW5kb3cuc2NyZWVuLndpZHRoIC0gMiA/IDUgOiAvLyByaWdodCBlZGdlXG4gICAgICAgICAgICAgICAgKHggLSB0aGlzLl9wcmV2WCkgLyA0O1xuXG4gICAgICAgIHRoaXMuX21hcC5zZXRCZWFyaW5nKHRoaXMuX21hcC5nZXRCZWFyaW5nKCkgLSBkKTtcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcbiAgICAgICAgRE9NLmVuYWJsZURyYWcoKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24oY2xhc3NOYW1lLCBmbikge1xuICAgICAgICB2YXIgYSA9IERPTS5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGEuaHJlZiA9ICcjJztcbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgX2RyYXdOb3J0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYWQgPSAyMCxcbiAgICAgICAgICAgIHdpZHRoID0gOCxcbiAgICAgICAgICAgIGNlbnRlciA9IDI2LFxuICAgICAgICAgICAgYW5nbGUgPSB0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICsgKE1hdGguUEkgLyAyKSxcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2NvbXBhc3NDdHg7XG5cbiAgICAgICAgdGhpcy5fY29tcGFzc0NhbnZhcy53aWR0aCA9IHRoaXMuX2NvbXBhc3NDYW52YXMud2lkdGg7XG5cbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgY3R4LmxpbmVUbygwLCAtd2lkdGgpO1xuICAgICAgICBjdHgubGluZVRvKC1yYWQsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIHdpZHRoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2JiYic7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgd2lkdGgpO1xuICAgICAgICBjdHgubGluZVRvKHJhZCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDQ7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB3aWR0aCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwuanMnKSxcbiAgICBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyksXG4gICAgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdGxuZy5qcycpLFxuICAgIExhdExuZ0JvdW5kcyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmdib3VuZHMuanMnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbnV0aWwuZXh0ZW5kKGV4cG9ydHMsIHtcbiAgICBpc0Vhc2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zdG9wRm47XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BGbikge1xuICAgICAgICAgICAgdGhpcy5fc3RvcEZuKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcEZuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYW5CeTogZnVuY3Rpb24ob2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB1dGlsLmV4dGVuZCh7b2Zmc2V0OiBQb2ludC5jb252ZXJ0KG9mZnNldCkubXVsdCgtMSl9LCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYW5UbzogZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIGxhdGxuZyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZSxcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkucm90YXRlKC10ci5hbmdsZSksXG4gICAgICAgICAgICBmcm9tID0gdHIucG9pbnQsXG4gICAgICAgICAgICB0byA9IHRyLnByb2plY3QobGF0bG5nKS5zdWIob2Zmc2V0KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdG9wRm4gPSBicm93c2VyLnRpbWVkKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdChvcHRpb25zLmVhc2luZyh0KSkpKTtcbiAgICAgICAgICAgIHRoaXMuX21vdmUoKTtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblxuICAgICAgICB9LCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlID8gMCA6IG9wdGlvbnMuZHVyYXRpb24sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBab29tcyB0byBhIGNlcnRhaW4gem9vbSBsZXZlbCB3aXRoIGVhc2luZy5cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDBcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBhcm91bmQgPSB0ci5jZW50ZXIsXG4gICAgICAgICAgICBlYXNpbmcgPSB0aGlzLl91cGRhdGVFYXNpbmcob3B0aW9ucy5kdXJhdGlvbiwgem9vbSwgb3B0aW9ucy5lYXNpbmcpLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdHIuem9vbTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hcm91bmQpIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IExhdExuZy5jb252ZXJ0KG9wdGlvbnMuYXJvdW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQoUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSBvcHRpb25zLmR1cmF0aW9uID0gMDtcblxuICAgICAgICBpZiAoIXRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdG9wRm4gPSBicm93c2VyLnRpbWVkKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHRyLnNldFpvb21Bcm91bmQodXRpbC5pbnRlcnAoc3RhcnRab29tLCB6b29tLCBlYXNpbmcodCkpLCBhcm91bmQpO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmFuaW1hdGlvbkxvb3Auc2V0KDMwMCk7IC8vIHRleHQgZmFkaW5nXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKHRydWUpO1xuXG4gICAgICAgICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWFzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPj0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgb3B0aW9ucy5kdXJhdGlvbiwgdGhpcyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPCAyMDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vblpvb21FbmQpO1xuICAgICAgICAgICAgdGhpcy5fb25ab29tRW5kID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHpvb21JbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLnpvb21Ubyh0aGlzLmdldFpvb20oKSArIDEsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICB6b29tT3V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpIC0gMSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbihiZWFyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgYXJvdW5kID0gdHIuY2VudGVyO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFyb3VuZCkge1xuICAgICAgICAgICAgYXJvdW5kID0gTGF0TG5nLmNvbnZlcnQob3B0aW9ucy5hcm91bmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICBhcm91bmQgPSB0ci5wb2ludExvY2F0aW9uKHRyLmNlbnRlclBvaW50LmFkZChQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb3RhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cbiAgICAgICAgdGhpcy5fc3RvcEZuID0gYnJvd3Nlci50aW1lZChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgeyB0aGlzLnJvdGF0aW5nID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHRyLnNldEJlYXJpbmdBcm91bmQodXRpbC5pbnRlcnAoc3RhcnQsIGJlYXJpbmcsIG9wdGlvbnMuZWFzaW5nKHQpKSwgYXJvdW5kKTtcbiAgICAgICAgICAgIHRoaXMuX21vdmUoZmFsc2UsIHRydWUpLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVzZXROb3J0aDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVUbygwLCB1dGlsLmV4dGVuZCh7ZHVyYXRpb246IDEwMDB9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIGZpdEJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIG1heFpvb206IEluZmluaXR5XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGJvdW5kcyA9IExhdExuZ0JvdW5kcy5jb252ZXJ0KGJvdW5kcyk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLFxuICAgICAgICAgICAgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG53ID0gdHIucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxuICAgICAgICAgICAgc2UgPSB0ci5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSksXG4gICAgICAgICAgICBzaXplID0gc2Uuc3ViKG53KSxcbiAgICAgICAgICAgIGNlbnRlciA9IHRyLnVucHJvamVjdChudy5hZGQoc2UpLmRpdigyKSksXG5cbiAgICAgICAgICAgIHNjYWxlWCA9ICh0ci53aWR0aCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXQueCkgKiAyKSAvIHNpemUueCxcbiAgICAgICAgICAgIHNjYWxlWSA9ICh0ci5oZWlnaHQgLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LnkpICogMikgLyBzaXplLnksXG5cbiAgICAgICAgICAgIHpvb20gPSBNYXRoLm1pbih0ci5zY2FsZVpvb20odHIuc2NhbGUgKiBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zLmxpbmVhciA/XG4gICAgICAgICAgICB0aGlzLmVhc2VUbyhjZW50ZXIsIHpvb20sIDAsIG9wdGlvbnMpIDpcbiAgICAgICAgICAgIHRoaXMuZmx5VG8oY2VudGVyLCB6b29tLCAwLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZWFzZVRvOiBmdW5jdGlvbihsYXRsbmcsIHpvb20sIGJlYXJpbmcsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgbGF0bG5nID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKTtcblxuICAgICAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogem9vbTtcbiAgICAgICAgYmVhcmluZyA9IGJlYXJpbmcgPT09IHVuZGVmaW5lZCA/IHN0YXJ0QmVhcmluZyA6IGJlYXJpbmc7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSB0ci5wcm9qZWN0KGxhdGxuZykuc3ViKG9mZnNldC5kaXYoc2NhbGUpKSxcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLnBvaW50TG9jYXRpb24odHIuY2VudGVyUG9pbnQuYWRkKHRvLnN1Yihmcm9tKS5kaXYoMSAtIDEgLyBzY2FsZSkpKTtcblxuICAgICAgICBpZiAoem9vbSAhPT0gc3RhcnRab29tKSB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKSB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXG4gICAgICAgIHRoaXMuX3N0b3BGbiA9IGJyb3dzZXIudGltZWQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBrID0gb3B0aW9ucy5lYXNpbmcodCk7XG5cbiAgICAgICAgICAgIGlmICh6b29tICE9PSBzdGFydFpvb20pIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRab29tQXJvdW5kKHN0YXJ0Wm9vbSArIGsgKiAoem9vbSAtIHN0YXJ0Wm9vbSksIGFyb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVhcmluZyAhPT0gc3RhcnRCZWFyaW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IHV0aWwuaW50ZXJwKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcbiAgICAgICAgICAgIHRoaXMuX21vdmUoem9vbSAhPT0gc3RhcnRab29tLCBiZWFyaW5nICE9PSBzdGFydEJlYXJpbmcpO1xuXG4gICAgICAgICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlID8gMCA6IG9wdGlvbnMuZHVyYXRpb24sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmbHlUbzogZnVuY3Rpb24obGF0bG5nLCB6b29tLCBiZWFyaW5nLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgICAgc3BlZWQ6IDEuMixcbiAgICAgICAgICAgIGN1cnZlOiAxLjQyLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgbGF0bG5nID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKTtcblxuICAgICAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogem9vbTtcbiAgICAgICAgYmVhcmluZyA9IGJlYXJpbmcgPT09IHVuZGVmaW5lZCA/IHN0YXJ0QmVhcmluZyA6IGJlYXJpbmc7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSB0ci5wcm9qZWN0KGxhdGxuZykuc3ViKG9mZnNldC5kaXYoc2NhbGUpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0VmlldyhsYXRsbmcsIHpvb20sIGJlYXJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0V29ybGRTaXplID0gdHIud29ybGRTaXplLFxuICAgICAgICAgICAgcmhvID0gb3B0aW9ucy5jdXJ2ZSxcbiAgICAgICAgICAgIFYgPSBvcHRpb25zLnNwZWVkLFxuXG4gICAgICAgICAgICB3MCA9IE1hdGgubWF4KHRyLndpZHRoLCB0ci5oZWlnaHQpLFxuICAgICAgICAgICAgdzEgPSB3MCAvIHNjYWxlLFxuICAgICAgICAgICAgdTEgPSB0by5zdWIoZnJvbSkubWFnKCksXG4gICAgICAgICAgICByaG8yID0gcmhvICogcmhvO1xuXG4gICAgICAgIGZ1bmN0aW9uIHIoaSkge1xuICAgICAgICAgICAgdmFyIGIgPSAodzEgKiB3MSAtIHcwICogdzAgKyAoaSA/IC0xIDogMSkgKiByaG8yICogcmhvMiAqIHUxICogdTEpIC8gKDIgKiAoaSA/IHcxIDogdzApICogcmhvMiAqIHUxKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxuICAgICAgICBmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XG4gICAgICAgIGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cblxuICAgICAgICB2YXIgcjAgPSByKDApLFxuICAgICAgICAgICAgdyA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9LFxuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiB3MCAqICgoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yKSAvIHUxOyB9LFxuICAgICAgICAgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyh1MSkgPCAwLjAwMDAwMSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHcwIC0gdzEpIDwgMC4wMDAwMDEpIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgayA9IHcxIDwgdzAgPyAtMSA6IDE7XG4gICAgICAgICAgICBTID0gTWF0aC5hYnMoTWF0aC5sb2codzEgLyB3MCkpIC8gcmhvO1xuXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuICAgICAgICAgICAgdyA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIE1hdGguZXhwKGsgKiByaG8gKiBzKTsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDEwMDAgKiBTIC8gVjtcblxuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9IGJlYXJpbmcpIHRoaXMucm90YXRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cbiAgICAgICAgdGhpcy5fc3RvcEZuID0gYnJvd3Nlci50aW1lZChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25zLmVhc2luZyh0KSxcbiAgICAgICAgICAgICAgICBzID0gayAqIFMsXG4gICAgICAgICAgICAgICAgdXMgPSB1KHMpO1xuXG4gICAgICAgICAgICB0ci56b29tID0gc3RhcnRab29tICsgdHIuc2NhbGVab29tKDEgLyB3KHMpKTtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdCh1cykpLCBzdGFydFdvcmxkU2l6ZSk7XG5cbiAgICAgICAgICAgIGlmIChiZWFyaW5nICE9PSBzdGFydEJlYXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5iZWFyaW5nID0gdXRpbC5pbnRlcnAoc3RhcnRCZWFyaW5nLCBiZWFyaW5nLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdHlsZS5hbmltYXRpb25Mb29wLnNldCgzMDApOyAvLyB0ZXh0IGZhZGluZ1xuXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKHRydWUsIGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZyk7XG5cbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkdXJhdGlvbiwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91cGRhdGVFYXNpbmc6IGZ1bmN0aW9uKGR1cmF0aW9uLCB6b29tLCBiZXppZXIpIHtcbiAgICAgICAgdmFyIGVhc2luZztcblxuICAgICAgICBpZiAodGhpcy5lYXNlKSB7XG4gICAgICAgICAgICB2YXIgZWFzZSA9IHRoaXMuZWFzZSxcbiAgICAgICAgICAgICAgICB0ID0gKERhdGUubm93KCkgLSBlYXNlLnN0YXJ0KSAvIGVhc2UuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgc3BlZWQgPSBlYXNlLmVhc2luZyh0ICsgMC4wMSkgLSBlYXNlLmVhc2luZyh0KSxcblxuICAgICAgICAgICAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbWFrZSBuZXcgYmV6aWVyIHRoYXQgaXMgY29udGludW91cyB3aXRoIGxhc3RcbiAgICAgICAgICAgICAgICB4ID0gMC4yNyAvIE1hdGguc3FydChzcGVlZCAqIHNwZWVkICsgMC4wMDAxKSAqIDAuMDEsXG4gICAgICAgICAgICAgICAgeSA9IE1hdGguc3FydCgwLjI3ICogMC4yNyAtIHggKiB4KTtcblxuICAgICAgICAgICAgZWFzaW5nID0gdXRpbC5iZXppZXIoeCwgeSwgMC4yNSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNpbmcgPSBiZXppZXIgPyB1dGlsLmJlemllci5hcHBseSh1dGlsLCBiZXppZXIpIDogdXRpbC5lYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgaW5mb3JtYXRpb24gb24gY3VycmVudCBlYXNpbmdcbiAgICAgICAgdGhpcy5lYXNlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICB0bzogTWF0aC5wb3coMiwgem9vbSksXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IGVhc2luZ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBlYXNpbmc7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJhY3Rpb24uanMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZXJzO1xuXG5mdW5jdGlvbiBIYW5kbGVycyhtYXApIHtcblxuICAgIHZhciByb3RhdGVFbmQ7XG5cbiAgICB2YXIgaW5lcnRpYUxpbmVhcml0eSA9IDAuMixcbiAgICAgICAgaW5lcnRpYUVhc2luZyA9IHV0aWwuYmV6aWVyKDAsIDAsIGluZXJ0aWFMaW5lYXJpdHksIDEpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBJbnRlcmFjdGlvbihtYXAuY29udGFpbmVyKVxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbWFwLmZpcmUoJ2NsaWNrJywgZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignaG92ZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBtYXAuZmlyZSgnaG92ZXInLCBlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFwLmZpcmUoJ21vdmVzdGFydCcpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgICAgIG1hcC5yZXNpemUoKTtcbiAgICAgICAgICAgIG1hcC51cGRhdGUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdwYW4nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBtYXAuc3RvcCgpO1xuICAgICAgICAgICAgbWFwLnRyYW5zZm9ybS5wYW5CeShlLm9mZnNldCk7XG4gICAgICAgICAgICBtYXAuX21vdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdwYW5lbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIWUuaW5lcnRpYSkgbWFwLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmVsb2NpdHkgdG8gcHgvcyAmIGFkanVzdCBmb3IgaW5jcmVhc2VkIGluaXRpYWwgYW5pbWF0aW9uIHNwZWVkIHdoZW4gZWFzaW5nIG91dFxuICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IGUuaW5lcnRpYS5tdWx0KDEwMDAgKiBpbmVydGlhTGluZWFyaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgPSB2ZWxvY2l0eS5tYWcoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXhTcGVlZCA9IDQwMDA7IC8vIHB4L3NcblxuICAgICAgICAgICAgICAgIGlmIChzcGVlZCA+PSBtYXhTcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IG1heFNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eS5fdW5pdCgpLl9tdWx0KG1heFNwZWVkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVjZWxlcmF0aW9uID0gODAwMCwgLy8gcHgvc14yXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3BlZWQgLyAoZGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHZlbG9jaXR5Lm11bHQoLWR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ3pvb20nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBTY2FsZSBieSBzaWdtb2lkIG9mIHNjcm9sbCB3aGVlbCBkZWx0YS5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhlLmRlbHRhIC8gMTAwKSkpO1xuICAgICAgICAgICAgaWYgKGUuZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSBzY2FsZSA9IDEgLyBzY2FsZTtcblxuICAgICAgICAgICAgdmFyIGZyb21TY2FsZSA9IG1hcC5lYXNlICYmIGlzRmluaXRlKGUuZGVsdGEpID8gbWFwLmVhc2UudG8gOiBtYXAudHJhbnNmb3JtLnNjYWxlLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gIWlzRmluaXRlKGUuZGVsdGEpID8gODAwIDogZS5zb3VyY2UgPT0gJ3RyYWNrcGFkJyA/IDAgOiAzMDA7XG5cbiAgICAgICAgICAgIG1hcC56b29tVG8obWFwLnRyYW5zZm9ybS5zY2FsZVpvb20oZnJvbVNjYWxlICogc2NhbGUpLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGFyb3VuZDogbWFwLnVucHJvamVjdChlLnBvaW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigncm90YXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IG1hcC50cmFuc2Zvcm0uY2VudGVyUG9pbnQsIC8vIENlbnRlciBvZiByb3RhdGlvblxuICAgICAgICAgICAgICAgIHN0YXJ0VG9DZW50ZXIgPSBlLnN0YXJ0LnN1YihjZW50ZXIpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VG9DZW50ZXJEaXN0ID0gc3RhcnRUb0NlbnRlci5tYWcoKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNsaWNrIHdhcyB0b28gY2xvc2UgdG8gdGhlIGNlbnRlciwgbW92ZSB0aGUgY2VudGVyIG9mIHJvdGF0aW9uIGJ5IDIwMCBwaXhlbHNcbiAgICAgICAgICAgIC8vIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNsaWNrLlxuICAgICAgICAgICAgaWYgKHN0YXJ0VG9DZW50ZXJEaXN0IDwgMjAwKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gZS5zdGFydC5hZGQobmV3IFBvaW50KC0yMDAsIDApLl9yb3RhdGUoc3RhcnRUb0NlbnRlci5hbmdsZSgpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiZWFyaW5nRGlmZiA9IGUucHJldi5zdWIoY2VudGVyKS5hbmdsZVdpdGgoZS5jdXJyZW50LnN1YihjZW50ZXIpKSAvIE1hdGguUEkgKiAxODA7XG4gICAgICAgICAgICBtYXAudHJhbnNmb3JtLmJlYXJpbmcgPSBtYXAuZ2V0QmVhcmluZygpIC0gYmVhcmluZ0RpZmY7XG5cbiAgICAgICAgICAgIG1hcC5fbW92ZShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocm90YXRlRW5kKTtcbiAgICAgICAgICAgIHJvdGF0ZUVuZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1hcC5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1hcC5fcmVyZW5kZXIoKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyk7XG5cbmZ1bmN0aW9uIEhhc2gobWFwKSB7XG4gICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLm9uaGFzaC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgbWFwLm9uKCdtb3ZlJywgdXRpbC5kZWJvdW5jZSh0aGlzLnVwZGF0ZUhhc2guYmluZCh0aGlzKSwgMTAwKSk7XG59XG5cbkhhc2gucHJvdG90eXBlID0ge1xuICAgIG9uaGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2MgPSBsb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKGxvYy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0VmlldyhbK2xvY1sxXSwgK2xvY1syXV0sICtsb2NbMF0sICsobG9jWzNdIHx8IDApKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlSGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLm1hcC5nZXRDZW50ZXIoKSxcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLm1hcC5nZXRab29tKCksXG4gICAgICAgICAgICBiZWFyaW5nID0gdGhpcy5tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nKHpvb20pIC8gTWF0aC5MTjIpKSxcblxuICAgICAgICAgICAgaGFzaCA9ICcjJyArIChNYXRoLnJvdW5kKHpvb20gKiAxMDApIC8gMTAwKSArXG4gICAgICAgICAgICAgICAgJy8nICsgY2VudGVyLmxhdC50b0ZpeGVkKHByZWNpc2lvbikgK1xuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sbmcudG9GaXhlZChwcmVjaXNpb24pICtcbiAgICAgICAgICAgICAgICAoYmVhcmluZyA/ICcvJyArIChNYXRoLnJvdW5kKGJlYXJpbmcgKiAxMCkgLyAxMCkgOiAnJyk7XG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCcnLCAnJywgaGFzaCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQuanMnKSxcbiAgICBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uO1xuXG5mdW5jdGlvbiBJbnRlcmFjdGlvbihlbCkge1xuICAgIHZhciBpbnRlcmFjdGlvbiA9IHRoaXM7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gICAgdmFyIHJvdGF0aW5nID0gZmFsc2UsXG4gICAgICAgIHBhbm5lZCA9IGZhbHNlLFxuICAgICAgICBmaXJzdFBvcyA9IG51bGwsXG4gICAgICAgIHBvcyA9IG51bGwsXG4gICAgICAgIGluZXJ0aWEgPSBudWxsLFxuICAgICAgICBub3c7XG5cbiAgICBmdW5jdGlvbiBtb3VzZVBvcyhlKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgICAgICAgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3ApO1xuICAgIH1cblxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgcm90YXRpbmcgPSB0cnVlO1xuICAgICAgICBmaXJzdFBvcyA9IHBvcyA9IG1vdXNlUG9zKGV2KTtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25tb3VzZWRvd24sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25tb3VzZXVwLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25tb3VzZW1vdmUsIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uY2xpY2ssIGZhbHNlKTtcbiAgICBzY3JvbGx3aGVlbCh6b29tKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIG9uZG91YmxlY2xpY2ssIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiB6b29tKHR5cGUsIGRlbHRhLCBwb2ludCkge1xuICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCd6b29tJywge1xuICAgICAgICAgICAgc291cmNlOiB0eXBlLFxuICAgICAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICAgICAgcG9pbnQ6IHBvaW50XG4gICAgICAgIH0pO1xuICAgICAgICBpbmVydGlhID0gbnVsbDtcbiAgICAgICAgbm93ID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGljayhwb2ludCkge1xuICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdjbGljaycsIHtwb2ludDogcG9pbnR9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBob3Zlcihwb2ludCkge1xuICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdob3ZlcicsIHtwb2ludDogcG9pbnR9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYW4ocG9pbnQpIHtcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHBvcy5zdWIocG9pbnQpO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgncGFuJywge29mZnNldDogb2Zmc2V0fSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbiBhdmVyYWdlZCB2ZXJzaW9uIG9mIHRoaXMgbW92ZW1lbnQgdG8gdGhlIGluZXJ0aWEgdmVjdG9yXG4gICAgICAgICAgICBpZiAoaW5lcnRpYSkge1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgICAgICAgICAgLy8gc29tZXRpbWVzIGl0J3MgMCBhZnRlciBzb21lIGVycmF0aWMgcGFuaW5nXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gZHVyYXRpb24gKyBub3c7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWEucHVzaChbdGltZSwgcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMiAmJiB0aW1lIC0gaW5lcnRpYVswXVswXSA+IDEwMCkgaW5lcnRpYS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmVydGlhID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcG9zID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3Jlc2l6ZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvdGF0ZShwb2ludCkge1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdyb3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0UG9zLFxuICAgICAgICAgICAgICAgIHByZXY6IHBvcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBwb2ludFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubW91c2Vkb3duKGV2KSB7XG4gICAgICAgIGZpcnN0UG9zID0gcG9zID0gbW91c2VQb3MoZXYpO1xuICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdkb3duJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25tb3VzZXVwKCkge1xuICAgICAgICBwYW5uZWQgPSBwb3MgJiYgZmlyc3RQb3MgJiYgKHBvcy54ICE9IGZpcnN0UG9zLnggfHwgcG9zLnkgIT0gZmlyc3RQb3MueSk7XG5cbiAgICAgICAgcm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcG9zID0gbnVsbDtcblxuICAgICAgICBpZiAoaW5lcnRpYSAmJiBpbmVydGlhLmxlbmd0aCA+PSAyICYmIG5vdyA+IERhdGUubm93KCkgLSAxMDApIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IGxhc3RbMV0uc3ViKGZpcnN0WzFdKS5kaXYobGFzdFswXSAtIGZpcnN0WzBdKTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3BhbmVuZCcsICB7aW5lcnRpYTogdmVsb2NpdHl9KTtcblxuICAgICAgICB9IGVsc2UgaW50ZXJhY3Rpb24uZmlyZSgncGFuZW5kJyk7XG5cbiAgICAgICAgaW5lcnRpYSA9IG51bGw7XG4gICAgICAgIG5vdyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25tb3VzZW1vdmUoZXYpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gbW91c2VQb3MoZXYpO1xuXG4gICAgICAgIGlmIChyb3RhdGluZykgeyByb3RhdGUocG9pbnQpOyB9XG4gICAgICAgIGVsc2UgaWYgKHBvcykgcGFuKHBvaW50KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudG9FbGVtZW50O1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT0gZWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUpIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBlbCkge1xuICAgICAgICAgICAgICAgIGhvdmVyKHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2xpY2soZXYpIHtcbiAgICAgICAgaWYgKCFwYW5uZWQpIGNsaWNrKG1vdXNlUG9zKGV2KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25kb3VibGVjbGljayhldikge1xuICAgICAgICB6b29tKCd3aGVlbCcsIEluZmluaXR5ICogKGV2LnNoaWZ0S2V5ID8gLTEgOiAxKSwgbW91c2VQb3MoZXYpKTtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGx3aGVlbChjYWxsYmFjaykge1xuICAgICAgICB2YXIgZmlyZWZveCA9IC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgdmFyIHNhZmFyaSA9IC9TYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQ2hyb20oaXVtfGUpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgdmFyIHRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgRGF0ZTtcblxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHdoZWVsLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIGxhc3RFdmVudCA9IDA7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgdHlwZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gbnVsbDtcblxuICAgICAgICBmdW5jdGlvbiBzY3JvbGwodmFsdWUsIGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RhbXAgPSB0aW1lLm5vdygpO1xuICAgICAgICAgICAgdmFyIHRpbWVEZWx0YSA9IHN0YW1wIC0gbGFzdEV2ZW50O1xuICAgICAgICAgICAgbGFzdEV2ZW50ID0gc3RhbXA7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IG1vdXNlUG9zKGV2KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmICh2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSBtb3VzZSB3aGVlbCBldmVudC5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgNCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSB0cmFja3BhZCBldmVudCBiZWNhdXNlIGl0IGlzIHNvIHNtYWxsLlxuICAgICAgICAgICAgICAgIHR5cGUgPSAndHJhY2twYWQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lRGVsdGEgPiA0MDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG5ldyBzY3JvbGwgYWN0aW9uLlxuICAgICAgICAgICAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWx5IGl0XG4gICAgICAgICAgICAgICAgLy8gYnkgdXAgdG8gNDBtcy5cbiAgICAgICAgICAgICAgICB0eXBlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnd2hlZWwnO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0eXBlLCAtaW5pdGlhbFZhbHVlLCBwb2ludCk7XG4gICAgICAgICAgICAgICAgfSwgNDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJlcGVhdGluZyBldmVudCwgYnV0IHdlIGRvbid0IGtub3cgdGhlIHR5cGUgb2YgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHlldC4gSWYgdGhlIGRlbHRhIHBlciB0aW1lIGlzIHNtYWxsLCB3ZSBhc3N1bWUgaXQncyBhXG4gICAgICAgICAgICAgICAgLy8gZmFzdCB0cmFja3BhZDsgb3RoZXJ3aXNlIHdlIHN3aXRjaCBpbnRvIHdoZWVsIG1vZGUuXG4gICAgICAgICAgICAgICAgdHlwZSA9IChNYXRoLmFicyh0aW1lRGVsdGEgKiB2YWx1ZSkgPCAyMDApID8gJ3RyYWNrcGFkJyA6ICd3aGVlbCc7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2VcbiAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBwcmV2aW91cyBldmVudCAod2hpY2ggd2FzIGxlc3MgdGhhbiA0MG1zIGFnbykgaW50b1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0eXBlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBmaXJlIHRoZSBjYWxsYmFjayBpZiB3ZSBhY3R1YWxseSBrbm93IHdoYXQgdHlwZSBvZiBzY3JvbGxpbmdcbiAgICAgICAgICAgIC8vIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0eXBlLCAtdmFsdWUsIHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdoZWVsKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVkgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIGRlbHRhWSAvPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIGRlbHRhWSAqPSA0MDtcbiAgICAgICAgICAgIHNjcm9sbChkZWx0YVksIGUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW91c2V3aGVlbChlKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGFZID0gLWUud2hlZWxEZWx0YVk7XG4gICAgICAgICAgICBpZiAoc2FmYXJpKSBkZWx0YVkgPSBkZWx0YVkgLyAzO1xuICAgICAgICAgICAgc2Nyb2xsKGRlbHRhWSwgZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vdXRpbC9kaXNwYXRjaGVyLmpzJyksXG4gICAgQ2FudmFzID0gcmVxdWlyZSgnLi4vdXRpbC9jYW52YXMuanMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsLmpzJyksXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3Nlci5qcycpLFxuICAgIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXguanMnKSxcbiAgICBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkLmpzJyksXG5cbiAgICBTdHlsZSA9IHJlcXVpcmUoJy4uL3N0eWxlL3N0eWxlLmpzJyksXG4gICAgQW5pbWF0aW9uTG9vcCA9IHJlcXVpcmUoJy4uL3N0eWxlL2FuaW1hdGlvbmxvb3AuanMnKSxcbiAgICBHTFBhaW50ZXIgPSByZXF1aXJlKCcuLi9yZW5kZXIvcGFpbnRlci5qcycpLFxuXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vZ2VvL3RyYW5zZm9ybS5qcycpLFxuICAgIEhhc2ggPSByZXF1aXJlKCcuL2hhc2guanMnKSxcbiAgICBIYW5kbGVycyA9IHJlcXVpcmUoJy4vaGFuZGxlcnMuanMnKSxcbiAgICBTb3VyY2UgPSByZXF1aXJlKCcuLi9zb3VyY2Uvc291cmNlLmpzJyksXG4gICAgRWFzaW5ncyA9IHJlcXVpcmUoJy4vZWFzaW5ncy5qcycpLFxuICAgIExhdExuZyA9IHJlcXVpcmUoJy4uL2dlby9sYXRsbmcuanMnKSxcbiAgICBMYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbGF0bG5nYm91bmRzLmpzJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIEdseXBoU291cmNlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoc291cmNlLmpzJyksXG4gICAgQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL2NvbnRyb2wvYXR0cmlidXRpb24uanMnKTtcblxuLy8gYWxsb3cgcmVkZWZpbmluZyBNYXAgaGVyZSAoanNoaW50IHRoaW5rcyBpdCdzIGdsb2JhbClcbi8vIGpzaGludCAtVzA3OVxuXG52YXIgTWFwID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5pbmhlcml0KHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSBuZXcgQW5pbWF0aW9uTG9vcCgpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG4gICAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoICYmIG5ldyBIYXNoKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHZhciBiID0gTGF0TG5nQm91bmRzLmNvbnZlcnQob3B0aW9ucy5tYXhCb3VuZHMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtiLmdldFNvdXRoKCksIGIuZ2V0Tm9ydGgoKV07XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW2IuZ2V0V2VzdCgpLCBiLmdldEVhc3QoKV07XG4gICAgfVxuXG4gICAgdGhpcy5fb25TdHlsZUNoYW5nZSA9IHRoaXMuX29uU3R5bGVDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGVCdWNrZXRzID0gdGhpcy5fdXBkYXRlQnVja2V0cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NldHVwQ29udGFpbmVyKCk7XG4gICAgdGhpcy5fc2V0dXBQYWludGVyKCk7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0gb3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBuZXcgSGFuZGxlcnModGhpcyk7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoTWF0aC5tYXgob3B0aW9ucy5udW1Xb3JrZXJzLCAxKSwgdGhpcyk7XG5cbiAgICAgLy8gZG9uJ3Qgc2V0IHBvc2l0aW9uIGZyb20gb3B0aW9ucyBpZiBzZXQgdGhyb3VnaCBoYXNoXG4gICAgaWYgKCF0aGlzLmhhc2ggfHwgIXRoaXMuaGFzaC5vbmhhc2goKSkge1xuICAgICAgICB0aGlzLnNldFZpZXcob3B0aW9ucy5jZW50ZXIsIG9wdGlvbnMuem9vbSwgb3B0aW9ucy5iZWFyaW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcbiAgICB0aGlzLnN0YWNrcyA9IHt9O1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihvcHRpb25zLnN0eWxlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKGRhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkgdGhpcy5hZGRDb250cm9sKG5ldyBBdHRyaWJ1dGlvbigpKTtcbn07XG5cbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIEV2ZW50ZWQpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgRWFzaW5ncyk7XG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCB7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgICB6b29tOiAwLFxuICAgICAgICBiZWFyaW5nOiAwLFxuXG4gICAgICAgIG1pblpvb206IDAsXG4gICAgICAgIG1heFpvb206IDIwLFxuICAgICAgICBudW1Xb3JrZXJzOiBicm93c2VyLmhhcmR3YXJlQ29uY3VycmVuY3kgLSAxLFxuXG4gICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICBoYXNoOiBmYWxzZSxcblxuICAgICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcbiAgICB9LFxuXG4gICAgYWRkU291cmNlOiBmdW5jdGlvbihpZCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlc1tpZF0gPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZS5pZCA9IGlkO1xuICAgICAgICBpZiAoc291cmNlLm9uQWRkKSB7XG4gICAgICAgICAgICBzb3VyY2Uub25BZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS5lbmFibGVkKSBzb3VyY2UuZmlyZSgnc291cmNlLmFkZCcsIHtzb3VyY2U6IHNvdXJjZX0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlU291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICAgICAgaWYgKHNvdXJjZS5vblJlbW92ZSkge1xuICAgICAgICAgICAgc291cmNlLm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZXNbaWRdO1xuICAgICAgICByZXR1cm4gdGhpcy5maXJlKCdzb3VyY2UucmVtb3ZlJywge3NvdXJjZTogc291cmNlfSk7XG4gICAgfSxcblxuICAgIGFkZENvbnRyb2w6IGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5hZGRUbyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgbWFwJ3MgY2VudGVyLCB6b29tLCBhbmQgYmVhcmluZ1xuICAgIHNldFZpZXc6IGZ1bmN0aW9uKGNlbnRlciwgem9vbSwgYmVhcmluZykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gdHIuem9vbSAhPT0gK3pvb20sXG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IHRyLmJlYXJpbmcgIT09ICtiZWFyaW5nO1xuXG4gICAgICAgIHRyLmNlbnRlciA9IExhdExuZy5jb252ZXJ0KGNlbnRlcik7XG4gICAgICAgIHRyLnpvb20gPSArem9vbTtcbiAgICAgICAgdHIuYmVhcmluZyA9ICtiZWFyaW5nO1xuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5fbW92ZSh6b29tQ2hhbmdlZCwgYmVhcmluZ0NoYW5nZWQpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZWVuZCcpO1xuICAgIH0sXG5cbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgICB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLmdldFpvb20oKSwgdGhpcy5nZXRCZWFyaW5nKCkpO1xuICAgIH0sXG5cbiAgICBzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB0aGlzLmdldEJlYXJpbmcoKSk7XG4gICAgfSxcblxuICAgIHNldEJlYXJpbmc6IGZ1bmN0aW9uKGJlYXJpbmcpIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpLCBiZWFyaW5nKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmNlbnRlcjsgfSxcbiAgICBnZXRab29tOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnpvb207IH0sXG4gICAgZ2V0QmVhcmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5iZWFyaW5nOyB9LFxuXG4gICAgLy8gRGV0ZWN0IHRoZSBtYXAncyBuZXcgd2lkdGggYW5kIGhlaWdodCBhbmQgcmVzaXplIGl0LlxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDAsIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IDQwMDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCB8fCAzMDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5fY29uc3RyYWluKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5zcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc3ByaXRlLnJlc2l6ZSh0aGlzLnBhaW50ZXIuZ2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYWludGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gICAgICAgICAgICAuX21vdmUoKVxuICAgICAgICAgICAgLmZpcmUoJ3Jlc2l6ZScpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZWVuZCcpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24obmV3IFBvaW50KDAsIDApKSxcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24odGhpcy50cmFuc2Zvcm0uc2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwcm9qZWN0OiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2F0aW9uUG9pbnQoTGF0TG5nLmNvbnZlcnQobGF0bG5nKSk7XG4gICAgfSxcbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKFBvaW50LmNvbnZlcnQocG9pbnQpKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzO1xuXG4gICAgICAgIHBvaW50ID0gUG9pbnQuY29udmVydChwb2ludCk7XG5cbiAgICAgICAgdXRpbC5hc3luY0VhY2goT2JqZWN0LmtleXModGhpcy5zb3VyY2VzKSwgZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gbWFwLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgc291cmNlLmZlYXR1cmVzQXQocG9pbnQsIHBhcmFtcywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSBmZWF0dXJlcyA9IGZlYXR1cmVzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5vZmYoJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUoc3R5bGUsIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlcyA9IHRoaXMuc3R5bGUuc3R5bGVzaGVldC5zb3VyY2VzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNvdXJjZShpZCwgU291cmNlLmNyZWF0ZShzb3VyY2VzW2lkXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbHlwaFNvdXJjZSA9IG5ldyBHbHlwaFNvdXJjZSh0aGlzLnN0eWxlLnN0eWxlc2hlZXQuZ2x5cGhzLCB0aGlzLnBhaW50ZXIuZ2x5cGhBdGxhcyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5vbignY2hhbmdlJywgdGhpcy5fb25TdHlsZUNoYW5nZSk7XG5cbiAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RpbGVzRGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1Y2tldHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlR2x5cGhzKCk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdzdHlsZS5jaGFuZ2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX21vdmU6IGZ1bmN0aW9uICh6b29tLCByb3RhdGUpIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh6b29tKS5maXJlKCdtb3ZlJyk7XG5cbiAgICAgICAgaWYgKHpvb20pIHRoaXMuZmlyZSgnem9vbScpO1xuICAgICAgICBpZiAocm90YXRlKSB0aGlzLmZpcmUoJ3JvdGF0ZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBtYXAgc2V0dXAgY29kZVxuXG4gICAgX3NldHVwQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyID0gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICAgICAgICBpZiAoY29udGFpbmVyKSBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtbWFwJyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLCBjb250YWluZXIpO1xuICAgIH0sXG5cbiAgICBfc2V0dXBQYWludGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jYW52YXMuZ2V0V2ViR0xDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgR0xQYWludGVyKGdsLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIF9jb250ZXh0TG9zdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuY2FuY2VsRnJhbWUodGhpcy5fZnJhbWVJZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbnRleHRSZXN0b3JlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsYmFja3MgZnJvbSB3ZWIgd29ya2Vyc1xuXG4gICAgJ2RlYnVnIG1lc3NhZ2UnOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAnYWxlcnQgbWVzc2FnZSc6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgYWxlcnQuYXBwbHkod2luZG93LCBkYXRhKTtcbiAgICB9LFxuXG4gICAgJ2dldCBzcHJpdGUganNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuc3R5bGUuc3ByaXRlO1xuICAgICAgICBpZiAoc3ByaXRlLmxvYWRlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNwcml0ZTogc3ByaXRlLmRhdGEsIHJldGluYTogc3ByaXRlLnJldGluYSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwcml0ZS5vbignbG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0IGdseXBocyc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbHlwaFNvdXJjZS5nZXRSZWN0cyhwYXJhbXMuZm9udHN0YWNrLCBwYXJhbXMuY29kZXBvaW50cywgcGFyYW1zLmlkLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlcmluZ1xuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih1cGRhdGVTdHlsZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5zdHlsZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRoaXMuX3N0eWxlRGlydHkgfHwgdXBkYXRlU3R5bGU7XG4gICAgICAgIHRoaXMuX3RpbGVzRGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENhbGwgd2hlbiBhIChyZS0pcmVuZGVyIG9mIHRoZSBtYXAgaXMgcmVxdWlyZWQsIGUuZy4gd2hlbiB0aGUgdXNlciBwYW5uZWQgb3Igem9vbWVkLGYgb3IgbmV3IGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RpbGVzRGlydHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlc1tpZF0udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aWxlc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJHcm91cHModGhpcy5zdHlsZS5sYXllckdyb3Vwcyk7XG4gICAgICAgIHRoaXMuZmlyZSgncmVuZGVyJyk7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVJZCA9IG51bGw7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbkxvb3Auc3RvcHBlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZXBhaW50IHx8ICF0aGlzLmFuaW1hdGlvbkxvb3Auc3RvcHBlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yZW5kZXJHcm91cHM6IGZ1bmN0aW9uKGdyb3Vwcykge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIGdyb3VwLCBzb3VyY2U7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBncm91cHNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlc1tncm91cC5zb3VyY2VdO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyU3RlbmNpbCgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5yZW5kZXIoZ3JvdXApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmRyYXcodW5kZWZpbmVkLCB0aGlzLnN0eWxlLCBncm91cCwgeyBiYWNrZ3JvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZXJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZnJhbWVJZCkge1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVJZCA9IGJyb3dzZXIuZnJhbWUodGhpcy5yZW5kZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vblN0eWxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGUpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdHlsZS5yZWNhbGN1bGF0ZSh0aGlzLnRyYW5zZm9ybS56b29tKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUdseXBoczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5icm9hZGNhc3QoJ3NldCBnbHlwaHMnLCB0aGlzLnN0eWxlLnN0eWxlc2hlZXQuZ2x5cGhzKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUJ1Y2tldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUcmFuc2ZlciBhIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiB0aGUgc3R5bGUgdG8gdGhlIHdvcmtlcnMuIFRoZXkgb25seVxuICAgICAgICAvLyBuZWVkIHRoZSBidWNrZXQgaW5mb3JtYXRpb24gdG8ga25vdyB3aGF0IGZlYXR1cmVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgdGlsZS5cbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdCgnc2V0IGJ1Y2tldHMnLCB0aGlzLnN0eWxlLm9yZGVyZWRCdWNrZXRzKTtcblxuICAgICAgICAvLyBjbGVhcnMgYWxsIHRpbGVzIHRvIHJlY2FsY3VsYXRlIGdlb21ldHJpZXMgKGZvciBjaGFuZ2VzIHRvIGxpbmVjYXBzLCBsaW5lam9pbnMsIC4uLilcbiAgICAgICAgZm9yICh2YXIgcyBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tzXS5sb2FkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbn0pO1xuXG51dGlsLmV4dGVuZEFsbChNYXAucHJvdG90eXBlLCB7XG5cbiAgICAvLyBkZWJ1ZyBjb2RlXG4gICAgX2RlYnVnOiBmYWxzZSxcbiAgICBnZXQgZGVidWcoKSB7IHJldHVybiB0aGlzLl9kZWJ1ZzsgfSxcbiAgICBzZXQgZGVidWcodmFsdWUpIHsgdGhpcy5fZGVidWcgPSB2YWx1ZTsgdGhpcy5fcmVyZW5kZXIoKTsgfSxcblxuICAgIC8vIGNvbnRpbnVvdXMgcmVwYWludFxuICAgIF9yZXBhaW50OiBmYWxzZSxcbiAgICBnZXQgcmVwYWludCgpIHsgcmV0dXJuIHRoaXMuX3JlcGFpbnQ7IH0sXG4gICAgc2V0IHJlcGFpbnQodmFsdWUpIHsgdGhpcy5fcmVwYWludCA9IHZhbHVlOyB0aGlzLl9yZXJlbmRlcigpOyB9LFxuXG4gICAgLy8gcG9seWdvbiBhbnRpYWxpYXNpbmdcbiAgICBfYW50aWFsaWFzaW5nOiB0cnVlLFxuICAgIGdldCBhbnRpYWxpYXNpbmcoKSB7IHJldHVybiB0aGlzLl9hbnRpYWxpYXNpbmc7IH0sXG4gICAgc2V0IGFudGlhbGlhc2luZyh2YWx1ZSkgeyB0aGlzLl9hbnRpYWxpYXNpbmcgPSB2YWx1ZTsgdGhpcy5fcmVyZW5kZXIoKTsgfSxcblxuICAgIC8vIHNob3cgdmVydGljZXNcbiAgICBfdmVydGljZXM6IGZhbHNlLFxuICAgIGdldCB2ZXJ0aWNlcygpIHsgcmV0dXJuIHRoaXMuX3ZlcnRpY2VzOyB9LFxuICAgIHNldCB2ZXJ0aWNlcyh2YWx1ZSkgeyB0aGlzLl92ZXJ0aWNlcyA9IHZhbHVlOyB0aGlzLl9yZXJlbmRlcigpOyB9LFxuXG4gICAgLy8gc2hvdyB2ZXJ0aWNlc1xuICAgIF9sb2FkTmV3VGlsZXM6IHRydWUsXG4gICAgZ2V0IGxvYWROZXdUaWxlcygpIHsgcmV0dXJuIHRoaXMuX2xvYWROZXdUaWxlczsgfSxcbiAgICBzZXQgbG9hZE5ld1RpbGVzKHZhbHVlKSB7IHRoaXMuX2xvYWROZXdUaWxlcyA9IHZhbHVlOyB0aGlzLnVwZGF0ZSgpOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBBY3RvcjtcblxuZnVuY3Rpb24gQWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuY2FsbGJhY2tJRCA9IDA7XG4gICAgdGhpcy5yZWNlaXZlID0gdGhpcy5yZWNlaXZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMucmVjZWl2ZSwgZmFsc2UpO1xufVxuXG5BY3Rvci5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgY2FsbGJhY2s7XG5cbiAgICBpZiAoZGF0YS50eXBlID09ICc8cmVzcG9uc2U+Jykge1xuICAgICAgICBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2RhdGEuaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGNhbGxiYWNrKGRhdGEuZXJyb3IgfHwgbnVsbCwgZGF0YS5kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLmlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLnBhcmVudFtkYXRhLnR5cGVdKGRhdGEuZGF0YSwgZnVuY3Rpb24gcmVzcG9uc2UoZXJyLCBkYXRhLCBidWZmZXJzKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ3RyeWluZyB0byBjbG9uZScsIGRhdGEsIGJ1ZmZlcnMsIG1lc3NhZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgIG1lc3NhZ2UudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnPHJlc3BvbnNlPicsXG4gICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpZCksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciA/IFN0cmluZyhlcnIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9LCBidWZmZXJzKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbZGF0YS50eXBlXShkYXRhLmRhdGEpO1xuICAgIH1cbn07XG5cbkFjdG9yLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24odHlwZSwgZGF0YSwgY2FsbGJhY2ssIGJ1ZmZlcnMpIHtcbiAgICB2YXIgaWQgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5jYWxsYmFja3NbaWQgPSB0aGlzLmNhbGxiYWNrSUQrK10gPSBjYWxsYmFjaztcbiAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZSh7IHR5cGU6IHR5cGUsIGlkOiBTdHJpbmcoaWQpLCBkYXRhOiBkYXRhIH0sIGJ1ZmZlcnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5nZXRKU09OID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICB0cnkgeyBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpOyB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5leHBvcnRzLmdldEFycmF5QnVmZmVyID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5leHBvcnRzLmdldEltYWdlID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGltZyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gdXJsO1xuICAgIGltZy5nZXREYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiBnZXRJbWFnZURhdGEodGhpcyk7IH07XG4gICAgcmV0dXJuIGltZztcbn07XG5cbmZ1bmN0aW9uIGdldEltYWdlRGF0YShpbWcpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5kYXRhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnJhbWVOYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gJ3JlcXVlc3RBbmltYXRpb25GcmFtZSc7XG4gICAgaWYgKHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiAnbW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lJztcbiAgICBpZiAod2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmV0dXJuICd3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnO1xuICAgIGlmICh3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiAnbXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnO1xufSkoKTtcblxuZXhwb3J0cy5mcmFtZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHdpbmRvd1tmcmFtZU5hbWVdKGZuKTtcbn07XG5cbmV4cG9ydHMuY2FuY2VsRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICh3aW5kb3cuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICB3aW5kb3cubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGlkKTtcbn07XG5cbmV4cG9ydHMudGltZWQgPSBmdW5jdGlvbiAoZm4sIGR1ciwgY3R4KSB7XG4gICAgaWYgKCFkdXIpIHsgcmV0dXJuIGZuLmNhbGwoY3R4LCAxKTsgfVxuXG4gICAgdmFyIGFib3J0ID0gZmFsc2UsXG4gICAgICAgIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKTtcblxuICAgIGZ1bmN0aW9uIHRpY2sobm93KSB7XG4gICAgICAgIGlmIChhYm9ydCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSkgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAobm93ID4gc3RhcnQgKyBkdXIpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAobm93IC0gc3RhcnQpIC8gZHVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydCA9IHRydWU7IH07XG59O1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdXBwb3J0cyA9IFtcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnOyB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJzsgfSxcblxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoQXJyYXkucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUubWFwICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNvbWUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoRnVuY3Rpb24ucHJvdG90eXBlICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSxcbiAgICAgICAgICAgICAgICAhIShPYmplY3Qua2V5cyAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuaXNTZWFsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRnJvemVuICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnNlYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICdKU09OJyBpbiB3aW5kb3cgJiYgJ3BhcnNlJyBpbiBKU09OICYmICdzdHJpbmdpZnknIGluIEpTT047XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBpZiAoJ3N1cHBvcnRzQ29udGV4dCcgaW4gY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgKCEhY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgISFjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ1dvcmtlcicgaW4gd2luZG93OyB9XG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1tpXSgpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5oYXJkd2FyZUNvbmN1cnJlbmN5ID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgODtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZXZpY2VQaXhlbFJhdGlvJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuXG5mdW5jdGlvbiBDYW52YXMocGFyZW50LCBjb250YWluZXIpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1jYW52YXMnKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgcGFyZW50Ll9jb250ZXh0TG9zdC5iaW5kKHBhcmVudCksIGZhbHNlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHBhcmVudC5fY29udGV4dFJlc3RvcmVkLmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIC8vIFJlcXVlc3QgdGhlIHJlcXVpcmVkIGNhbnZhcyBzaXplIHRha2luZyB0aGUgcGl4ZWxyYXRpbyBpbnRvIGFjY291bnQuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxSYXRpbyAqIGhlaWdodDtcblxuICAgIC8vIE1haW50YWluIHRoZSBzYW1lIGNhbnZhcyBzaXplLCBwb3RlbnRpYWxseSBkb3duc2NhbGluZyBpdCBmb3IgSGlEUEkgZGlzcGxheXNcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCB7XG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICBkZXB0aDogZmFsc2VcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yLmpzJyk7XG5cbnZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG52YXIgd29ya2VyRmlsZSA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xudmFyIGFic29sdXRlID0gd29ya2VyRmlsZS5pbmRleE9mKCdodHRwJykgIT09IC0xO1xuXG5cbi8vIE1hbmFnZXMgdGhlIFdlYldvcmtlcnNcbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlcjtcbmZ1bmN0aW9uIERpc3BhdGNoZXIobGVuZ3RoLCBwYXJlbnQpIHtcbiAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjdG9yID0gMDtcblxuICAgIHZhciB1cmwsIGJsb2IsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzIGRvbWFpbiBpc3N1ZXMgd2UgY2FuJ3QgbG9hZCBpdCBkaXJlY3RseSB3aXRoIHRoZSB1cmwsXG4gICAgICAgIC8vIHNvIGNyZWF0ZSBhIGJsb2IgYW5kIG9iamVjdCB1cmwgYW5kIGxvYWQgdGhhdFxuICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbJ2ltcG9ydFNjcmlwdHMoXCInICsgd29ya2VyRmlsZSArICdcIik7J10sIHt0eXBlIDogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSk7XG4gICAgICAgICAgICB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IHdvcmtlckZpbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgICB2YXIgYWN0b3IgPSBuZXcgQWN0b3Iod29ya2VyLCBwYXJlbnQpO1xuICAgICAgICBhY3Rvci5uYW1lID0gXCJXb3JrZXIgXCIgKyBpO1xuICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcbiAgICB9XG59XG5cbkRpc3BhdGNoZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWN0b3JzW2ldLnNlbmQodHlwZSwgZGF0YSk7XG4gICAgfVxufTtcblxuRGlzcGF0Y2hlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCB0YXJnZXRJRCwgYnVmZmVycykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0SUQgIT09ICdudW1iZXInIHx8IGlzTmFOKHRhcmdldElEKSkge1xuICAgICAgICAvLyBVc2Ugcm91bmQgcm9iaW4gdG8gc2VuZCByZXF1ZXN0cyB0byB3ZWIgd29ya2Vycy5cbiAgICAgICAgdGFyZ2V0SUQgPSB0aGlzLmN1cnJlbnRBY3RvciA9ICh0aGlzLmN1cnJlbnRBY3RvciArIDEpICUgdGhpcy5hY3RvcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYWN0b3JzW3RhcmdldElEXS5zZW5kKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKTtcbiAgICByZXR1cm4gdGFyZ2V0SUQ7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEhUVFBfVVJMOiAnaHR0cDovL2EudGlsZXMubWFwYm94LmNvbS92NCcsXG4gICAgSFRUUFNfVVJMOiAnaHR0cHM6Ly9hLnRpbGVzLm1hcGJveC5jb20vdjQnLFxuICAgIEZPUkNFX0hUVFBTOiBmYWxzZSxcbiAgICBSRVFVSVJFX0FDQ0VTU19UT0tFTjogdHJ1ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmIChjbGFzc05hbWUpIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICBpZiAoY29udGFpbmVyKSBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHJldHVybiBlbDtcbn07XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbnZhciBkb2NFbCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiB7fSxcbiAgICBzZWxlY3RQcm9wID1cbiAgICAgICAgJ3VzZXJTZWxlY3QnIGluIGRvY0VsID8gJ3VzZXJTZWxlY3QnIDpcbiAgICAgICAgJ01velVzZXJTZWxlY3QnIGluIGRvY0VsID8gJ01velVzZXJTZWxlY3QnIDpcbiAgICAgICAgJ1dlYmtpdFVzZXJTZWxlY3QnIGluIGRvY0VsID8gJ1dlYmtpdFVzZXJTZWxlY3QnIDogbnVsbCxcbiAgICB1c2VyU2VsZWN0O1xuXG5leHBvcnRzLmRpc2FibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICBpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgZWxzZSBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICB1c2VyU2VsZWN0ID0gZG9jRWwuc3R5bGVbc2VsZWN0UHJvcF07XG4gICAgICAgIGRvY0VsLnN0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgIH1cbn07XG5leHBvcnRzLmVuYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcblxuICAgIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbiAgICBlbHNlIGlmIChzZWxlY3RQcm9wKSBkb2NFbC5zdHlsZVtzZWxlY3RQcm9wXSA9IHVzZXJTZWxlY3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbjogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGZuKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb2ZmOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpcmU6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAgIHV0aWwuZXh0ZW5kKGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgYWRkaW5nL3JlbW92aW5nIGxpc3RlbmVycyBpbnNpZGUgb3RoZXIgbGlzdGVuZXJzIHdvbid0IGNhdXNlIGluZmluaXRlIGxvb3BcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsaXN0ZW5zOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBocztcbmZ1bmN0aW9uIEdseXBocyhidWZmZXIsIGVuZCkge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblxuICAgIHZhciB2YWwsIHRhZztcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFsID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgdGFnID0gdmFsID4+IDM7XG4gICAgICAgIGlmICh0YWcgPT0gMSkge1xuICAgICAgICAgICAgdmFyIGZvbnRzdGFjayA9IHRoaXMucmVhZEZvbnRzdGFjaygpO1xuICAgICAgICAgICAgdGhpcy5zdGFja3NbZm9udHN0YWNrLm5hbWVdID0gZm9udHN0YWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCdza2lwcGluZyB0aWxlIHRhZyAnICsgdGFnKTtcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkdseXBocy5wcm90b3R5cGUucmVhZEZvbnRzdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgdmFyIGZvbnRzdGFjayA9IHsgZ2x5cGhzOiB7fSB9O1xuXG4gICAgdmFyIGJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICB2YXIgdmFsLCB0YWc7XG4gICAgdmFyIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcztcbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIGZvbnRzdGFjay5uYW1lID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgIGZvbnRzdGFjay5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSAzKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLnJlYWRHbHlwaCgpO1xuICAgICAgICAgICAgZm9udHN0YWNrLmdseXBoc1tnbHlwaC5pZF0gPSBnbHlwaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm9udHN0YWNrO1xufTtcblxuR2x5cGhzLnByb3RvdHlwZS5yZWFkR2x5cGggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuICAgIHZhciBnbHlwaCA9IHt9O1xuXG4gICAgdmFyIGJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICB2YXIgdmFsLCB0YWc7XG4gICAgdmFyIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcztcbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmlkID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMikge1xuICAgICAgICAgICAgZ2x5cGguYml0bWFwID0gYnVmZmVyLnJlYWRCdWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMykge1xuICAgICAgICAgICAgZ2x5cGgud2lkdGggPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA0KSB7XG4gICAgICAgICAgICBnbHlwaC5oZWlnaHQgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA1KSB7XG4gICAgICAgICAgICBnbHlwaC5sZWZ0ID0gYnVmZmVyLnJlYWRTVmFyaW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDYpIHtcbiAgICAgICAgICAgIGdseXBoLnRvcCA9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA3KSB7XG4gICAgICAgICAgICBnbHlwaC5hZHZhbmNlID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlci5za2lwKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICogQSBbbW9zdC1yZWNlbnRseS11c2VkIGNhY2hlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX2FsZ29yaXRobXMpXG4gKiB3aXRoIGhhc2ggbG9va3VwIG1hZGUgcG9zc2libGUgYnkga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyBpbiBwYXJhbGxlbCB0b1xuICogYW4gYXJyYXkgb2YgZGljdGlvbmFyeSBvZiB2YWx1ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBNUlVDYWNoZTtcbmZ1bmN0aW9uIE1SVUNhY2hlKGxlbmd0aCwgb25SZW1vdmUpIHtcbiAgICB0aGlzLm1heCA9IGxlbmd0aDtcbiAgICB0aGlzLm9uUmVtb3ZlID0gb25SZW1vdmU7XG4gICAgdGhpcy5yZXNldCgpO1xufVxuXG4vKlxuICogQ2xlYXJzIHRoZSBjYWNoZVxuICovXG5NUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxpc3QgPSB7fTtcbiAgICB0aGlzLm9yZGVyID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBBZGQgYSBrZXksIHZhbHVlIGNvbWJpbmF0aW9uIHRvIHRoZSBjYWNoZSwgdHJpbW1pbmcgaXRzIHNpemUgaWYgdGhpcyBwdXNoZXNcbiAqIGl0IG92ZXIgbWF4IGxlbmd0aC5cbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgZGF0YSkge1xuICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcbiAgICB0aGlzLm9yZGVyLnB1c2goa2V5KTtcblxuICAgIGlmICh0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHZhciByZW1vdmVkRGF0YSA9IHRoaXMuZ2V0KHRoaXMub3JkZXJbMF0pO1xuICAgICAgICBpZiAocmVtb3ZlZERhdGEpIHRoaXMub25SZW1vdmUocmVtb3ZlZERhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBga2V5YCBpcyBwcmVzZW50XG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMubGlzdDtcbn07XG5cbi8qXG4gKiBMaXN0IGFsbCBrZXlzIGluIHRoZSBjYWNoZVxuICovXG5NUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9yZGVyO1xufTtcblxuLypcbiAqIEdldCB0aGUgdmFsdWUgYXR0YWNoZWQgdG8gYSBzcGVjaWZpYyBrZXkuIElmIHRoZSBrZXkgaXMgbm90IGZvdW5kLFxuICogcmV0dXJucyBgbnVsbGBcbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICghdGhpcy5oYXMoa2V5KSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcbiAgICB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2Yoa2V5KSwgMSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVRva2VucztcblxudmFyIHRva2VuUGF0dGVybiA9IC97KFtcXHctXSspfS87XG5cbmZ1bmN0aW9uIHJlc29sdmVUb2tlbnMocHJvcGVydGllcywgZXhwcmVzc2lvbikge1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHRleHQgPSBleHByZXNzaW9uO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0ZXh0Lm1hdGNoKHRva2VuUGF0dGVybikpKSB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHByb3BlcnRpZXNbbWF0Y2hbMV1dID09PSAndW5kZWZpbmVkJyA/ICcnIDogcHJvcGVydGllc1ttYXRjaFsxXV07XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UobWF0Y2hbMF0sIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGgsIGFjY2Vzc1Rva2VuKSB7XG4gICAgYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBjb25maWcuQUNDRVNTX1RPS0VOO1xuXG4gICAgaWYgKCFhY2Nlc3NUb2tlbiAmJiBjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3ggR0wuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL2RldmVsb3BlcnMvYXBpLyNhY2Nlc3MtdG9rZW5zJyk7XG4gICAgfVxuXG4gICAgdmFyIHVybCA9ICgodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaHR0cHM6JyA9PT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wpIHx8XG4gICAgICAgIGNvbmZpZy5GT1JDRV9IVFRQUykgPyBjb25maWcuSFRUUFNfVVJMIDogY29uZmlnLkhUVFBfVVJMO1xuICAgIHVybCArPSBwYXRoO1xuICAgIHVybCArPSB1cmwuaW5kZXhPZignPycpICE9PSAtMSA/ICcmYWNjZXNzX3Rva2VuPScgOiAnP2FjY2Vzc190b2tlbj0nO1xuXG4gICAgaWYgKGNvbmZpZy5SRVFVSVJFX0FDQ0VTU19UT0tFTikge1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW5bMF0gPT09ICdzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBwdWJsaWMgYWNjZXNzIHRva2VuIChway4qKSB3aXRoIE1hcGJveCBHTCBKUywgbm90IGEgc2VjcmV0IGFjY2VzcyB0b2tlbiAoc2suKikuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9kZXZlbG9wZXJzL2FwaS8jYWNjZXNzLXRva2VucycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsICs9IGFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy50aWxlSlNPTiA9IGZ1bmN0aW9uKG1hcElELCBhY2Nlc3NUb2tlbikge1xuICAgIHZhciB1cmwgPSBtb2R1bGUuZXhwb3J0cygnLycgKyBtYXBJRCArICcuanNvbicsIGFjY2Vzc1Rva2VuKTtcblxuICAgIC8vIFRpbGVKU09OIHJlcXVlc3RzIG5lZWQgYSBzZWN1cmUgZmxhZyBhcHBlbmRlZCB0byB0aGVpciBVUkxzIHNvXG4gICAgLy8gdGhhdCB0aGUgc2VydmVyIGtub3dzIHRvIHNlbmQgU1NMLWlmaWVkIHJlc291cmNlIHJlZmVyZW5jZXMuXG4gICAgaWYgKHVybC5pbmRleE9mKCdodHRwcycpID09PSAwKVxuICAgICAgICB1cmwgKz0gJyZzZWN1cmUnO1xuXG4gICAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVbml0QmV6aWVyID0gcmVxdWlyZSgndW5pdGJlemllcicpO1xuXG5leHBvcnRzLmVhc2VDdWJpY0luT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCxcbiAgICAgICAgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcbn07XG5cbmV4cG9ydHMuYmV6aWVyID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGJlemllciA9IG5ldyBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIGJlemllci5zb2x2ZSh0KTtcbiAgICB9O1xufTtcblxuZXhwb3J0cy5lYXNlID0gZXhwb3J0cy5iZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKTtcblxuZXhwb3J0cy5pbnRlcnAgPSBmdW5jdGlvbiAoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn07XG5cbmV4cG9ydHMucHJlbXVsdGlwbHkgPSBmdW5jdGlvbiAoYykge1xuICAgIGNbMF0gKj0gY1szXTtcbiAgICBjWzFdICo9IGNbM107XG4gICAgY1syXSAqPSBjWzNdO1xuICAgIHJldHVybiBjO1xufTtcblxuZXhwb3J0cy5hc3luY0VhY2ggPSBmdW5jdGlvbiAoYXJyYXksIGZuLCBjYWxsYmFjaykge1xuICAgIHZhciByZW1haW5pbmcgPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgZnVuY3Rpb24gY2hlY2soKSB7IGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGZuKGFycmF5W2ldLCBjaGVjayk7XG59O1xuXG5leHBvcnRzLmtleXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKG9iaiwgb3RoZXIpIHtcbiAgICB2YXIgZGlmZmVyZW5jZSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghKGkgaW4gb3RoZXIpKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZlcmVuY2U7XG59O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgICBmb3IgKHZhciBpIGluIHNyYykge1xuICAgICAgICBkZXN0W2ldID0gc3JjW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuZXh0ZW5kQWxsID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHByb3BzKSB7XG4gICAgdmFyIHBhcmVudFByb3RvID0gdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudC5wcm90b3R5cGUgOiBwYXJlbnQsXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm90byk7XG4gICAgZXhwb3J0cy5leHRlbmRBbGwocHJvdG8sIHByb3BzKTtcbiAgICByZXR1cm4gcHJvdG87XG59O1xuXG52YXIgaWQgPSAxO1xuXG5leHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZCsrO1xufTtcblxuZXhwb3J0cy50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgdGltZSwgY29udGV4dCkge1xuICAgIHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xuXG4gICAgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXG4gICAgICAgIGxvY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGFyZ3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgICAvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcbiAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcbiAgICAgICAgICAgIGxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB3cmFwcGVyRm47XG59O1xuXG5leHBvcnRzLmRlYm91bmNlID0gZnVuY3Rpb24oZm4sIHRpbWUpIHtcbiAgICB2YXIgdGltZXIsIGFyZ3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0sIHRpbWUpO1xuICAgIH07XG59O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBUWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYFRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG52YXIgVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBzdWJqZWN0ID4gMCA/IHN1YmplY3QgPj4+IDAgOiAwXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgIHN1YmplY3QgPSBiYXNlNjRjbGVhbihzdWJqZWN0KVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHN1YmplY3QgIT09IG51bGwpIHsgLy8gYXNzdW1lIG9iamVjdCBpcyBhcnJheS1saWtlXG4gICAgaWYgKHN1YmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShzdWJqZWN0LmRhdGEpKVxuICAgICAgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aCA+IDAgPyBNYXRoLmZsb29yKCtzdWJqZWN0Lmxlbmd0aCkgOiAwXG4gIH0gZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFUWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0WywgbGVuZ3RoXSknKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYSkgJiYgQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkKSA/IHNlbGYubGVuZ3RoIDogTnVtYmVyKGVuZClcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IHJlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IHJlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSBoICs9IDE7XG4gIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgMV07XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yIH0gY2F0Y2goZSkgeyB9XG4iLCJ2YXIgZ2VvanNvbkFyZWEgPSByZXF1aXJlKCdnZW9qc29uLWFyZWEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXdpbmQ7XG5cbmZ1bmN0aW9uIHJld2luZChnaiwgb3V0ZXIpIHtcbiAgICBzd2l0Y2ggKChnaiAmJiBnai50eXBlKSB8fCBudWxsKSB7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGdqLmZlYXR1cmVzID0gZ2ouZmVhdHVyZXMubWFwKGN1cnJ5T3V0ZXIocmV3aW5kLCBvdXRlcikpO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgICAgIGdqLmdlb21ldHJ5ID0gcmV3aW5kKGdqLmdlb21ldHJ5LCBvdXRlcik7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3QoZ2osIG91dGVyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGN1cnJ5T3V0ZXIoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7IHJldHVybiBhKF8sIGIpOyB9O1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0KF8sIG91dGVyKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBjb3JyZWN0UmluZ3MoXy5jb29yZGluYXRlcywgb3V0ZXIpO1xuICAgIH0gZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBfLmNvb3JkaW5hdGVzID0gXy5jb29yZGluYXRlcy5tYXAoY3VycnlPdXRlcihjb3JyZWN0UmluZ3MsIG91dGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0UmluZ3MoXywgb3V0ZXIpIHtcbiAgICBvdXRlciA9ICEhb3V0ZXI7XG4gICAgX1swXSA9IHdpbmQoX1swXSwgIW91dGVyKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX1tpXSA9IHdpbmQoX1tpXSwgb3V0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbn1cblxuZnVuY3Rpb24gd2luZChfLCBkaXIpIHtcbiAgICByZXR1cm4gY3coXykgPT09IGRpciA/IF8gOiBfLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gY3coXykge1xuICAgIHJldHVybiBnZW9qc29uQXJlYS5yaW5nKF8pID49IDA7XG59XG4iLCJ2YXIgd2dzODQgPSByZXF1aXJlKCd3Z3M4NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xubW9kdWxlLmV4cG9ydHMucmluZyA9IHJpbmdBcmVhO1xuXG5mdW5jdGlvbiBnZW9tZXRyeShfKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSByZXR1cm4gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlcyk7XG4gICAgZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgYXJlYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgXy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSArPSBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcbiAgICBpZiAoY29vcmRzICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzWzBdKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcG9seWdvbiB3ZXJlIGl0IHByb2plY3RlZCBvbnRvXG4gKiAgICAgdGhlIGVhcnRoLiAgTm90ZSB0aGF0IHRoaXMgYXJlYSB3aWxsIGJlIHBvc2l0aXZlIGlmIHJpbmcgaXMgb3JpZW50ZWRcbiAqICAgICBjbG9ja3dpc2UsIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICpcbiAqIFJlZmVyZW5jZTpcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogICAgIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqICAgICBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwNyBodHRwOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvZHNwYWNlL2hhbmRsZS8yMDE0LzQwNDA5XG4gKlxuICogUmV0dXJuczpcbiAqIHtmbG9hdH0gVGhlIGFwcHJveGltYXRlIHNpZ25lZCBnZW9kZXNpYyBhcmVhIG9mIHRoZSBwb2x5Z29uIGluIHNxdWFyZVxuICogICAgIG1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiByaW5nQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG5cbiAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIHAxLCBwMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBwMSA9IGNvb3Jkc1tpXTtcbiAgICAgICAgICAgIHAyID0gY29vcmRzW2kgKyAxXTtcbiAgICAgICAgICAgIGFyZWEgKz0gcmFkKHAyWzBdIC0gcDFbMF0pICogKDIgKyBNYXRoLnNpbihyYWQocDFbMV0pKSArIE1hdGguc2luKHJhZChwMlsxXSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWEgPSBhcmVhICogd2dzODQuUkFESVVTICogd2dzODQuUkFESVVTIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gcmFkKF8pIHtcbiAgICByZXR1cm4gXyAqIE1hdGguUEkgLyAxODA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cy5SQURJVVMgPSA2Mzc4MTM3O1xubW9kdWxlLmV4cG9ydHMuRkxBVFRFTklORyA9IDEvMjk4LjI1NzIyMzU2Mztcbm1vZHVsZS5leHBvcnRzLlBPTEFSX1JBRElVUyA9IDYzNTY3NTIuMzE0MjtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkdmVyc2lvblwiOiA0LFxuICBcIiRyb290XCI6IHtcbiAgICBcInZlcnNpb25cIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICA0XG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJTdHlsZXNoZWV0IHZlcnNpb24gbnVtYmVyLiBNdXN0IGJlIDQuXCJcbiAgICB9LFxuICAgIFwiY29uc3RhbnRzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbnN0YW50c1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBvYmplY3Qgb2YgY29uc3RhbnRzIHRvIGJlIHJlZmVyZW5jZWQgaW4gbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic291cmNlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucyBmb3IgbGF5ZXJzIHRvIHB1bGwgZnJvbS5cIlxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJBbiBhcnJheSBvZiBsYXllcnMuIFRoZSBvcmRlciBvZiBsYXllcnMgY29pbmNpZGVzIHdpdGggdGhlIG9yZGVyIHRoZXkgd2lsbCBiZSBkcmF3bi5cIlxuICAgIH0sXG4gICAgXCJzcHJpdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3ByaXRlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwcml0ZSBkZWZpbml0aW9uLlwiXG4gICAgfSxcbiAgICBcImdseXBoc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVmFsaWQgdG9rZW5zIGFyZSB7Zm9udHN0YWNrfSBhbmQge3JhbmdlfS5cIlxuICAgIH0sXG4gICAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInRyYW5zaXRpb25cIixcbiAgICAgIFwiZG9jXCI6IFwiQSBnbG9iYWwgdHJhbnNpdGlvbiBkZWZpbml0aW9uIHRvIHVzZSBhcyBhIGRlZmF1bHQgYWNyb3NzIHByb3BlcnRpZXMuXCJcbiAgICB9XG4gIH0sXG4gIFwic3ByaXRlXCI6IFt7XG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkb2NcIjogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLlwiXG4gIH1dLFxuICBcImNvbnN0YW50c1wiOiB7XG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBjb25zdGFudCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgdmVyYmF0aW0gaW4gdGhlIHJlZmVyZW5jaW5nIHBsYWNlLiBUaGlzIGNhbiBiZSBhbnl0aGluZywgaW5jbHVkaW5nIG9iamVjdHMgYW5kIGFycmF5cy4gQWxsIHZhcmlhYmxlIG5hbWVzIG11c3QgYmUgcHJlZml4ZWQgd2l0aCBhbiBgQGAgc3ltYm9sLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZXNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzb3VyY2VcIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmVjdG9yXCIsXG4gICAgICAgIFwicmFzdGVyXCIsXG4gICAgICAgIFwiZ2VvanNvblwiLFxuICAgICAgICBcInZpZGVvXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMLCBvciBVUkwgdGVtcGxhdGUgdG8gcmV0cml2ZSB0aGUgc291cmNlIGRhdGEuXCJcbiAgICB9LFxuICAgIFwidGlsZVNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSAoaW4gcHgpIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIm1pblpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLlwiXG4gICAgfSxcbiAgICBcIm1heFpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZS4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXhab29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIlxuICAgIH0sXG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG4gICAgfVxuICB9LFxuICBcImxheWVyXCI6IHtcbiAgICBcImlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIlxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICBcInN5bWJvbFwiLFxuICAgICAgICBcInJhc3RlclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlJlZmVyZW5jZXMgYW5vdGhlciBsYXllciB0byBjb3B5IGBzb3VyY2VgLCBgc291cmNlX2xheWVyYCwgYGZpbHRlcmAsIGFuZCBgcmVuZGVyYCBwcm9wZXJ0aWVzIGZyb20uIFRoaXMgYWxsb3dzIHRoZSBsYXllcnMgdG8gc2hhcmUgcHJvY2Vzc2luZyBhbmQgYmUgbW9yZSBlZmZpY2llbnQuXCJcbiAgICB9LFxuICAgIFwic291cmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwic291cmNlLWxheWVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgaWYgdGhlIHNvdXJjZSBzdXBwb3J0cyBtdWx0aXBsZSBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwibWluLXpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcIm1heC16b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJpbnRlcmFjdGl2ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRvY1wiOiBcIkVuYWJsZSBxdWVyeWluZyBvZiBmZWF0dXJlIGRhdGEgZnJvbSB0aGlzIGxheWVyIGZvciBpbnRlcmFjdGl2aXR5LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcInJlbmRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJyZW5kZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiU3ltYm9saXplciB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gdmlzdWFsaXplIHRoaXMgbGF5ZXIuIElmIHVuc3BlY2lmaWVkIG9yIG51bGwsIHRoaXMgbGF5ZXIgaXMgbm90IHRyZWF0ZWQgYXMgYSBzeW1ib2xpemVyIGFuZCBvbmx5IGV4aXN0cyB0byBoYXZlIHByb3BlcnRpZXMgaW5oZXJpdGVkIHRvIG90aGVyIGxheWVycyB1c2luZyByZWYuXCJcbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBcnJheSBvciBvYmplY3Qgb2YgZmlsdGVycyBvciBleHByZXNzaW9ucy5cIlxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJJZiBgdHlwZWAgaXMgYHJhc3RlcmAsIHRoZSBjaGlsZCBsYXllcnMgYXJlIGNvbXBvc2l0ZWQgdG9nZXRoZXIgb250byB0aGUgcHJldmlvdXMgbGV2ZWwgbGF5ZXIgbGV2ZWwuXCJcbiAgICB9LFxuICAgIFwic3R5bGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY2xhc3NcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInN0eWxlLipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY2xhc3NcIixcbiAgICAgIFwiZG9jXCI6IFwiT3ZlcnJpZGUgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci4gVGhlIGNsYXNzIG5hbWUgaXMgdGhlIHBhcnQgYWZ0ZXIgdGhlIGZpcnN0IGRvdC5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZW5kZXJcIjogW1xuICAgIFwicmVuZGVyX2ZpbGxcIixcbiAgICBcInJlbmRlcl9saW5lXCIsXG4gICAgXCJyZW5kZXJfc3ltYm9sXCIsXG4gICAgXCJyZW5kZXJfcmFzdGVyXCIsXG4gICAgXCJyZW5kZXJfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwicmVuZGVyX2JhY2tncm91bmRcIjoge1xuICB9LFxuICBcInJlbmRlcl9maWxsXCI6IHtcbiAgfSxcbiAgXCJyZW5kZXJfbGluZVwiOiB7XG4gICAgXCJsaW5lLWNhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYnV0dFwiLFxuICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgIFwic3F1YXJlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJidXR0XCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5ncy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWpvaW5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImJldmVsXCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJtaXRlclwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiXG4gICAgfSxcbiAgICBcImxpbmUtbWl0ZXItbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLXJvdW5kLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZW5kZXJfc3ltYm9sXCI6IHtcbiAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICAgIFwibGluZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcInBvaW50XCIsXG4gICAgICAgIFwiZG9jXCI6IFwiUGxhY2VtZW50IG9mIGEgbGFiZWwgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LiBgTGluZWAgY2FuIG9ubHkgYmUgdXNlZCBvbiBMaW5lU3RyaW5ncyBhbmQgUG9seWdvbnMuXCJcbiAgICB9LFxuICAgIFwic3ltYm9sLW1pbi1kaXN0YW5jZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyNTAsXG4gICAgICBcImRvY1wiOiBcIk1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0d28gc3ltYm9sIGFuY2hvcnMgKHB4KVwiXG4gICAgfSxcbiAgICBcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBzeW1ib2xzIHdpbGwgbm90IGNyb3NzIHRpbGUgZWRnZXMuIFN5bWJvbHMgdGhhdCBjcm9zcyB0aWxlIGVkZ2VzIG1heSBjYXVzZSBjb2xsaXNpb25zIGluIHNvbWUgY2FzZXMuIFRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIHNldCB0byB0cnVlIGlmIHRoZSBsYXllciBkb2VzIG5vdCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLlwiXG4gICAgfSxcbiAgICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgaWNvbnMgYW5kIHRleHQuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd29uJ3QgYWZmZWN0IHBsYWNlbWVudCBvZiBvdGhlciBpY29ucyBhbmQgdGV4dC5cIlxuICAgIH0sXG4gICAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGV4dCBjYW4gYmUgc2hvd24gd2l0aG91dCBpdHMgY29ycmVzcG9uZGluZyBpY29uLlwiXG4gICAgfSxcbiAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICAgIFwiZG9jXCI6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyByb3RhdGVkXCJcbiAgICB9LFxuICAgIFwiaWNvbi1tYXgtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBhbW91bnQgdG8gc2NhbGUgdGhlIGljb24gYnkuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBzdHJpbmcgd2l0aCB7dG9rZW5zfSByZXBsYWNlZCwgcmVmZXJlbmNpbmcgdGhlIGRhdGEgcHJvcGVydHkgdG8gcHVsbCBmcm9tLlwiXG4gICAgfSxcbiAgICBcImljb24tcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlZ3JlZXMuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1wYWRkaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIGljb24gYm91bmRpbmcgYm94IHRvIGF2b2lkIGljb24gY29sbGlzaW9ucyAocHgpLlwiXG4gICAgfSxcbiAgICBcImljb24ta2VlcC11cHJpZ2h0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gbWF5IGJlIGZsaXBwZWQgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duXCJcbiAgICB9LFxuICAgIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJJY29uJ3Mgb2Zmc2V0LCBpbiBwaXhlbHMuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICAgIFwiZG9jXCI6IFwiT3JpZW50YXRpb24gb2YgaWNvbiBvciB0ZXh0IHdoZW4gbWFwIGlzIHJvdGF0ZWRcIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWZpZWxkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiXCIsXG4gICAgICBcImRvY1wiOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBGZWF0dXJlIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCB1c2luZyB0b2tlbnMgbGlrZSB7ZmllbGRfbmFtZX0uXCJcbiAgICB9LFxuICAgIFwidGV4dC1mb250XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJGb250IHN0YWNrIHRvIHVzZSBmb3IgZGlzcGxheWluZyB0ZXh0LlwiXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHNpemUgdGV4dCB3aWxsIGJlIGRpc3BsYXllZC5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZyAoZW0pLlwiXG4gICAgfSxcbiAgICBcInRleHQtbGluZS1oZWlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMS4yLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIlRleHQga2VybmluZyB2YWx1ZSAoZW0pLlwiXG4gICAgfSxcbiAgICBcInRleHQtanVzdGlmeVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInJpZ2h0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCJcbiAgICB9LFxuICAgIFwidGV4dC1ob3Jpem9udGFsLWFsaWduXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwicmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJIb3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgdGV4dCByZWxhdGl2ZSB0byB0aGUgYW5jaG9yLlwiXG4gICAgfSxcbiAgICBcInRleHQtdmVydGljYWwtYWxpZ25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInRvcFwiLFxuICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICBcImJvdHRvbVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgdGV4dCByZWxhdGl2ZSB0byB0aGUgYW5jaG9yLlwiXG4gICAgfSxcbiAgICBcInRleHQtbWF4LWFuZ2xlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDQ1LFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBhbmdsZSBjaGFuZ2UsIGluIGRlZ3JlZXMsIGFsbG93ZWQgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiXG4gICAgfSxcbiAgICBcInRleHQtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlZ3JlZXMuXCJcbiAgICB9LFxuICAgIFwidGV4dC1wYWRkaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIHRleHQgYm91bmRpbmcgYm94IHRvIGF2b2lkIGxhYmVsIGNvbGxpc2lvbnMgKHB4KS5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWtlZXAtdXByaWdodFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdGV4dCBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd25cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibm9uZVwiLFxuICAgICAgICBcInVwcGVyY2FzZVwiLFxuICAgICAgICBcImxvd2VyY2FzZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgaG93IHRvIGNhcGl0YWxpemUgdGV4dCwgc2ltaWxhciB0byB0aGUgQ1NTIGB0ZXh0LXRyYW5zZm9ybWAgcHJvcGVydHkuXCJcbiAgICB9LFxuICAgIFwidGV4dC1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgaWNvbnMgYW5kIGxhYmVscy5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCB3b24ndCBhZmZlY3QgcGxhY2VtZW50IG9mIG90aGVyIGljb25zIGFuZCBsYWJlbHMuXCJcbiAgICB9LFxuICAgIFwidGV4dC1vcHRpb25hbFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgICBcImRvY1wiOiBcIklmIHRydWUsIGljb25zIGNhbiBiZSBzaG93biB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgdGV4dC5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZW5kZXJfcmFzdGVyXCI6IHtcbiAgICBcInJhc3Rlci1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDI1NixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIHRleHR1cmUgaW1hZ2Ugc2l6ZSAoaW4gcGl4ZWxzKSB2ZWN0b3IgbGF5ZXJzIHdpbGwgYmUgcmFzdGVyaXplZCBhdC4gV2lsbCBhdXRvbWF0aWNhbGx5IGJ5IHNjYWxlZCB0byBtYXRjaCB0aGUgdmlzdWFsIHRpbGUgc2l6ZS5cIlxuICAgIH0sXG4gICAgXCJyYXN0ZXItYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJCbHVyIHJhZGl1cyB0byBhcHBseSB0byB0aGUgcmFzdGVyIHRleHR1cmUgYmVmb3JlIGRpc3BsYXkuXCJcbiAgICB9XG4gIH0sXG4gIFwiZmlsdGVyXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfZXhwcmVzc2lvblwiLFxuICAgICAgXCJkb2NcIjogXCJWYXJpb3VzIGZpbHRlciBleHByZXNzaW9ucy4gVW5sZXNzIG92ZXJyaWRkZW4gYnkgcGFyZW50LCB0aGVzZSBhcmUgaW50ZXJwcmV0ZWQgYXMgYEFORGAuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwiZmlsdGVyX2V4cHJlc3Npb25cIixcbiAgICAgIFwiZG9jXCI6IFwiVmFyaW91cyBmaWx0ZXIgZXhwcmVzc2lvbnMuIFVubGVzcyBvdmVycmlkZGVuIGJ5IHBhcmVudCwgdGhlc2UgYXJlIGludGVycHJldGVkIGFzIGBPUmAuXCJcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyX2V4cHJlc3Npb25cIjoge1xuICAgIFwiJlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiQU5EIG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcInxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIk9SIG9wZXJhdG9yLlwiXG4gICAgfSxcbiAgICBcIl5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlhPUiBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCIhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJOT1Igb3BlcmF0b3IuXCJcbiAgICB9LFxuICAgIFwiJHR5cGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIlBvaW50XCIsXG4gICAgICAgIFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBcIlBvbHlnb25cIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiR2VvbWV0cnkgdHlwZSB0aGF0IGZlYXR1cmVzIG11c3QgbWF0Y2guXCJcbiAgICB9LFxuICAgIFwiKlwiOiBbXG4gICAgICB7XG4gICAgICAgIFwidHlwZVwiOiBcImZpbHRlcl9jb21wYXJpc29uXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQXJiaXRhcmlseSBuYW1lZCBmZWF0dXJlIG1lbWJlci4gQSBjb21wYXJpc29uIG9iamVjdCBkZWZpbmluZyBhIGZpbHRlciBleHByZXNzaW9uLlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInR5cGVcIjogXCJmaWx0ZXJfdmFsdWVcIixcbiAgICAgICAgXCJkb2NcIjogXCJBcmJpdGFyaWx5IG5hbWVkIGZlYXR1cmUgbWVtYmVyLiBBIGZpbHRlcl92YWx1ZSBpbXBsaWVzIHRoZSBlcXVhbGl0eSAoc3RyaW5nL251bWJlci9ib29sZWFuKSBvciBzZXQgbWVtYmVyc2hpcCBvcGVyYXRvciAoYXJyYXkpLlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBcImZpbHRlcl9jb21wYXJpc29uXCI6IHtcbiAgICBcIj09XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxuICAgICAgXCJkb2NcIjogXCJFcXVhbGl0eSBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCIhPVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfdmFsdWVcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5lcXVhbGl0eSBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCI+XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxuICAgICAgXCJkb2NcIjogXCJHcmVhdGVyIHRoYW4gb3BlcmF0b3IuXCJcbiAgICB9LFxuICAgIFwiPj1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXG4gICAgICBcImRvY1wiOiBcIkdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCI8XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlcl92YWx1ZVwiLFxuICAgICAgXCJkb2NcIjogXCJMZXNzIHRoYW4gb3BlcmF0b3IuXCJcbiAgICB9LFxuICAgIFwiPD1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyX3ZhbHVlXCIsXG4gICAgICBcImRvY1wiOiBcIkxlc3MgdGhhbiBvciBlcXVhbCBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCJpblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImZpbHRlcl9wcmltaXRpdmVcIixcbiAgICAgIFwiZG9jXCI6IFwiU2V0IG1lbWJlciBvcGVyYXRvci5cIlxuICAgIH0sXG4gICAgXCIhaW5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJmaWx0ZXJfcHJpbWl0aXZlXCIsXG4gICAgICBcImRvY1wiOiBcIk5vdCBpbiBzZXQgb3BlcmF0b3IuXCJcbiAgICB9XG4gIH0sXG4gIFwiZmlsdGVyX3ZhbHVlXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJfcHJpbWl0aXZlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwiZmlsdGVyX3ByaW1pdGl2ZVwiXG4gICAgfVxuICBdLFxuICBcImZpbHRlcl9wcmltaXRpdmVcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgfVxuICBdLFxuICBcImZ1bmN0aW9uXCI6IHtcbiAgICBcInN0b3BzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIHN0b3BzLlwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImZ1bmN0aW9uX3N0b3BcIlxuICAgIH0sXG4gICAgXCJiYXNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBleHBvbmVudGlhbCBiYXNlIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGN1cnZlLiBJdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgcmVzdWx0IGluY3JlYXNlcy4gSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSByZXN1bHQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggYDFgIHRoZSBzdG9wcyBhcmUgaW50ZXJwb2xhdGVkIGxpbmVhcmx5LlwiXG4gICAgfVxuICB9LFxuICBcImZ1bmN0aW9uX3N0b3BcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJ2YWx1ZVwiOiBbXCJudW1iZXJcIiwgXCJjb2xvclwiXSxcbiAgICBcImxlbmd0aFwiOiAyLFxuICAgIFwiZG9jXCI6IFwiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci5cIlxuICB9LFxuICBcImNsYXNzXCI6IFtcbiAgICBcImNsYXNzX2ZpbGxcIixcbiAgICBcImNsYXNzX2xpbmVcIixcbiAgICBcImNsYXNzX3N5bWJvbFwiLFxuICAgIFwiY2xhc3NfcmFzdGVyXCIsXG4gICAgXCJjbGFzc19iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJjbGFzc19maWxsXCI6IHtcbiAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJmaWxsLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBmaWxsLiBNYXRjaGVzIHRoZSB2YWx1ZSBvZiBgZmlsbC1jb2xvcmAgaWYgdW5zcGVjaWZpZWQuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJmaWxsLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LCBpbiBwaXhlbHMuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiXG4gICAgfSxcbiAgICBcImZpbGwtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBmaWxscy5cIlxuICAgIH1cbiAgfSxcbiAgXCJjbGFzc19saW5lXCI6IHtcbiAgICBcImxpbmUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwibGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQsIGluIHBpeGVscy4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCJcbiAgICB9LFxuICAgIFwibGluZS13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkxpbmUgd2lkdGggKGluIHB4KVwiXG4gICAgfSxcbiAgICBcImxpbmUtb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIkxpbmUgY2FzaW5nIHdoZXJlIGBsaW5lLW9mZnNldGAgaW5kaWNhdGVzIHRvdGFsIHdpZHRoLiBAVE9ETyByZW5hbWU/XCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJsaW5lLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJMaW5lIGJsdXIsIGluIHBpeGVscy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWRhc2hhcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDEsXG4gICAgICAgIC0xXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwibGluZS1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGxpbmVzLlwiXG4gICAgfVxuICB9LFxuICBcImNsYXNzX3N5bWJvbFwiOiB7XG4gICAgXCJpY29uLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImljb24tc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGljb24gYnkuIDEgaXMgb3JpZ2luYWwgc2l6ZSwgMyB0cmlwbGVzIHRoZSBzaXplLlwiXG4gICAgfSxcbiAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbidzIGhhbG8uIEljb24gaGFsb3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIlxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8td2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJIb3cgZmFyIGF3YXkgdGhlIGhhbG8gaXMgZnJvbSB0aGUgaWNvbiBvdXRsaW5lLCBpbiBwaXhlbHMuXCJcbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLCBpbiBwaXhlbHMuXCJcbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkFuIGljb24ncyBvZmZzZXQsIGluIHBpeGVscy4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCJcbiAgICB9LFxuICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0ZXh0LXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzaXplIGluIHBpeGVscy4gSWYgdW5zcGVjaWZpZWQsIHRoZSB0ZXh0IHdpbGwgYmUgYXMgYmlnIGFzIGFsbG93ZWQgYnkgdGhlIGxheWVyIGRlZmluaXRpb24uXCJcbiAgICB9LFxuICAgIFwidGV4dC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInRleHQtaGFsby1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInRleHQtaGFsby13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkhvdyBmYXIgYXdheSB0aGUgaGFsbyBpcyBmcm9tIHRoZSBmb250IG91dGxpbmUsIGluIHBpeGVscy4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZSAocHgpLlwiXG4gICAgfSxcbiAgICBcInRleHQtaGFsby1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiRmFkZSBvdXQgdGhlIGhhbG8gdG93YXJkcyB0aGUgb3V0c2lkZSwgaW4gcGl4ZWxzLlwiXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJBIGxhYmVsJ3Mgb2Zmc2V0LCBpbiBwaXhlbHMuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiXG4gICAgfVxuICB9LFxuICBcImNsYXNzX3Jhc3RlclwiOiB7XG4gICAgXCJyYXN0ZXItb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIGh1ZXMgYXJvdW5kIHRoZSBjb2xvciB3aGVlbCBieSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkZWdyZWVzLlwiXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1zYXR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1mYWRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiRHVyYXRpb24gb2YgdGhlIGZhZGUgd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLiBAVE9ETyByZW5hbWU/XCJcbiAgICB9XG4gIH0sXG4gIFwiY2xhc3NfYmFja2dyb3VuZFwiOiB7XG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiYmFja2dyb3VuZC1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH1cbiAgfSxcbiAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICBcImR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwiZG9jXCI6IFwiVGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBpdCB0YWtlcyBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJcbiAgICB9LFxuICAgIFwiZGVsYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGEgdHJhbnNpdGlvbiBiZWdpbnMuXCJcbiAgICB9XG4gIH1cbn1cbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG9idWY7XG5mdW5jdGlvbiBQcm90b2J1ZihidWYpIHtcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG59XG5cblByb3RvYnVmLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5idWYubGVuZ3RoOyB9XG59O1xuXG5Qcm90b2J1Zi5WYXJpbnQgPSAwO1xuUHJvdG9idWYuSW50NjQgPSAxO1xuUHJvdG9idWYuTWVzc2FnZSA9IDI7XG5Qcm90b2J1Zi5TdHJpbmcgPSAyO1xuUHJvdG9idWYuUGFja2VkID0gMjtcblByb3RvYnVmLkludDMyID0gNTtcblxuUHJvdG9idWYucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJ1ZiA9IG51bGw7XG59O1xuXG4vLyA9PT0gUkVBRElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5Qcm90b2J1Zi5wcm90b3R5cGUucmVhZFVJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkVUludDY0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50NjRMRSh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWREb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsID0gaWVlZTc1NC5yZWFkKHRoaXMuYnVmLCB0aGlzLnBvcywgdHJ1ZSwgNTIsIDgpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkVmFyaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLmJ1Zltwb3NdIDw9IDB4N2YpIHtcbiAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmW3Bvc107XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1Zltwb3MgKyAxXSA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgIHJldHVybiAodGhpcy5idWZbcG9zXSAmIDB4N2YpIHwgKHRoaXMuYnVmW3BvcyArIDFdIDw8IDcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5idWZbcG9zICsgMl0gPD0gMHg3Zikge1xuICAgICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgICByZXR1cm4gKHRoaXMuYnVmW3Bvc10gJiAweDdmKSB8ICh0aGlzLmJ1Zltwb3MgKyAxXSAmIDB4N2YpIDw8IDcgfCAodGhpcy5idWZbcG9zICsgMl0pIDw8IDE0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5idWZbcG9zICsgM10gPD0gMHg3Zikge1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gKHRoaXMuYnVmW3Bvc10gJiAweDdmKSB8ICh0aGlzLmJ1Zltwb3MgKyAxXSAmIDB4N2YpIDw8IDcgfCAodGhpcy5idWZbcG9zICsgMl0gJiAweDdmKSA8PCAxNCB8ICh0aGlzLmJ1Zltwb3MgKyAzXSkgPDwgMjE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1Zltwb3MgKyA0XSA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDU7XG4gICAgICAgIHJldHVybiAoKHRoaXMuYnVmW3Bvc10gJiAweDdmKSB8ICh0aGlzLmJ1Zltwb3MgKyAxXSAmIDB4N2YpIDw8IDcgfCAodGhpcy5idWZbcG9zICsgMl0gJiAweDdmKSA8PCAxNCB8ICh0aGlzLmJ1Zltwb3MgKyAzXSkgPDwgMjEpICsgKHRoaXMuYnVmW3BvcyArIDRdICogMjY4NDM1NDU2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNraXAoUHJvdG9idWYuVmFyaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihcIlRPRE86IEhhbmRsZSA2KyBieXRlIHZhcmludHNcIik7XG4gICAgfVxufTtcblxuUHJvdG9idWYucHJvdG90eXBlLnJlYWRTVmFyaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgIGlmIChudW0gPiAyMTQ3NDgzNjQ3KSB0aHJvdyBuZXcgRXJyb3IoJ1RPRE86IEhhbmRsZSBudW1iZXJzID49IDJeMzAnKTtcbiAgICAvLyB6aWd6YWcgZW5jb2RpbmdcbiAgICByZXR1cm4gKChudW0gPj4gMSkgXiAtKG51bSAmIDEpKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICB2YXIgcCA9IHRoaXMucG9zO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcyArIGJ5dGVzO1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB3aGlsZSAocCA8IGVuZCkge1xuICAgICAgICBpZiAoYltwXSA8PSAweDdGKSBzdHIgKz0gY2hyKGJbcCsrXSk7XG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhCRikgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IGNvZGVwb2ludDogJyArIGJbcF0pO1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4REYpIHN0ciArPSBjaHIoKGJbcCsrXSAmIDB4MUYpIDw8IDYgfCAoYltwKytdICYgMHgzRikpO1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4RUYpIHN0ciArPSBjaHIoKGJbcCsrXSAmIDB4MUYpIDw8IDEyIHwgKGJbcCsrXSAmIDB4M0YpIDw8IDYgfCAoYltwKytdICYgMHgzRikpO1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4RjcpIHAgKz0gNDsgLy8gV2UgY2FuJ3QgaGFuZGxlIHRoZXNlIGNvZGVwb2ludHMgaW4gSlMsIHNvIHNraXAuXG4gICAgICAgIGVsc2UgaWYgKGJbcF0gPD0gMHhGQikgcCArPSA1O1xuICAgICAgICBlbHNlIGlmIChiW3BdIDw9IDB4RkQpIHAgKz0gNjtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggY29kZXBvaW50OiAnICsgYltwXSk7XG4gICAgfVxuICAgIHRoaXMucG9zICs9IGJ5dGVzO1xuICAgIHJldHVybiBzdHI7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUucmVhZEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1Zi5zdWJhcnJheSh0aGlzLnBvcywgdGhpcy5wb3MgKyBieXRlcyk7XG4gICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFkUGFja2VkID0gZnVuY3Rpb24odHlwZSkge1xuICAgIC8vIFRPRE86IGJvdW5kcyBjaGVja2luZ1xuICAgIHZhciBieXRlcyA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcyArIGJ5dGVzO1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXNbJ3JlYWQnICsgdHlwZV0oKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odmFsKSB7XG4gICAgLy8gVE9ETzogYm91bmRzIGNoZWNraW5nXG4gICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8qIHZhcmludCAqLyBjYXNlIFByb3RvYnVmLlZhcmludDogd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdID4gMHg3Zik7IGJyZWFrO1xuICAgICAgICAvKiA2NCBiaXQgKi8gY2FzZSBQcm90b2J1Zi5JbnQ2NDogdGhpcy5wb3MgKz0gODsgYnJlYWs7XG4gICAgICAgIC8qIGxlbmd0aCAqLyBjYXNlIFByb3RvYnVmLk1lc3NhZ2U6IHZhciBieXRlcyA9IHRoaXMucmVhZFZhcmludCgpOyB0aGlzLnBvcyArPSBieXRlczsgYnJlYWs7XG4gICAgICAgIC8qIDMyIGJpdCAqLyBjYXNlIFByb3RvYnVmLkludDMyOiB0aGlzLnBvcyArPSA0OyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59O1xuXG4vLyA9PT0gV1JJVElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVUYWcgPSBmdW5jdGlvbih0YWcsIHR5cGUpIHtcbiAgICB0aGlzLndyaXRlVmFyaW50KCh0YWcgPDwgMykgfCB0eXBlKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS5yZWFsbG9jID0gZnVuY3Rpb24obWluKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoIDwgdGhpcy5wb3MgKyBtaW4pIGxlbmd0aCAqPSAyO1xuICAgIGlmIChsZW5ndGggIT0gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmKTtcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgfVxufTtcblxuUHJvdG9idWYucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLnBvcyk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVQYWNrZWQgPSBmdW5jdGlvbih0eXBlLCB0YWcsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciBtZXNzYWdlID0gbmV3IFByb3RvYnVmKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZXNzYWdlWyd3cml0ZScgKyB0eXBlXShpdGVtc1tpXSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gbWVzc2FnZS5maW5pc2goKTtcblxuICAgIHRoaXMud3JpdGVUYWcodGFnLCBQcm90b2J1Zi5QYWNrZWQpO1xuICAgIHRoaXMud3JpdGVCdWZmZXIoZGF0YSk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVVSW50MzIgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkVUludDMyID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuSW50MzIpO1xuICAgIHRoaXMud3JpdGVVSW50MzIodmFsKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVZhcmludCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgIHZhbCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8PSAweDdmKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh2YWwgPD0gMHgzZmZmKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYygyKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDgwIHwgKCh2YWwgPj4+IDApICYgMHg3Zik7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHgwMCB8ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmZikge1xuICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHg4MCB8ICgodmFsID4+PiAwKSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4ODAgfCAoKHZhbCA+Pj4gNykgJiAweDdmKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDAwIHwgKCh2YWwgPj4+IDE0KSAmIDB4N2YpO1xuICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4ZmZmZmZmZikge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gMHg4MCB8ICgodmFsID4+PiAwKSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4ODAgfCAoKHZhbCA+Pj4gNykgJiAweDdmKTtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAweDgwIHwgKCh2YWwgPj4+IDE0KSAmIDB4N2YpO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDB4MDAgfCAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbCA+IDApIHtcbiAgICAgICAgICAgIHZhciBiID0gdmFsICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gMTI4KTtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSBiIHw9IDB4ODBcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gYjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZFZhcmludCA9IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLlZhcmludCk7XG4gICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlU1ZhcmludCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh2YWwgPj0gMCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCAqIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsICogLTIgLSAxKTtcbiAgICB9XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVUYWdnZWRTVmFyaW50ID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuVmFyaW50KTtcbiAgICB0aGlzLndyaXRlU1ZhcmludCh2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZEJvb2xlYW4gPSBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgIHRoaXMud3JpdGVUYWdnZWRWYXJpbnQodGFnLCBCb29sZWFuKHZhbCkpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICB0aGlzLndyaXRlVmFyaW50KGJ5dGVzKTtcbiAgICB0aGlzLnJlYWxsb2MoYnl0ZXMpO1xuICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IGJ5dGVzO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlVGFnZ2VkU3RyaW5nID0gZnVuY3Rpb24odGFnLCBzdHIpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuU3RyaW5nKTtcbiAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVGbG9hdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICB0aGlzLmJ1Zi53cml0ZUZsb2F0TEUodmFsLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZEZsb2F0ID0gZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICB0aGlzLndyaXRlVGFnKHRhZywgUHJvdG9idWYuSW50MzIpO1xuICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlRG91YmxlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgIHRoaXMuYnVmLndyaXRlRG91YmxlTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZERvdWJsZSA9IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLkludDY0KTtcbiAgICB0aGlzLndyaXRlRG91YmxlKHZhbCk7XG59O1xuXG5Qcm90b2J1Zi5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSBieXRlcztcbn07XG5cblByb3RvYnVmLnByb3RvdHlwZS53cml0ZVRhZ2dlZEJ1ZmZlciA9IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLlN0cmluZyk7XG4gICAgdGhpcy53cml0ZUJ1ZmZlcihidWZmZXIpO1xufTtcblxuUHJvdG9idWYucHJvdG90eXBlLndyaXRlTWVzc2FnZSA9IGZ1bmN0aW9uKHRhZywgcHJvdG9idWYpIHtcbiAgICB2YXIgYnVmZmVyID0gcHJvdG9idWYuZmluaXNoKCk7XG4gICAgdGhpcy53cml0ZVRhZyh0YWcsIFByb3RvYnVmLk1lc3NhZ2UpO1xuICAgIHRoaXMud3JpdGVCdWZmZXIoYnVmZmVyKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgYWRkOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7ICAgICB9LFxuICAgIHN1YjogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHApOyAgICAgfSxcbiAgICBtdWx0OiAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX211bHQoayk7ICAgIH0sXG4gICAgZGl2OiAgICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7ICAgICB9LFxuICAgIHJvdGF0ZTogIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpOyAgfSxcbiAgICBtYXRNdWx0OiBmdW5jdGlvbihtKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7IH0sXG4gICAgdW5pdDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTsgfSxcbiAgICBwZXJwOiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcGVycCgpOyB9LFxuICAgIHJvdW5kOiAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpOyB9LFxuXG4gICAgbWFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdFNxcihwKSk7XG4gICAgfSxcblxuICAgIGRpc3RTcXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gYi55LCB0aGlzLnggLSBiLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVdpdGg6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKGIueCwgYi55KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzLCBzb2x2aW5nIHRoZSBmb3JtdWxhIGZvciB0aGUgY3Jvc3MgcHJvZHVjdCBhIHggYiA9IHxhfHxifHNpbijOuCkgZm9yIM64LlxuICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIHRoaXMueCAqIHkgLSB0aGlzLnkgKiB4LFxuICAgICAgICAgICAgdGhpcy54ICogeCArIHRoaXMueSAqIHkpO1xuICAgIH0sXG5cbiAgICBfbWF0TXVsdDogZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeCA9IG1bMF0gKiB0aGlzLnggKyBtWzFdICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggKz0gcC54O1xuICAgICAgICB0aGlzLnkgKz0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggLT0gcC54O1xuICAgICAgICB0aGlzLnkgLT0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX211bHQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54ICo9IGs7XG4gICAgICAgIHRoaXMueSAqPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RpdjogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggLz0gaztcbiAgICAgICAgdGhpcy55IC89IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wZXJwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICAgICAgdGhpcy54ID0gLXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGNvcyAqIHRoaXMueCAtIHNpbiAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gY29uc3RydWN0cyBQb2ludCBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuUG9pbnQuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICBmdW5jdGlvbiBxdWV1ZShwYXJhbGxlbGlzbSkge1xuICAgIHZhciBxLFxuICAgICAgICB0YXNrcyA9IFtdLFxuICAgICAgICBzdGFydGVkID0gMCwgLy8gbnVtYmVyIG9mIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHN0YXJ0ZWQgKGFuZCBwZXJoYXBzIGZpbmlzaGVkKVxuICAgICAgICBhY3RpdmUgPSAwLCAvLyBudW1iZXIgb2YgdGFza3MgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIChzdGFydGVkIGJ1dCBub3QgZmluaXNoZWQpXG4gICAgICAgIHJlbWFpbmluZyA9IDAsIC8vIG51bWJlciBvZiB0YXNrcyBub3QgeWV0IGZpbmlzaGVkXG4gICAgICAgIHBvcHBpbmcsIC8vIGluc2lkZSBhIHN5bmNocm9ub3VzIHRhc2sgY2FsbGJhY2s/XG4gICAgICAgIGVycm9yID0gbnVsbCxcbiAgICAgICAgYXdhaXQgPSBub29wLFxuICAgICAgICBhbGw7XG5cbiAgICBpZiAoIXBhcmFsbGVsaXNtKSBwYXJhbGxlbGlzbSA9IEluZmluaXR5O1xuXG4gICAgZnVuY3Rpb24gcG9wKCkge1xuICAgICAgd2hpbGUgKHBvcHBpbmcgPSBzdGFydGVkIDwgdGFza3MubGVuZ3RoICYmIGFjdGl2ZSA8IHBhcmFsbGVsaXNtKSB7XG4gICAgICAgIHZhciBpID0gc3RhcnRlZCsrLFxuICAgICAgICAgICAgdCA9IHRhc2tzW2ldLFxuICAgICAgICAgICAgYSA9IHNsaWNlLmNhbGwodCwgMSk7XG4gICAgICAgIGEucHVzaChjYWxsYmFjayhpKSk7XG4gICAgICAgICsrYWN0aXZlO1xuICAgICAgICB0WzBdLmFwcGx5KG51bGwsIGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlLCByKSB7XG4gICAgICAgIC0tYWN0aXZlO1xuICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IgPSBlOyAvLyBpZ25vcmUgbmV3IHRhc2tzIGFuZCBzcXVlbGNoIGFjdGl2ZSBjYWxsYmFja3NcbiAgICAgICAgICBzdGFydGVkID0gcmVtYWluaW5nID0gTmFOOyAvLyBzdG9wIHF1ZXVlZCB0YXNrcyBmcm9tIHN0YXJ0aW5nXG4gICAgICAgICAgbm90aWZ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFza3NbaV0gPSByO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZykgcG9wcGluZyB8fCBwb3AoKTtcbiAgICAgICAgICBlbHNlIG5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSBhd2FpdChlcnJvcik7XG4gICAgICBlbHNlIGlmIChhbGwpIGF3YWl0KGVycm9yLCB0YXNrcyk7XG4gICAgICBlbHNlIGF3YWl0LmFwcGx5KG51bGwsIFtlcnJvcl0uY29uY2F0KHRhc2tzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHEgPSB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICB0YXNrcy5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgICAgKytyZW1haW5pbmc7XG4gICAgICAgICAgcG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgYXdhaXQgPSBmO1xuICAgICAgICBhbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIG5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sXG4gICAgICBhd2FpdEFsbDogZnVuY3Rpb24oZikge1xuICAgICAgICBhd2FpdCA9IGY7XG4gICAgICAgIGFsbCA9IHRydWU7XG4gICAgICAgIGlmICghcmVtYWluaW5nKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIHF1ZXVlLnZlcnNpb24gPSBcIjEuMC43XCI7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gcXVldWU7IH0pO1xuICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IHF1ZXVlO1xuICBlbHNlIHRoaXMucXVldWUgPSBxdWV1ZTtcbn0pKCk7XG4iLCIvKlxuIChjKSAyMDEzLCBWbGFkaW1pciBBZ2Fmb25raW5cbiBSQnVzaCwgYSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGhpZ2gtcGVyZm9ybWFuY2UgMkQgc3BhdGlhbCBpbmRleGluZyBvZiBwb2ludHMgYW5kIHJlY3RhbmdsZXMuXG4gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2hcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KSB7XG5cbiAgICAvLyBqc2hpbnQgbmV3Y2FwOiBmYWxzZSwgdmFsaWR0aGlzOiB0cnVlXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHJidXNoKSkgeyByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7IH1cblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoIXRoaXMuX2ludGVyc2VjdHMoYmJveCwgbm9kZS5iYm94KSkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzdHJhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICAgICAgYmJveDogdGhpcy5fZW1wdHkoKSxcbiAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0pIHsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5vZGUuY2hpbGRyZW4uaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIHRoaXMuX2NvbnRhaW5zKG5vZGUuYmJveCwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgICAgICAgICBub2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSxcbiAgICBjb21wYXJlTWluWTogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGV2ZWwsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW1zLFxuICAgICAgICAgICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fY2FsY0JCb3gobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xuXG4gICAgICAgICAgICBpdGVtcy5zb3J0KHRoaXMuY29tcGFyZU1pblgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBlbGltaW5hdGUgcmVjdXJzaW9uP1xuXG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBOMSA9IE1hdGguY2VpbChOIC8gTSkgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcbiAgICAgICAgICAgIE4yID0gTWF0aC5jZWlsKE4gLyBNKSxcbiAgICAgICAgICAgIGNvbXBhcmUgPSBsZXZlbCAlIDIgPT09IDEgPyB0aGlzLmNvbXBhcmVNaW5YIDogdGhpcy5jb21wYXJlTWluWSxcbiAgICAgICAgICAgIGksIGosIHNsaWNlLCBzbGljZUxlbiwgY2hpbGROb2RlO1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSBOMSkge1xuICAgICAgICAgICAgc2xpY2UgPSBpdGVtcy5zbGljZShpLCBpICsgTjEpLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDAsIHNsaWNlTGVuID0gc2xpY2UubGVuZ3RoOyBqIDwgc2xpY2VMZW47IGogKz0gTjIpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSB0aGlzLl9idWlsZChzbGljZS5zbGljZShqLCBqICsgTjIpLCBsZXZlbCArIDEsIGhlaWdodCAtIDEpO1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsY0JCb3gobm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgeyBicmVhazsgfVxuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gdGhpcy5fYXJlYShjaGlsZC5iYm94KTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IHRoaXMuX2VubGFyZ2VkQXJlYShiYm94LCBjaGlsZC5iYm94KSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG5cbiAgICAgICAgdmFyIGJib3ggPSBpc05vZGUgPyBpdGVtLmJib3ggOiB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIHRoaXMuX2V4dGVuZChub2RlLmJib3gsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uc3BsaWNlKHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSkpLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChub2RlLmxlYWYpIHtcbiAgICAgICAgICAgIG5ld05vZGUubGVhZiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxjQkJveChub2RlKTtcbiAgICAgICAgdGhpcy5fY2FsY0JCb3gobmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgICAgICBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIHRoaXMuZGF0YS5jaGlsZHJlbiA9IFtub2RlLCBuZXdOb2RlXTtcbiAgICAgICAgdGhpcy5kYXRhLmhlaWdodCA9IG5vZGUuaGVpZ2h0ICsgMTtcbiAgICAgICAgdGhpcy5fY2FsY0JCb3godGhpcy5kYXRhKTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gdGhpcy5fZGlzdEJCb3gobm9kZSwgMCwgaSk7XG4gICAgICAgICAgICBiYm94MiA9IHRoaXMuX2Rpc3RCQm94KG5vZGUsIGksIE0pO1xuXG4gICAgICAgICAgICBvdmVybGFwID0gdGhpcy5faW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgYXJlYSA9IHRoaXMuX2FyZWEoYmJveDEpICsgdGhpcy5fYXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IHRoaXMuX2NvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IHRoaXMuX2NvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcblxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIGxlZnRCQm94ID0gdGhpcy5fZGlzdEJCb3gobm9kZSwgMCwgbSksXG4gICAgICAgICAgICByaWdodEJCb3ggPSB0aGlzLl9kaXN0QkJveChub2RlLCBNIC0gbSwgTSksXG4gICAgICAgICAgICBtYXJnaW4gPSB0aGlzLl9tYXJnaW4obGVmdEJCb3gpICsgdGhpcy5fbWFyZ2luKHJpZ2h0QkJveCksXG4gICAgICAgICAgICBpLCBjaGlsZDtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICAgICAgICAgIG1hcmdpbiArPSB0aGlzLl9tYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdGhpcy50b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gdGhpcy5fbWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG5cbiAgICAvLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuICAgIF9kaXN0QkJveDogZnVuY3Rpb24gKG5vZGUsIGssIHApIHtcbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLl9lbXB0eSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW5kKGJib3gsIG5vZGUubGVhZiA/IHRoaXMudG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcblxuICAgIC8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbiAgICBfY2FsY0JCb3g6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuYmJveCA9IHRoaXMuX2Rpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLl9leHRlbmQocGF0aFtpXS5iYm94LCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgcGFyZW50OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc3BsaWNlKHBhcmVudC5pbmRleE9mKHBhdGhbaV0pLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjQkJveChwYXRoW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29udGFpbnM6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPD0gYlswXSAmJlxuICAgICAgICAgICAgICAgYVsxXSA8PSBiWzFdICYmXG4gICAgICAgICAgICAgICBiWzJdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgICAgIGJbM10gPD0gYVszXTtcbiAgICB9LFxuXG4gICAgX2ludGVyc2VjdHM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiWzBdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgICAgIGJbMV0gPD0gYVszXSAmJlxuICAgICAgICAgICAgICAgYlsyXSA+PSBhWzBdICYmXG4gICAgICAgICAgICAgICBiWzNdID49IGFbMV07XG4gICAgfSxcblxuICAgIF9leHRlbmQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGFbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICAgICAgYVsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICBhWzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgICAgIGFbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIF9hcmVhOiAgIGZ1bmN0aW9uIChhKSB7IHJldHVybiAoYVsyXSAtIGFbMF0pICogKGFbM10gLSBhWzFdKTsgfSxcbiAgICBfbWFyZ2luOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGFbMl0gLSBhWzBdKSArIChhWzNdIC0gYVsxXSk7IH0sXG5cbiAgICBfZW5sYXJnZWRBcmVhOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKE1hdGgubWF4KGJbMl0sIGFbMl0pIC0gTWF0aC5taW4oYlswXSwgYVswXSkpICpcbiAgICAgICAgICAgICAgIChNYXRoLm1heChiWzNdLCBhWzNdKSAtIE1hdGgubWluKGJbMV0sIGFbMV0pKTtcbiAgICB9LFxuXG4gICAgX2ludGVyc2VjdGlvbkFyZWE6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYVswXSwgYlswXSksXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYVsxXSwgYlsxXSksXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5taW4oYVsyXSwgYlsyXSksXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG4gICAgfSxcblxuICAgIF9lbXB0eTogZnVuY3Rpb24gKCkgeyByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldOyB9LFxuXG4gICAgX2NvbXBhcmVOb2RlTWluWDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuYmJveFswXSAtIGIuYmJveFswXTsgfSxcbiAgICBfY29tcGFyZU5vZGVNaW5ZOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5iYm94WzFdIC0gYi5iYm94WzFdOyB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgLy8ganNoaW50IGV2aWw6IHRydWVcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLCAncmV0dXJuIFthJyArIGZvcm1hdC5qb2luKCcsIGEnKSArICddOycpO1xuICAgIH1cbn07XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYnVzaDtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzZWxmLnJidXNoID0gcmJ1c2g7XG59IGVsc2Uge1xuICAgIHdpbmRvdy5yYnVzaCA9IHJidXNoO1xufVxuXG59KSgpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFBvcnRlZCBmcm9tIFdlYmtpdFxuICogaHR0cDovL3N2bi53ZWJraXQub3JnL3JlcG9zaXRvcnkvd2Via2l0L3RydW5rL1NvdXJjZS9XZWJDb3JlL3BsYXRmb3JtL2dyYXBoaWNzL1VuaXRCZXppZXIuaFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVW5pdEJlemllcjtcblxuZnVuY3Rpb24gVW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLCBpbXBsaWNpdCBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50cyBhcmUgKDAsMCkgYW5kICgxLDEpLlxuICAgIHRoaXMuY3ggPSAzLjAgKiBwMXg7XG4gICAgdGhpcy5ieCA9IDMuMCAqIChwMnggLSBwMXgpIC0gdGhpcy5jeDtcbiAgICB0aGlzLmF4ID0gMS4wIC0gdGhpcy5jeCAtIHRoaXMuYng7XG5cbiAgICB0aGlzLmN5ID0gMy4wICogcDF5O1xuICAgIHRoaXMuYnkgPSAzLjAgKiAocDJ5IC0gcDF5KSAtIHRoaXMuY3k7XG4gICAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5O1xuXG4gICAgdGhpcy5wMXggPSBwMXg7XG4gICAgdGhpcy5wMXkgPSBwMnk7XG4gICAgdGhpcy5wMnggPSBwMng7XG4gICAgdGhpcy5wMnkgPSBwMnk7XG59XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAvLyBgYXggdF4zICsgYnggdF4yICsgY3ggdCcgZXhwYW5kZWQgdXNpbmcgSG9ybmVyJ3MgcnVsZS5cbiAgICByZXR1cm4gKCh0aGlzLmF4ICogdCArIHRoaXMuYngpICogdCArIHRoaXMuY3gpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgzLjAgKiB0aGlzLmF4ICogdCArIDIuMCAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICBpZiAodHlwZW9mIGVwc2lsb24gPT09ICd1bmRlZmluZWQnKSBlcHNpbG9uID0gMWUtNjtcblxuICAgIHZhciB0MCwgdDEsIHQyLCB4MiwgaTtcblxuICAgIC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG4gICAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSBicmVhaztcblxuICAgICAgICB0MiA9IHQyIC0geDIgLyBkMjtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGJpc2VjdGlvbiBtZXRob2QgZm9yIHJlbGlhYmlsaXR5LlxuICAgIHQwID0gMC4wO1xuICAgIHQxID0gMS4wO1xuICAgIHQyID0geDtcblxuICAgIGlmICh0MiA8IHQwKSByZXR1cm4gdDA7XG4gICAgaWYgKHQyID4gdDEpIHJldHVybiB0MTtcblxuICAgIHdoaWxlICh0MCA8IHQxKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIGlmICh4ID4geDIpIHtcbiAgICAgICAgICAgIHQwID0gdDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICB9XG5cbiAgICAgICAgdDIgPSAodDEgLSB0MCkgKiAwLjUgKyB0MDtcbiAgICB9XG5cbiAgICAvLyBGYWlsdXJlLlxuICAgIHJldHVybiB0Mjtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZUN1cnZlWSh0aGlzLnNvbHZlQ3VydmVYKHgsIGVwc2lsb24pKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWxheWVyLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVsYXllcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGUoYnVmZmVyLCBlbmQpIHtcblxuICAgIHRoaXMubGF5ZXJzID0ge307XG4gICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgIHRhZyA9IHZhbCA+PiAzO1xuXG4gICAgICAgIGlmICh0YWcgPT0gMykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5yZWFkTGF5ZXIoKTtcbiAgICAgICAgICAgIGlmIChsYXllci5sZW5ndGgpIHRoaXMubGF5ZXJzW2xheWVyLm5hbWVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlLnByb3RvdHlwZS5yZWFkTGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyLFxuICAgICAgICBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcyxcbiAgICAgICAgbGF5ZXIgPSBuZXcgVmVjdG9yVGlsZUxheWVyKGJ1ZmZlciwgZW5kKTtcblxuICAgIGJ1ZmZlci5wb3MgPSBlbmQ7XG5cbiAgICByZXR1cm4gbGF5ZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShidWZmZXIsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcblxuICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuXG4gICAgLy8gUHVibGljXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgdGhpcy50eXBlID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSAtMTtcblxuICAgIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSAyKSB7XG4gICAgICAgICAgICB2YXIgdGFnRW5kID0gYnVmZmVyLnBvcyArIGJ1ZmZlci5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIucG9zIDwgdGFnRW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbYnVmZmVyLnJlYWRWYXJpbnQoKV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2J1ZmZlci5yZWFkVmFyaW50KCldO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA0KSB7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyA9IFsnVW5rbm93bicsICdQb2ludCcsICdMaW5lU3RyaW5nJywgJ1BvbHlnb24nXTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgYnVmZmVyLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgZW5kID0gYnVmZmVyLnBvcyArIGJ5dGVzLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIGxpbmVzID0gW10sXG4gICAgICAgIGxpbmU7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZF9sZW5ndGggPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kX2xlbmd0aCAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZF9sZW5ndGggPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcblxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmVUb1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZS5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSA3KSB7XG4gICAgICAgICAgICAvLyBjbG9zZVBvbHlnb25cbiAgICAgICAgICAgIGxpbmUucHVzaChsaW5lWzBdLmNsb25lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcblxuICAgIHJldHVybiBsaW5lcztcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICBidWZmZXIucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgYnl0ZXMgPSBidWZmZXIucmVhZFZhcmludCgpLFxuICAgICAgICBlbmQgPSBidWZmZXIucG9zICsgYnl0ZXMsXG5cbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZF9sZW5ndGggPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kX2xlbmd0aCAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZF9sZW5ndGggPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBidWZmZXIucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlTGF5ZXI7XG5mdW5jdGlvbiBWZWN0b3JUaWxlTGF5ZXIoYnVmZmVyLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG5cbiAgICB2YXIgdmFsLCB0YWc7XG5cbiAgICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aDtcblxuICAgIHdoaWxlIChidWZmZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhbCA9IGJ1ZmZlci5yZWFkVmFyaW50KCk7XG4gICAgICAgIHRhZyA9IHZhbCA+PiAzO1xuXG4gICAgICAgIGlmICh0YWcgPT09IDE1KSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDUpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50ID0gYnVmZmVyLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKGJ1ZmZlci5wb3MpO1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGJ1ZmZlci5yZWFkU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godGhpcy5yZWFkRmVhdHVyZVZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVmVjdG9yVGlsZUxheWVyLnByb3RvdHlwZS5yZWFkRmVhdHVyZVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcixcbiAgICAgICAgdmFsdWUgPSBudWxsLFxuICAgICAgICBieXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IGJ1ZmZlci5wb3MgKyBieXRlcyxcbiAgICAgICAgdmFsLCB0YWc7XG5cbiAgICB3aGlsZSAoYnVmZmVyLnBvcyA8IGVuZCkge1xuICAgICAgICB2YWwgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB0YWcgPSB2YWwgPj4gMztcblxuICAgICAgICBpZiAodGFnID09IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFkIGZsb2F0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09IDMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLnJlYWREb3VibGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gNCkge1xuICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIucmVhZFZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWQgdWludCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA2KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5yZWFkU1ZhcmludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PSA3KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJvb2xlYW4oYnVmZmVyLnJlYWRWYXJpbnQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9idWZmZXIucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG4gICAgdmFyIGVuZCA9IHRoaXMuX2J1ZmZlci5yZWFkVmFyaW50KCkgKyB0aGlzLl9idWZmZXIucG9zO1xuXG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9idWZmZXIsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIl19
